/-
Copyright (c) 2025 leantest-afp contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: leantest-afp contributors
-/
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import LeantestAfp.Probability.Ergodic.KoopmanMeanErgodic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2

/-!
# Shift-invariant œÉ-algebra and conditional expectation

This file defines the shift-invariant œÉ-algebra on path space and establishes
the fundamental connection between:
- The fixed-point subspace of the Koopman operator
- The L¬≤ space with respect to the shift-invariant œÉ-algebra
- The conditional expectation onto the shift-invariant œÉ-algebra

## Main definitions

* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The œÉ-algebra of shift-invariant sets.
* `fixedSubspace`: The subspace of L¬≤ functions fixed by the Koopman operator.

## Main results

* `mem_shiftInvariantSigma_iff`: Characterization of membership in the invariant œÉ-algebra.
* `fixedSpace_eq_invMeasurable`: Functions fixed by Koopman are exactly those
  measurable with respect to the shift-invariant œÉ-algebra.
* `proj_eq_condexp`: The orthogonal projection onto the fixed-point subspace equals
  the conditional expectation onto the shift-invariant œÉ-algebra.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant œÉ-algebra is denoted
  ùìò_Œæ in Kallenberg.

-/

noncomputable section

open scoped Classical

namespace LeantestAfp.Probability.DeFinetti

open MeasureTheory Filter Topology
open LeantestAfp.Probability.Ergodic

variable {Œ± : Type*} [MeasurableSpace Œ±]

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Œ©[Œ±])) : Prop :=
  MeasurableSet s ‚àß shift ‚Åª¬π' s = s

lemma isShiftInvariant_iff (s : Set (Œ©[Œ±])) :
    isShiftInvariant s ‚Üî MeasurableSet s ‚àß ‚àÄ œâ, shift œâ ‚àà s ‚Üî œâ ‚àà s := by
  constructor
  ¬∑ intro ‚ü®hm, heq‚ü©
    exact ‚ü®hm, fun œâ => by rw [‚Üê Set.mem_preimage, heq]‚ü©
  ¬∑ intro ‚ü®hm, hiff‚ü©
    refine ‚ü®hm, Set.ext fun œâ => ?_‚ü©
    simp [hiff]

/-- The shift-invariant œÉ-algebra: the collection of shift-invariant sets.

For now we define this axiomatically; a full construction would use the œÉ-algebra
generated by shift-invariant sets or the comap construction.
-/
def shiftInvariantSigma : MeasurableSpace (Œ©[Œ±]) where
  MeasurableSet' := fun s => isShiftInvariant (Œ± := Œ±) s
  measurableSet_empty := by
    refine ‚ü®measurableSet_empty, ?_‚ü©
    simp
  measurableSet_compl := by
    intro s hs
    obtain ‚ü®hs_meas, hs_eq‚ü© := hs
    refine ‚ü®hs_meas.compl, ?_‚ü©
    simpa [Set.preimage_compl, hs_eq, Set.compl_compl]
  measurableSet_iUnion := by
    intro f hf
    refine ‚ü®measurableSet_iUnion fun n => (hf n).left, ?_‚ü©
    ext œâ
    simp [Set.preimage_iUnion, hf]

lemma shiftInvariantSigma_le :
    shiftInvariantSigma ‚â§ (inferInstance : MeasurableSpace (Œ©[Œ±])) := by
  intro s hs
  exact (hs : isShiftInvariant (Œ± := Œ±) s).1

lemma mem_shiftInvariantSigma_iff (s : Set (Œ©[Œ±])) :
    @MeasurableSet _ shiftInvariantSigma s ‚Üî isShiftInvariant (Œ± := Œ±) s :=
  Iff.rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Œ©[Œ±] ‚Üí ‚Ñù)
    (hg : @Measurable _ shiftInvariantSigma _ g) :
    (fun œâ => g (shift œâ)) = g := by
  classical
  ext œâ
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases' hlt_or with hlt hgt
  ¬∑ -- Case `g (shift œâ) < g œâ`
    obtain ‚ü®q, hltq, hqœâ‚ü© := exists_rat_btwn hlt
    have hset_eq := (hg (MeasurableSet_Iio (q : ‚Ñù))).2
    have h_shift_mem : shift œâ ‚àà g ‚Åª¬π' Set.Iio (q : ‚Ñù) := by
      simpa [Set.mem_preimage] using hltq
    have h_pre : œâ ‚àà shift ‚Åª¬π' (g ‚Åª¬π' Set.Iio (q : ‚Ñù)) := by
      simpa [Set.mem_preimage] using h_shift_mem
    have h_mem : œâ ‚àà g ‚Åª¬π' Set.Iio (q : ‚Ñù) := by
      simpa [hset_eq] using h_pre
    have : g œâ < (q : ‚Ñù) := by
      simpa [Set.mem_preimage] using h_mem
    have : g œâ < g œâ := lt_trans this hqœâ
    exact lt_irrefl _ this
  ¬∑ -- Case `g œâ < g (shift œâ)`
    obtain ‚ü®q, hœâq, hq_lt‚ü© := exists_rat_btwn hgt
    have hset_eq := (hg (MeasurableSet_Ioi (q : ‚Ñù))).2
    have h_shift_mem : shift œâ ‚àà g ‚Åª¬π' Set.Ioi (q : ‚Ñù) := by
      simpa [Set.mem_preimage] using hq_lt
    have h_pre : œâ ‚àà shift ‚Åª¬π' (g ‚Åª¬π' Set.Ioi (q : ‚Ñù)) := by
      simpa [Set.mem_preimage] using h_shift_mem
    have h_mem : œâ ‚àà g ‚Åª¬π' Set.Ioi (q : ‚Ñù) := by
      simpa [hset_eq] using h_pre
    have : (q : ‚Ñù) < g œâ := by
      simpa [Set.mem_preimage] using h_mem
    have : g œâ < g œâ := lt_trans hœâq this
    exact lt_irrefl _ this

/-- A function is measurable with respect to the shift-invariant œÉ-algebra iff
it is (a.e.) constant along shift orbits. -/
lemma invMeasurable_iff_shiftInvariant {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (_hœÉ : MeasurePreserving shift Œº Œº) (g : Œ©[Œ±] ‚Üí ‚Ñù) :
    (‚àÄ·µê œâ ‚àÇŒº, g (shift œâ) = g œâ) ‚Üí
    (@Measurable _ _ shiftInvariantSigma _ g ‚Üí
     ‚àÄ·µê œâ ‚àÇŒº, g (shift œâ) = g œâ) := by
  intro _ hmeas
  refine eventually_of_forall ?_
  intro œâ
  have hfun := congrArg (fun f => f œâ) (shiftInvariantSigma_measurable_shift_eq g hmeas)
  simpa using hfun

/-- Functions that are `AEStronglyMeasurable` with respect to the invariant œÉ-algebra are
almost everywhere fixed by the shift. -/
lemma shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) {f : Œ©[Œ±] ‚Üí ‚Ñù}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº) :
    (fun œâ => f (shift œâ)) =·µê[Œº] f := by
  classical
  rcases hf with ‚ü®g, hg_meas, hfg‚ü©
  have hcomp :=
    (hœÉ.quasiMeasurePreserving).ae_eq_comp (Œº := Œº) (ŒΩ := Œº)
      (f := shift (Œ± := Œ±)) (g := fun œâ => f œâ) (g' := fun œâ => g œâ) hfg
  have hshift : (fun œâ => g (shift œâ)) =·µê[Œº] g :=
    EventuallyEq.of_eq (shiftInvariantSigma_measurable_shift_eq g hg_meas.measurable)
  exact hcomp.trans <| hshift.trans hfg.symm

/-- If an `Lp` function is measurable with respect to the invariant œÉ-algebra, the Koopman
operator fixes it. -/
lemma koopman_eq_self_of_shiftInvariant
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f : Lp ‚Ñù 2 Œº}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº) :
    koopman shift hœÉ f = f := by
  classical
  have hcomp :
      (koopman shift hœÉ f) =·µê[Œº]
        (fun œâ => f (shift œâ)) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Œ± := Œ±)) hœÉ f =·µê[Œº]
        fun œâ => f (shift œâ)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving (Œº := Œº) (Œºb := Œº)
            (p := (2 : ‚Ñù‚â•0‚àû)) f hœÉ)
  have hshift := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq (Œº := Œº) hœÉ hf
  have hfinal : (koopman shift hœÉ f) =·µê[Œº] f := hcomp.trans hshift
  exact Lp.ext hfinal

/-- A Koopman-fixed function should be measurable with respect to the invariant œÉ-algebra.

The key step is to modify a representative of `f` on a null set so that it becomes
pointwise invariant under the shift; the resulting function will then be
`shiftInvariantSigma`-measurable by construction. -/
lemma aestronglyMeasurable_shiftInvariant_of_koopman
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f : Lp ‚Ñù 2 Œº}
    (hfix : koopman shift hœÉ f = f) :
    AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº := by
  classical
  /-
  Proof strategy sketch:
  1. Unfold the equality `koopman shift hœÉ f = f` to obtain the almost-everywhere
     identity `(fun œâ => f (shift œâ)) =·µê[Œº] f`.
  2. Choose a strongly measurable representative `g` of `f`.
  3. Modify `g` on the Œº-null set where the shift invariance fails to build a
     pointwise invariant function `g'` with `g' = g` almost everywhere.
  4. Perform the null-set modification inductively along the orbit to ensure
     `g' ‚àò shift = g'` on the nose.
  5. Conclude that the preimage of any Borel set under `g'` is shift-invariant,
     hence belongs to `shiftInvariantSigma` by definition, giving the desired
     measurability.
  6. Finally transport this back to the original `f` using the `AE` equality.

  Implementing steps (3)‚Äì(5) will likely require a bespoke lemma about
  modifying functions on null sets to enforce invariance; this will be filled in
  later.
  -/
  -- STEP 1. Extract the a.e. invariance statement from `koopman` equality.
  have hshift : (fun œâ => f (shift œâ)) =·µê[Œº] f := by
    have := congrArg (fun g : Lp ‚Ñù 2 Œº => g) hfix
    exact this
  -- STEP 2. Choose a strongly measurable representative of `f`.
  have hf_base : AEStronglyMeasurable f Œº := by
    simpa using (Lp.aestronglyMeasurable (Œº := Œº) (p := (2 : ‚Ñù‚â•0‚àû)) f)
  obtain ‚ü®g, hg_meas, hfg‚ü© := hf_base
  -- Transport the a.e. invariance to the chosen representative.
  have hshift_g : (fun œâ => g (shift œâ)) =·µê[Œº] g := by
    have hcomp := (hœÉ.quasiMeasurePreserving.ae_eq_comp hfg)
    have hcomp' : (fun œâ => g (shift œâ)) =·µê[Œº] (fun œâ => f (shift œâ)) := by
      simpa using hcomp
    have hshift' : (fun œâ => f (shift œâ)) =·µê[Œº] g := hshift.trans hfg
    exact hcomp'.trans hshift'
  -- STEP 3. Record the full-measure set on which the representative is pointwise invariant.
  let S : Set (Œ©[Œ±]) := {œâ | g (shift œâ) = g œâ}
  have hS_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà S := by
    simpa [S, Set.mem_setOf_eq] using hshift_g
  have hS_null : Œº S·∂ú = 0 := by
    simpa [ae_iff, S, Set.mem_setOf_eq] using hS_ae
  -- TODO: Define `S‚àû := ‚ãÇ n, (shift^[n]) ‚Åª¬π' S` and prove it has full Œº-measure using the
  -- measure-preserving property of the iterates of `shift`.
  -- TODO: show that `S` is measurable and construct the iterated invariant set `S‚àû`.
  -- TODO: Continue by modifying a representative of `f` on a null set to obtain a pointwise
  -- shift-invariant function and use it to show `f` is measurable w.r.t. `shiftInvariantSigma`.
  sorry

/-- The fixed-point subspace of the Koopman operator.

This is the closed subspace of L¬≤(Œº) consisting of equivalence classes of functions
f such that f ‚àò shift = f almost everywhere.
-/
def fixedSubspace {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) : Submodule ‚Ñù (Lp ‚Ñù 2 Œº) :=
  fixedSpace (koopman shift hœÉ)

/-- Functions in the fixed-point subspace are exactly those that are a.e. invariant under shift. -/
lemma mem_fixedSubspace_iff {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) (f : Lp ‚Ñù 2 Œº) :
    f ‚àà fixedSubspace hœÉ ‚Üî koopman shift hœÉ f = f := by
  rfl

/-- The orthogonal projection onto the fixed-point subspace exists (as a closed subspace). -/
lemma fixedSubspace_closed {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    IsClosed (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  let T := koopman shift hœÉ
  have hset : (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) =
      (fun f : Lp ‚Ñù 2 Œº => T f - f) ‚Åª¬π' ({0} : Set (Lp ‚Ñù 2 Œº)) := by
    ext f
    rfl
  have hcont : Continuous fun f : Lp ‚Ñù 2 Œº => T f - f :=
    (T.continuous.sub continuous_id)
  have hclosed : IsClosed ((fun f : Lp ‚Ñù 2 Œº => T f - f) ‚Åª¬π'
      ({0} : Set (Lp ‚Ñù 2 Œº))) :=
    IsClosed.preimage hcont isClosed_singleton
  simpa [hset]

/-- Conditional expectation on L¬≤ can be viewed as an orthogonal projection.

For a sub-œÉ-algebra ùìñ, the conditional expectation condexp[ùìñ] is the orthogonal
projection from L¬≤(Œº) onto L¬≤(ùìñ), the closed subspace of functions measurable
with respect to ùìñ.

TODO: Use mathlib's condexpL2 once we have the proper sub-œÉ-algebra instance.
-/
noncomputable def condexpL2 {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº] :
    Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº :=
  ((lpMeas ‚Ñù ‚Ñù (shiftInvariantSigma (Œ± := Œ±)) 2 Œº).subtypeL).comp
    (MeasureTheory.condExpL2 ‚Ñù ‚Ñù (shiftInvariantSigma_le (Œ± := Œ±)))

/-- Key theorem: The orthogonal projection onto the fixed-point subspace of the Koopman
operator equals the conditional expectation onto the shift-invariant œÉ-algebra.

This is the bridge between ergodic theory (operator fixed points) and probability
(conditional expectation).
-/
theorem proj_eq_condexp {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    ‚àÉ (P : Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº),
      (‚àÄ f, f ‚àà fixedSubspace hœÉ ‚Üí P f = f) ‚àß
      (‚àÄ f, P f = condexpL2 shiftInvariantSigma f) := by
  /-
  Sketch of proof:
  1. Let `P‚ÇÄ := (lpMeas ‚Ä¶).orthogonalProjection`. Observe that our definition of `condexpL2`
     is `subtypeL.comp P‚ÇÄ`, so showing `P‚ÇÄ` equals the orthogonal projection onto
     `fixedSubspace hœÉ` is enough.
  2. Build the equivalence of subspaces.
     * (Forward) If `g` is `shiftInvariantSigma`-measurable, then `g ‚àò shift = g` a.e.
       Produce a lemma
         `lemma shiftInvariantSigma_measurable_aestronglyMeasurable
             (hg : AEStronglyMeasurable[m] g Œº) : g ‚àò shift =·µê Œº g`.
       This will use that measurable sets in `shiftInvariantSigma` are invariant by the
       definition of the œÉ-algebra, together with the fact that evaluation maps on `Œ©[Œ±]`
       generate the œÉ-algebra.
     * (Reverse) If `koopman shift hœÉ f = f`, then `f` is invariant a.e.  Use the
       representatives lemma for `Lp` to get an a.e. equal function `g`. Show that `g` is
       measurable w.r.t. `shiftInvariantSigma` by proving that its level sets belong to
       the invariant œÉ-algebra.  A convenient way is to start with simple functions,
       use stability of the invariant œÉ-algebra under limits, and appeal to the
       dominated convergence theorem.
  3. Once the two closed subspaces agree, uniqueness of orthogonal projections yields the
     desired statement (cf. `Submodule.orthogonalProjection_eq_self_of_subset`).
  4. Finally, wrap up: choose `P := condexpL2 shiftInvariantSigma` and show it satisfies the
     two characterising properties using the two inclusions from step 2.
  -/
  sorry

/-- The range of conditional expectation onto the invariant œÉ-algebra equals
the fixed-point subspace. -/
lemma range_condexp_eq_fixedSubspace {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    Set.range (condexpL2 shiftInvariantSigma) =
    (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  ext f
  constructor
  ¬∑ -- (‚äÜ) Range of condexpL2 ‚äÜ fixedSubspace
    intro ‚ü®g, hg‚ü©
    rw [‚Üê hg]
    -- condexpL2 g is measurable w.r.t. shiftInvariantSigma
    -- hence invariant under shift, so Koopman fixes it
    classical
    have hmeas :
        AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)]
          (condexpL2 shiftInvariantSigma g : Œ©[Œ±] ‚Üí ‚Ñù) Œº := by
      simpa using
        (lpMeas.aestronglyMeasurable
          (MeasureTheory.condExpL2 ‚Ñù ‚Ñù (shiftInvariantSigma_le (Œ± := Œ±)) g))
    have hkoop :=
      koopman_eq_self_of_shiftInvariant (hœÉ := hœÉ) hmeas
    exact (mem_fixedSubspace_iff (hœÉ := hœÉ)
        (f := condexpL2 shiftInvariantSigma g)).mpr hkoop
  ¬∑ -- (‚äá) fixedSubspace ‚äÜ Range of condexpL2
    intro hf
    -- If f is fixed by Koopman, then f is shift-invariant a.e.
    -- hence measurable w.r.t. shiftInvariantSigma
    -- so f = condexpL2 f
    use f
    /-
    Outline:
    1. Starting from `hf : f ‚àà fixedSubspace hœÉ`, use `mem_fixedSubspace_iff` to get the
       almost everywhere invariance of `f` under `shift`.
    2. Produce a representative that is strictly invariant on a Œº-a.e. invariant set,
       then prove it is `shiftInvariantSigma`-measurable (reverse inclusion lemma).
    3. Invoke the defining property of conditional expectation on `Lp` to conclude that
       `condexpL2 shiftInvariantSigma f = f`.
    -/
    sorry

end LeantestAfp.Probability.DeFinetti
