/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.MeasurableSpace.Basic
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Exchangeability.PathSpace.Shift

/-!
# Shift-invariant Ïƒ-algebra on path space

This file defines the shift-invariant Ïƒ-algebra on path space and establishes
basic measurability properties.

## Main definitions

* `tailSigma`: The tail Ïƒ-algebra generated by the iterates of the left shift.
* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The Ïƒ-algebra of shift-invariant sets.

## Main results

* `isShiftInvariant_iff`: Characterization of shift-invariance in terms of membership.
* `shiftInvariantSigma_le`: The shift-invariant Ïƒ-algebra is a sub-Ïƒ-algebra.
* `mem_shiftInvariantSigma_iff`: Membership in the invariant Ïƒ-algebra.
* `shiftInvariantSigma_measurable_shift_eq`: Shift-invariant measurability forces
  pointwise invariance under the shift map.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant Ïƒ-algebra is denoted
  ð“˜_Î¾ in Kallenberg.
* FMP 10.4: Invariant sets and functions (Chapter 10, pages 180-181).

-/

noncomputable section

open scoped Classical Topology

namespace Exchangeability.DeFinetti

open MeasureTheory Filter Topology
open Exchangeability.PathSpace

variable {Î± : Type*} [MeasurableSpace Î±]

/-- The tail Ïƒ-algebra generated by the iterates of the left shift on path space. -/
def tailSigma : MeasurableSpace (Î©[Î±]) :=
  â¨… n : â„•, MeasurableSpace.comap (fun Ï‰ => (shift^[n]) Ï‰) inferInstance

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Î©[Î±])) : Prop :=
  MeasurableSet s âˆ§ shift â»Â¹' s = s

lemma isShiftInvariant_iff {s : Set (Î©[Î±])} :
    isShiftInvariant s â†” MeasurableSet s âˆ§ âˆ€ Ï‰, shift Ï‰ âˆˆ s â†” Ï‰ âˆˆ s := by
  constructor
  Â· intro âŸ¨hm, heqâŸ©
    exact âŸ¨hm, fun Ï‰ => by rw [â† Set.mem_preimage, heq]âŸ©
  Â· intro âŸ¨hm, hiffâŸ©
    refine âŸ¨hm, Set.ext fun Ï‰ => ?_âŸ©
    simp [hiff]

/-- The shift-invariant Ïƒ-algebra: the collection of shift-invariant sets.

This is defined directly as the sub-Ïƒ-algebra of measurable shift-invariant sets.
-/
def shiftInvariantSigma : MeasurableSpace (Î©[Î±]) where
  MeasurableSet' := fun s => isShiftInvariant (Î± := Î±) s
  measurableSet_empty := by
    refine âŸ¨MeasurableSet.empty, ?_âŸ©
    simp
  measurableSet_compl := by
    intro s hs
    obtain âŸ¨hs_meas, hs_eqâŸ© := hs
    refine âŸ¨hs_meas.compl, ?_âŸ©
    simp [Set.preimage_compl, hs_eq]
  measurableSet_iUnion := by
    intro f hf
    refine âŸ¨MeasurableSet.iUnion fun n => (hf n).1, ?_âŸ©
    simp only [Set.preimage_iUnion]
    ext Ï‰
    simp only [Set.mem_iUnion, Set.mem_preimage]
    constructor
    Â· intro âŸ¨i, hiâŸ©
      use i
      -- hi : shift Ï‰ âˆˆ f i
      -- By (hf i), f i is shift-invariant: shift Ï‰ âˆˆ f i â†” Ï‰ âˆˆ f i
      have := isShiftInvariant_iff.1 (hf i)
      exact (this.2 Ï‰).1 hi
    Â· intro âŸ¨i, hiâŸ©
      use i
      -- hi : Ï‰ âˆˆ f i
      -- By (hf i), f i is shift-invariant: shift Ï‰ âˆˆ f i â†” Ï‰ âˆˆ f i
      have := isShiftInvariant_iff.1 (hf i)
      exact (this.2 Ï‰).2 hi

lemma shiftInvariantSigma_le :
    shiftInvariantSigma â‰¤ (inferInstance : MeasurableSpace (Î©[Î±])) := by
  intro s hs
  exact hs.1

lemma mem_shiftInvariantSigma_iff {s : Set (Î©[Î±])} :
    @MeasurableSet _ shiftInvariantSigma s â†” isShiftInvariant (Î± := Î±) s := by
  rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Î©[Î±] â†’ â„)
    (hg : Measurable[shiftInvariantSigma] g) :
    (fun Ï‰ => g (shift Ï‰)) = g := by
  classical
  ext Ï‰
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases hlt_or with
  | inl hlt =>
      -- Case `g (shift Ï‰) < g Ï‰`
      obtain âŸ¨q, hltq, hqÏ‰âŸ© := exists_rat_btwn hlt
      have hmeas : MeasurableSet (Set.Iio (q : â„)) :=
        (isOpen_Iio : IsOpen (Set.Iio (q : â„))).measurableSet
      have hset_eq := (hg hmeas : isShiftInvariant (g â»Â¹' Set.Iio â†‘q)).2
      have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
        simpa [Set.mem_preimage] using hltq
      have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Iio (q : â„)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
        simpa [hset_eq] using h_pre
      have : g Ï‰ < (q : â„) := by
        simpa [Set.mem_preimage] using h_mem
      have : g Ï‰ < g Ï‰ := lt_trans this hqÏ‰
      exact lt_irrefl _ this
  | inr hgt =>
      -- Case `g Ï‰ < g (shift Ï‰)`
      obtain âŸ¨q, hÏ‰q, hq_ltâŸ© := exists_rat_btwn hgt
      have hmeas : MeasurableSet (Set.Ioi (q : â„)) :=
        (isOpen_Ioi : IsOpen (Set.Ioi (q : â„))).measurableSet
      have hset_eq := (hg hmeas : isShiftInvariant (g â»Â¹' Set.Ioi â†‘q)).2
      have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
        simpa [Set.mem_preimage] using hq_lt
      have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Ioi (q : â„)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
        simpa [hset_eq] using h_pre
      have : (q : â„) < g Ï‰ := by
        simpa [Set.mem_preimage] using h_mem
      have : g Ï‰ < g Ï‰ := lt_trans hÏ‰q this
      exact lt_irrefl _ this

-- Helper: Measurability of iterated shifts follows from measurability of `shift`.
lemma shift_iterate_measurable (n : â„•) :
    Measurable (shift^[n] : Î©[Î±] â†’ Î©[Î±]) := by
  simpa using measurable_shift.iterate n

/-- A function that is pointwise shift-invariant and measurable is
    measurable with respect to the shift-invariant Ïƒ-algebra. -/
lemma shiftInvariant_implies_shiftInvariantMeasurable
    (g : Î©[Î±] â†’ â„) (hg : Measurable g)
    (hinv : âˆ€ Ï‰, g (shift Ï‰) = g Ï‰) :
    Measurable[shiftInvariantSigma] g := by
  intro t ht
  have hpreimage : MeasurableSet (g â»Â¹' t) := hg ht
  have hinv_preimage : shift â»Â¹' (g â»Â¹' t) = g â»Â¹' t := by
    ext Ï‰
    simp [Set.mem_preimage, hinv Ï‰]
  exact (mem_shiftInvariantSigma_iff (s:=g â»Â¹' t)).mpr âŸ¨hpreimage, hinv_preimageâŸ©

end Exchangeability.DeFinetti
