import Mathlib.Data.Fin.Tuple.Basic
import Mathlib.Logic.Equiv.Fintype
import Mathlib.MeasureTheory.Constructions.Cylinders
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.MeasureTheory.Measure.Typeclasses.Finite
import Exchangeability.Contractability

/-!
# Exchangeability

This file removes the temporary axioms used earlier in the development by
providing measure-theoretic proofs that are available in `mathlib`.

The key ingredients are:

* π-system uniqueness for finite measures (`Measure.ext_of_generate_finite`),
* the fact that cylinder sets generated by initial segments of coordinates form
  a π-system which generates the product σ-algebra on `ℕ → α`, and
* combinatorial lemmas that extend finite permutations to permutations of `ℕ` in
  order to compare finite and full exchangeability.
-/

noncomputable section

open scoped BigOperators

open Equiv MeasureTheory Set

namespace Exchangeability

variable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]

/-!
## π-system of prefix cylinders

We work with cylinder sets determined by the first `n` coordinates.  They are
convenient for pushing finite-dimensional marginal equalities to the whole path
space, and they generate the product σ-algebra on `ℕ → α`.
-/

/-- Projection to the first `n` coordinates. -/
def prefixProj (α : Type*) [MeasurableSpace α] (n : ℕ) (x : ℕ → α) : Fin n → α :=
  fun i => x i

@[simp]
lemma prefixProj_apply (n : ℕ) (x : ℕ → α) (i : Fin n) :
    prefixProj (α:=α) n x i = x i := rfl

lemma measurable_prefixProj (n : ℕ) :
    Measurable (prefixProj (α:=α) n) := by
  classical
  refine measurable_pi_lambda _ (fun i => ?_)
  simpa using
    (measurable_pi_apply (α:=ℕ → α) i :
      Measurable fun x : ℕ → α => x (i : ℕ))

/-- Cylinder determined by the first `n` coordinates belonging to a measurable set. -/
def prefixCylinder (n : ℕ) (S : Set (Fin n → α)) : Set (ℕ → α) :=
  (prefixProj (α:=α) n) ⁻¹' S

@[simp]
lemma mem_prefixCylinder {n : ℕ} {S : Set (Fin n → α)} {x : ℕ → α} :
    x ∈ prefixCylinder (α:=α) n S ↔ prefixProj (α:=α) n x ∈ S := Iff.rfl

@[simp]
lemma prefixCylinder_univ (n : ℕ) :
    prefixCylinder (α:=α) n (Set.univ : Set (Fin n → α)) = (Set.univ) := by
  ext x; simp [prefixCylinder]

@[simp]
lemma prefixCylinder_empty (n : ℕ) :
    prefixCylinder (α:=α) n (∅ : Set (Fin n → α)) = (∅) := rfl

/--
A π-system consisting of prefix cylinders determined by an initial segment of
coordinates.  Each element is generated by the first `n` entries for some `n`.
-/
def prefixCylinders : Set (Set (ℕ → α)) :=
  {A | ∃ n, ∃ S : Set (Fin n → α), MeasurableSet S ∧ A = prefixCylinder (α:=α) n S}

lemma prefixCylinder_mem_prefixCylinders {n : ℕ} {S : Set (Fin n → α)}
    (hS : MeasurableSet S) :
    prefixCylinder (α:=α) n S ∈ prefixCylinders (α:=α) :=
  ⟨n, S, hS, rfl⟩

lemma measurable_of_mem_prefixCylinders {A : Set (ℕ → α)}
    (hA : A ∈ prefixCylinders (α:=α)) : MeasurableSet A := by
  classical
  rcases hA with ⟨n, S, hS, rfl⟩
  exact (measurable_prefixProj (α:=α) n).measurableSet_preimage hS

section Extend

variable {m n : ℕ}

/-- Restrict a tuple of length `k` to the first `m` coordinates. -/
def takePrefix (hmn : m ≤ n) (x : Fin n → α) : Fin m → α :=
  fun i => x (Fin.castLE hmn i)

@[simp]
lemma takePrefix_apply (hmn : m ≤ n) (x : Fin n → α) (i : Fin m) :
    takePrefix (α:=α) hmn x i = x (Fin.castLE hmn i) := rfl

lemma takePrefix_measurable (hmn : m ≤ n) :
    Measurable (takePrefix (α:=α) hmn) := by
  classical
  refine measurable_pi_lambda _ (fun i => ?_)
  change Measurable fun x : Fin n → α => x (Fin.castLE hmn i)
  exact measurable_pi_apply _

@[simp]
lemma takePrefix_prefixProj (hmn : m ≤ n) (x : ℕ → α) :
    takePrefix (α:=α) hmn (prefixProj (α:=α) n x) = prefixProj (α:=α) m x := by
  ext i; simp [takePrefix]

/-- Extend a measurable set on `Fin m → α` to one on `Fin n → α` by ignoring the
extra coordinates. -/
def extendSet (hmn : m ≤ n) (S : Set (Fin m → α)) : Set (Fin n → α) :=
  {x | takePrefix (α:=α) hmn x ∈ S}

lemma extendSet_measurable {hmn : m ≤ n} {S : Set (Fin m → α)}
    (hS : MeasurableSet S) : MeasurableSet (extendSet (α:=α) hmn S) := by
  classical
  exact (takePrefix_measurable (α:=α) hmn).measurableSet_preimage hS

lemma prefixCylinder_inter {m n : ℕ} {S : Set (Fin m → α)} {T : Set (Fin n → α)} :
    prefixCylinder (α:=α) m S ∩ prefixCylinder (α:=α) n T =
      prefixCylinder (α:=α) (max m n)
        (extendSet (α:=α) (Nat.le_max_left _ _) S ∩
          extendSet (α:=α) (Nat.le_max_right _ _) T) := by
  ext x; constructor <;> intro hx
  · rcases hx with ⟨hxS, hxT⟩
    refine ⟨?_, ?_⟩
    · change takePrefix (α:=α) (Nat.le_max_left m n) (prefixProj (α:=α) (max m n) x) ∈ S
      simpa [takePrefix_prefixProj] using hxS
    · change takePrefix (α:=α) (Nat.le_max_right m n) (prefixProj (α:=α) (max m n) x) ∈ T
      simpa [takePrefix_prefixProj] using hxT
  · rcases hx with ⟨hxS, hxT⟩
    constructor
    · change takePrefix (α:=α) (Nat.le_max_left m n) (prefixProj (α:=α) (max m n) x) ∈ S
      simpa [takePrefix_prefixProj] using hxS
    · change takePrefix (α:=α) (Nat.le_max_right m n) (prefixProj (α:=α) (max m n) x) ∈ T
      simpa [takePrefix_prefixProj] using hxT

end Extend

lemma isPiSystem_prefixCylinders :
    IsPiSystem (prefixCylinders (α:=α)) := by
  classical
  rintro A ⟨m, S, hS, rfl⟩ B ⟨n, T, hT, rfl⟩ hAB
  refine ⟨_, _, _, prefixCylinder_inter (α:=α)⟩
  · exact extendSet_measurable (α:=α) (Nat.le_max_left m n) hS
  · exact extendSet_measurable (α:=α) (Nat.le_max_right m n) hT

/-- Helper: any cylinder determined by a finite set of coordinates belongs to the
σ-algebra generated by prefix cylinders. -/
lemma cylinder_subset_prefixCylinders {s : Finset ℕ} {S : Set (∀ i : s, α)}
    (hS : MeasurableSet S) :
    MeasureTheory.cylinder (α:=fun _ : ℕ => α) s S ∈ prefixCylinders (α:=α) := by
  classical
  -- Choose an initial segment that covers `s`.
  let N := s.sup id + 1
  have h_mem : ∀ i ∈ s, i < N := by
    intro i hi
    have hle : i ≤ s.sup id := Finset.le_sup (by simpa using hi)
    exact Nat.lt_of_le_of_lt hle (Nat.lt_succ_self _)
  -- Transport `S` along the inclusion into the initial segment.
  let ι : s → Fin N := fun x => ⟨x.1, h_mem x.1 x.2⟩
  let pull : (Fin N → α) → (∀ i : s, α) := fun x => fun y => x (ι y)
  have hpull_meas : Measurable pull := by
    refine measurable_pi_lambda _ (fun y => ?_)
    change Measurable fun x : Fin N → α => x (ι y)
    exact measurable_pi_apply _
  have hs_eq :
      MeasureTheory.cylinder (α:=fun _ : ℕ => α) s S =
        prefixCylinder (α:=α) N (pull ⁻¹' S) := by
    ext x
    simp [MeasureTheory.cylinder, pull, prefixCylinder, prefixProj, Finset.restrict,
      Function.comp, h_mem]
  refine hs_eq ▸ prefixCylinder_mem_prefixCylinders (α:=α) ?_
  exact hpull_meas.measurableSet_preimage hS

lemma generateFrom_prefixCylinders :
    MeasurableSpace.generateFrom (prefixCylinders (α:=α)) =
      (inferInstance : MeasurableSpace (ℕ → α)) := by
  classical
  refine le_antisymm ?_ ?_
  · refine generateFrom_le ?_
    rintro A hA
    exact measurable_of_mem_prefixCylinders (α:=α) hA
  · have h_subset :
      MeasurableSpace.generateFrom
          (MeasureTheory.measurableCylinders fun _ : ℕ => α)
        ≤ MeasurableSpace.generateFrom (prefixCylinders (α:=α)) := by
      refine MeasurableSpace.generateFrom_mono ?_
      intro A hA
      obtain ⟨s, S, hS, rfl⟩ :=
        (MeasureTheory.mem_measurableCylinders (α:=fun _ : ℕ => α) A).1 hA
      exact cylinder_subset_prefixCylinders (α:=α) hS
    simpa [MeasureTheory.generateFrom_measurableCylinders
      (α:=fun _ : ℕ => α)] using h_subset

/-- Finite measures with matching finite-dimensional marginals coincide. -/
theorem measure_eq_of_fin_marginals_eq {μ ν : Measure (ℕ → α)}
    [IsFiniteMeasure μ] [IsFiniteMeasure ν]
    (h : ∀ n (S : Set (Fin n → α)) (_hS : MeasurableSet S),
        Measure.map (prefixProj (α:=α) n) μ S =
        Measure.map (prefixProj (α:=α) n) ν S) : μ = ν := by
  classical
  have h_univ : μ Set.univ = ν Set.univ := by
    simpa [Measure.map_apply_of_aemeasurable
      ((measurable_prefixProj (α:=α) 1).aemeasurable)]
      using h 1 Set.univ MeasurableSet.univ
  apply Measure.ext_of_generate_finite (C:=prefixCylinders (α:=α))
  · simpa [generateFrom_prefixCylinders (α:=α)]
  · exact isPiSystem_prefixCylinders (α:=α)
  · intro A hA
    rcases hA with ⟨n, S, hS, rfl⟩
    have hmap := h n S hS
    simpa [prefixCylinder,
      Measure.map_apply_of_aemeasurable
        ((measurable_prefixProj (α:=α) n).aemeasurable)] using hmap
  · simpa using h_univ

/-- Convenience wrapper of `measure_eq_of_fin_marginals_eq` for probability measures. -/
theorem measure_eq_of_fin_marginals_eq_prob {μ ν : Measure (ℕ → α)}
    [IsProbabilityMeasure μ] [IsProbabilityMeasure ν]
    (h : ∀ n (S : Set (Fin n → α)) (_hS : MeasurableSet S),
        Measure.map (prefixProj (α:=α) n) μ S =
        Measure.map (prefixProj (α:=α) n) ν S) : μ = ν := by
  classical
  exact measure_eq_of_fin_marginals_eq (α:=α) (μ:=μ) (ν:=ν) h

/-!
## Exchangeability versus full exchangeability

We leverage the previous uniqueness result to upgrade exchangeability under
finite permutations to invariance under all permutations of `ℕ`.
-/

/-- Reindex paths by a permutation of `ℕ`. -/
def reindex (π : Equiv.Perm ℕ) (x : ℕ → α) : ℕ → α := fun i => x (π i)

@[simp]
lemma reindex_apply (π : Equiv.Perm ℕ) (x : ℕ → α) (i : ℕ) :
    reindex (α:=α) π x i = x (π i) := rfl

lemma measurable_reindex (π : Equiv.Perm ℕ) :
    Measurable (reindex (α:=α) π) := by
  classical
  refine measurable_pi_lambda _ (fun i => ?_)
  change Measurable fun x : ℕ → α => x (π i)
  exact measurable_pi_apply _

attribute [measurability] measurable_prefixProj takePrefix_measurable measurable_reindex

/-- The path law of a stochastic process. -/
def pathLaw (μ : Measure Ω) (X : ℕ → Ω → α) : Measure (ℕ → α) :=
  Measure.map (fun ω => fun i => X i ω) μ

lemma pathLaw_map_prefix (μ : Measure Ω) (X : ℕ → Ω → α)
    (hX : ∀ i, Measurable (X i)) (n : ℕ) :
    Measure.map (prefixProj (α:=α) n) (pathLaw (α:=α) μ X) =
      Measure.map (fun ω => fun i : Fin n => X i ω) μ := by
  classical
  have hmeas : Measurable fun ω => fun i : ℕ => X i ω :=
    measurable_pi_lambda _ (fun i => hX i)
  refine Measure.map_map (μ:=μ)
    (f:=fun ω => fun i : ℕ => X i ω)
    (g:=prefixProj (α:=α) n)
    (measurable_prefixProj (α:=α) n)
    hmeas

lemma pathLaw_map_prefix_perm (μ : Measure Ω) (X : ℕ → Ω → α)
    (hX : ∀ i, Measurable (X i)) (π : Equiv.Perm ℕ) (n : ℕ) :
    Measure.map (prefixProj (α:=α) n)
        (Measure.map (reindex (α:=α) π) (pathLaw (α:=α) μ X)) =
      Measure.map (fun ω => fun i : Fin n => X (π i) ω) μ := by
  classical
  have hreindex :
      Measurable fun x : ℕ → α => reindex (α:=α) π x := measurable_reindex (α:=α) π
  have hmeas : Measurable fun ω => fun i : ℕ => X i ω :=
    measurable_pi_lambda _ (fun i => hX i)
  have hcomp :
      Measure.map (prefixProj (α:=α) n)
          (Measure.map (reindex (α:=α) π) (pathLaw (α:=α) μ X)) =
        Measure.map ((prefixProj (α:=α) n) ∘ reindex (α:=α) π)
          (pathLaw (α:=α) μ X) :=
    (Measure.map_map (μ:=pathLaw (α:=α) μ X)
      (g:=reindex (α:=α) π)
      (f:=prefixProj (α:=α) n)
      (measurable_prefixProj (α:=α) n) hreindex).symm
  have hcomp' :
      Measure.map ((prefixProj (α:=α) n) ∘ reindex (α:=α) π) (pathLaw (α:=α) μ X) =
        Measure.map (fun ω => fun i : Fin n => X (π i) ω) μ := by
    have hgoal := Measure.map_map (μ:=μ)
      (f:=reindex (α:=α) π ∘ fun ω => fun i => X i ω)
      (g:=prefixProj (α:=α) n)
      (measurable_prefixProj (α:=α) n)
      ((measurable_reindex (α:=α) π).comp hmeas)
    simpa [pathLaw, Function.comp, reindex_apply, prefixProj_apply] using hgoal
  simpa [hcomp] using hcomp'

/-- Full exchangeability is equivalent to invariance of the path law under reindexing. -/
lemma fullyExchangeable_iff_pathLaw_invariant {μ : Measure Ω}
    [IsProbabilityMeasure μ] {X : ℕ → Ω → α}
    (hX : ∀ i, Measurable (X i)) :
    FullyExchangeable μ X ↔
      ∀ π, Measure.map (reindex (α:=α) π) (pathLaw (α:=α) μ X)
        = pathLaw (α:=α) μ X := by
  classical
  constructor
  · intro hFull π
    have hmap :
        Measure.map (reindex (α:=α) π) (pathLaw (α:=α) μ X)
          = Measure.map (fun ω => fun i : ℕ => X (π i) ω) μ := by
      have := Measure.map_map (μ:=μ)
        (f:=fun ω => fun i : ℕ => X i ω)
        (g:=reindex (α:=α) π)
        (measurable_reindex (α:=α) π)
        (measurable_pi_lambda _ (fun i => hX i))
      simpa [pathLaw, Function.comp, reindex_apply] using this
    have hpath : pathLaw (α:=α) μ X =
        Measure.map (fun ω => fun i : ℕ => X i ω) μ := by
      simp [pathLaw]
    have := hFull π
    simpa [hmap, hpath] using this
  · intro hPath π
    have hmap :
        Measure.map (reindex (α:=α) π) (pathLaw (α:=α) μ X)
          = Measure.map (fun ω => fun i : ℕ => X (π i) ω) μ := by
      have := Measure.map_map (μ:=μ)
        (f:=fun ω => fun i : ℕ => X i ω)
        (g:=reindex (α:=α) π)
        (measurable_reindex (α:=α) π)
        (measurable_pi_lambda _ (fun i => hX i))
      simpa [pathLaw, Function.comp, reindex_apply] using this
    have hpath : pathLaw (α:=α) μ X =
        Measure.map (fun ω => fun i : ℕ => X i ω) μ := by
      simp [pathLaw]
    have := hPath π
    simpa [hmap, hpath] using this

/-!
### Auxiliary combinatorics on finite prefixes
-/

section Approximation

variable (π : Equiv.Perm ℕ) (n : ℕ)

/-- A bound containing both the first `n` indices and their `π`-images. -/
def permBound : ℕ :=
  max n ((Finset.range n).sup fun i : ℕ => π i + 1)

lemma le_permBound : n ≤ permBound π n := le_max_left _ _

lemma lt_permBound_of_lt {i : ℕ} (hi : i < n) :
    π i < permBound π n := by
  classical
  have hsup : π i + 1 ≤ (Finset.range n).sup fun j => π j + 1 :=
    Finset.le_sup ⟨i, by simpa using hi, rfl⟩
  have : π i < (Finset.range n).sup fun j => π j + 1 :=
    lt_of_lt_of_le (Nat.lt_succ_self _) hsup
  exact lt_of_lt_of_le this (Nat.le_max_right _ _)

lemma lt_permBound_fin (i : Fin n) :
    π i < permBound π n := lt_permBound_of_lt (π:=π) (n:=n) i.isLt

def approxEquiv :
    {x : Fin (permBound π n) // (x : ℕ) < n} ≃
      {x : Fin (permBound π n) // ∃ j : Fin n, (x : ℕ) = π j} :=
  by
    classical
    refine
      { toFun := ?_, invFun := ?_, left_inv := ?_, right_inv := ?_ }
    · intro x
      have hx := x.property
      let i : Fin n := ⟨x.1, hx⟩
      have hi : (π i : ℕ) < permBound π n := lt_permBound_fin (π:=π) (n:=n) i
      refine ⟨⟨π i, hi⟩, ?_⟩
      exact ⟨i, rfl⟩
    · intro y
      obtain ⟨j, hj⟩ := y.property
      have hj_lt : (j : ℕ) < n := j.isLt
      have hj_eq : π.symm y.1 = j := by
        apply π.symm_apply_eq.2
        simpa [hj]
      have hjm : (π.symm y.1 : ℕ) < permBound π n :=
        lt_of_lt_of_le (by simpa [hj_eq] using hj_lt)
          (le_permBound (π:=π) (n:=n))
      refine ⟨⟨π.symm y.1, hjm⟩, ?_⟩
      simpa [hj_eq]
    · intro x
      ext
      simp
    · intro y
      rcases y with ⟨y, hy⟩
      rcases hy with ⟨j, hj⟩
      ext
      simp [hj]

def approxPerm : Equiv.Perm (Fin (permBound π n)) :=
  (approxEquiv (π:=π) (n:=n)).extendSubtype

lemma approxPerm_apply_cast (i : Fin n) :
    approxPerm (π:=π) (n:=n)
        (Fin.castLE (le_permBound (π:=π) (n:=n)) i)
      = ⟨π i, lt_permBound_fin (π:=π) (n:=n) i⟩ := by
  classical
  have hmem : ((Fin.castLE (le_permBound (π:=π) (n:=n)) i) : ℕ) < n := by
    simpa using i.isLt
  have := Equiv.extendSubtype_apply_of_mem
      (e:=approxEquiv (π:=π) (n:=n))
      (x:=Fin.castLE (le_permBound (π:=π) (n:=n)) i)
      hmem
  simpa using this

end Approximation

-/-- Finite-dimensional marginals of `X` are invariant under arbitrary permutations. -/
lemma marginals_perm_eq {μ : Measure Ω} (X : ℕ → Ω → α)
    (hX : ∀ i, Measurable (X i)) (hμ : Exchangeable μ X)
    (π : Equiv.Perm ℕ) (n : ℕ) :
    Measure.map (fun ω => fun i : Fin n => X (π i) ω) μ =
      Measure.map (fun ω => fun i : Fin n => X i ω) μ := by
  classical
  by_cases hn : n = 0
  · subst hn; simp
  set m := permBound (π:=π) n with hm_def
  have hm : n ≤ m := le_permBound (π:=π) (n:=n)
  set σ := approxPerm (π:=π) (n:=n) with hσ_def
  have hσ := hμ m σ
  have hX₁ : Measurable fun ω => fun i : Fin m => X i ω :=
    measurable_pi_lambda _ (fun i => hX i)
  have hX₂ : Measurable fun ω => fun i : Fin m => X (σ i) ω :=
    measurable_pi_lambda _ (fun i => hX _)
  have hproj : Measurable (takePrefix (α:=α) hm) := takePrefix_measurable (α:=α) hm
  have hmap₁ :=
    Measure.map_map (μ:=μ)
      (f:=fun ω => fun i : Fin m => X (σ i) ω)
      (g:=takePrefix (α:=α) hm) hproj hX₂
  have hmap₂ :=
    Measure.map_map (μ:=μ)
      (f:=fun ω => fun i : Fin m => X i ω)
      (g:=takePrefix (α:=α) hm) hproj hX₁
  have hσ' := congrArg (fun ν => Measure.map (takePrefix (α:=α) hm) ν) hσ
  have hgoal := by simpa [hmap₁, hmap₂] using hσ'
  have hcomp₁ :
      (takePrefix (α:=α) hm) ∘ fun ω => fun i : Fin m => X (σ i) ω
        = fun ω => fun i : Fin n => X (π i) ω := by
    funext ω i
    simp [Function.comp, takePrefix,
      approxPerm_apply_cast (π:=π) (n:=n) i]
  have hcomp₂ :
      (takePrefix (α:=α) hm) ∘ fun ω => fun i : Fin m => X i ω
        = fun ω => fun i : Fin n => X i ω := by
    funext ω i; simp [Function.comp, takePrefix]
  simpa [hcomp₁, hcomp₂] using hgoal

/-- Exchangeability and full exchangeability coincide for probability measures. -/
theorem exchangeable_iff_fullyExchangeable {μ : Measure Ω}
    [IsProbabilityMeasure μ] {X : ℕ → Ω → α}
    (hX : ∀ i, Measurable (X i)) :
    Exchangeable μ X ↔ FullyExchangeable μ X := by
  classical
  constructor
  · intro hEx π
    let μX := pathLaw (α:=α) μ X
    have hμ_univ : μ Set.univ = (1 : ℝ≥0∞) := by simpa using measure_univ (μ:=μ)
    have hμX_univ : μX Set.univ = (1 : ℝ≥0∞) := by
      simp [μX, pathLaw, Measure.map_apply_of_aemeasurable,
        (measurable_pi_lambda _ (fun i => hX i)).aemeasurable, hμ_univ]
    haveI : IsProbabilityMeasure μX := ⟨by simpa using hμX_univ⟩
    have hμXπ_univ :
        Measure.map (reindex (α:=α) π) μX Set.univ = (1 : ℝ≥0∞) := by
      simp [Measure.map_apply_of_aemeasurable,
        (measurable_reindex (α:=α) π).aemeasurable, hμX_univ]
    haveI : IsProbabilityMeasure (Measure.map (reindex (α:=α) π) μX) :=
      ⟨by simpa using hμXπ_univ⟩
    have hMarg : ∀ n (S : Set (Fin n → α)) (hS : MeasurableSet S),
        Measure.map (prefixProj (α:=α) n) μX S =
          Measure.map (prefixProj (α:=α) n)
            (Measure.map (reindex (α:=α) π) μX) S := by
      intro n S hS
      have h1 := pathLaw_map_prefix (α:=α) μ X hX n
      have h2 := pathLaw_map_prefix_perm (α:=α) μ X hX π n
      have hperm := marginals_perm_eq (μ:=μ) (X:=X) hX hEx π n
      have hlhs :
          Measure.map (prefixProj (α:=α) n) μX =
            Measure.map (fun ω => fun i : Fin n => X i ω) μ := h1
      have hrhs :
          Measure.map (prefixProj (α:=α) n)
              (Measure.map (reindex (α:=α) π) μX) =
            Measure.map (fun ω => fun i : Fin n => X (π i) ω) μ := h2
      simpa [hlhs, hrhs] using congrArg (fun ν => ν S) hperm
    have hEq :=
      measure_eq_of_fin_marginals_eq_prob (α:=α)
        (μ:=μX) (ν:=Measure.map (reindex (α:=α) π) μX) hMarg
    have hmap₁ :
        Measure.map (fun ω => fun i : ℕ => X (π i) ω) μ =
          Measure.map (reindex (α:=α) π) μX := by
      simp [μX, pathLaw, Measure.map_map,
        (measurable_reindex (α:=α) π),
        (measurable_pi_lambda _ (fun i => hX i))]
    have hmap₂ : Measure.map (fun ω => fun i : ℕ => X i ω) μ = μX := by
      simp [μX, pathLaw]
    simpa [hmap₁, hmap₂] using hEq.symm
  · intro hFull
    exact FullyExchangeable.exchangeable (μ:=μ) (X:=X) hX hFull

end Exchangeability
