/-
Copyright (c) 2025 The Exchangeability Contributors.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Claude Code
-/

import Mathlib.MeasureTheory.MeasurableSpace.Basic
import Mathlib.MeasureTheory.Measure.MeasureSpace

/-!
# Tail σ-algebras on path space and for general processes

This file provides two canonical viewpoints on tail σ-algebras with explicit bridge lemmas
connecting them.

## Main definitions

* `tailFamily X n`: The n-th reverse (future) σ-algebra generated by the tails of X
* `tailProcess X`: Tail σ-algebra of a process X : ℕ → Ω → α
* `tailShift α`: Tail σ-algebra on path space (ℕ → α) defined via one-sided shifts

## Main results

* `tailProcess_coords_eq_tailShift`: The critical bridge between path-space and process formulations
* `tailProcess_eq_comap_path`: Pullback formulation (most convenient in practice)
* `tailProcess_eq_iInf_revFiltration`: Connection to reverse filtration formulation

## Implementation notes

This file is designed to be mathlib-ready:
- Only imports mathlib (no project dependencies)
- Comprehensive docstrings
- Conservative use of attributes (@[simp] only on definitional aliases)

-/

namespace Exchangeability.Tail

open MeasureTheory

section Tail

variable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]

/-! ### Index Arithmetic (isolate Nat arithmetic once) -/

section NatIndexArithmetic

@[simp] lemma nat_add_assoc (n m k : ℕ) : n + (m + k) = (n + m) + k := (add_assoc n m k).symm

end NatIndexArithmetic

/-! ### Process-Relative Tail -/

/-- The `n`-th reverse (future) σ-algebra generated by the tails of `X`. -/
def tailFamily (X : ℕ → Ω → α) (n : ℕ) : MeasurableSpace Ω :=
  iSup (fun k : ℕ => MeasurableSpace.comap (fun ω => X (n + k) ω) inferInstance)

/-- Tail σ-algebra of a process `X : ℕ → Ω → α`. -/
def tailProcess (X : ℕ → Ω → α) : MeasurableSpace Ω :=
  iInf (tailFamily X)

@[simp] lemma tailProcess_def (X : ℕ → Ω → α) :
    tailProcess X = iInf (tailFamily X) := rfl

lemma tailFamily_antitone (X : ℕ → Ω → α) :
    Antitone (tailFamily X) := by
  intro n m hnm
  simp only [tailFamily]
  apply iSup_le
  intro k
  have : n + (k + (m - n)) = m + k := by omega
  calc MeasurableSpace.comap (fun ω => X (m + k) ω) inferInstance
      = MeasurableSpace.comap (fun ω => X (n + (k + (m - n))) ω) inferInstance := by rw [← this]
    _ ≤ _ := le_iSup (fun j => MeasurableSpace.comap (fun ω => X (n + j) ω) inferInstance) (k + (m - n))

lemma tailProcess_le_tailFamily (X : ℕ → Ω → α) (n : ℕ) :
    tailProcess X ≤ tailFamily X n := by
  exact iInf_le (tailFamily X) n

/-! ### Path-Space Tail -/

/-- Tail σ-algebra on path space `(ℕ → α)` defined via one-sided shifts. -/
def tailShift (α : Type*) [MeasurableSpace α] : MeasurableSpace (ℕ → α) :=
  iInf (fun n : ℕ =>
    MeasurableSpace.comap
      (fun (ω : ℕ → α) => fun k => ω (n + k))
      (inferInstance : MeasurableSpace (ℕ → α)))

/-! ### Bridge Lemmas (LOAD-BEARING - Phase 1a) -/

/-- On path space: the pullback of the product σ-algebra by the `n`-fold shift equals
    the join of the coordinate pullbacks at indices `n+k`.

    **Proof strategy:** Use that the product σ-algebra on (ℕ → α) is generated by
    coordinate maps ω ↦ ω k. Apply comap_comp with eval (n+k) = (eval k) ∘ (shift^[n]),
    then bundle via iSup_congr. -/
lemma comap_shift_eq_iSup_comap_coords (n : ℕ) :
    MeasurableSpace.comap (fun (ω : ℕ → α) => fun k => ω (n + k))
        (inferInstance : MeasurableSpace (ℕ → α))
      =
    iSup (fun k : ℕ =>
      MeasurableSpace.comap (fun (ω : ℕ → α) => ω (n + k))
        (inferInstance : MeasurableSpace α)) := by
  -- TODO: Prove using product σ-algebra characterization
  -- Key: product σ-algebra = ⨆ k, comap (eval k)
  -- Then: comap shift (⨆ k, comap eval_k) = ⨆ k, comap (eval_k ∘ shift) = ⨆ k, comap eval_(n+k)
  sorry

/-- **Bridge 1 (path ↔ process).**
    For the coordinate process on path space, `tailProcess` equals `tailShift`.

    **Proof strategy:** Apply iInf_congr using comap_shift_eq_iSup_comap_coords. -/
lemma tailProcess_coords_eq_tailShift :
    tailProcess (fun k (ω : ℕ → α) => ω k) = tailShift α := by
  -- TODO: Complete proof once comap_shift_eq_iSup_comap_coords is proven
  sorry

/-- **Bridge 2 (pullback along sample-path map).**
    Let `Φ : Ω → (ℕ → α)` be `Φ ω k := X k ω`. Then the process tail is the
    pullback of the path tail along `Φ`.

    **Proof strategy:** Use antisymmetry and universal properties of inf/sup. -/
lemma tailProcess_eq_comap_path (X : ℕ → Ω → α) :
    tailProcess X
      =
    MeasurableSpace.comap (fun ω : Ω => fun k => X k ω) (tailShift α) := by
  -- TODO: Prove that comap commutes with iInf in this special case
  -- or use a different characterization
  sorry

/-- **Bridge 3 (to ViaMartingale's revFiltration).**
    If `revFiltration X m` is defined as the σ-algebra generated by all `X (m+k)`,
    then the tail equals `⨅ m, revFiltration X m`.

    **Proof strategy:** Rewrite each slice using hrev, then unfold tailProcess. -/
lemma tailProcess_eq_iInf_revFiltration
    (X : ℕ → Ω → α)
    (revFiltration : (ℕ → Ω → α) → ℕ → MeasurableSpace Ω)
    (hrev :
      ∀ m, revFiltration X m
            =
          iSup (fun k : ℕ =>
            MeasurableSpace.comap (fun ω => X (m + k) ω) inferInstance)) :
    tailProcess X = iInf (fun m => revFiltration X m) := by
  simp only [tailProcess]
  congr 1
  funext m
  simp only [tailFamily]
  rw [hrev m]

/-! ### General Properties -/

/-- Tail σ-algebra is sub-σ-algebra of ambient space. -/
lemma tailProcess_le_ambient (X : ℕ → Ω → α) :
    tailProcess X ≤ (inferInstance : MeasurableSpace Ω) := by
  apply iInf_le_of_le 0
  apply iSup_le
  intro k
  -- Each comap is ≤ the ambient measurable space
  sorry

/-! NOTE: For probability/finite measures, trimming to the tail σ-algebra preserves
    sigma-finiteness. This is automatic via type class inference in mathlib. -/

end Tail

end Exchangeability.Tail
