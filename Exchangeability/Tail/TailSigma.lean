/-
Copyright (c) 2025 Cameron Freer.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/

import Mathlib.MeasureTheory.MeasurableSpace.Pi
import Mathlib.MeasureTheory.Measure.MeasureSpace

/-!
# Tail σ-algebras on path space and for general processes

This file provides two canonical viewpoints on tail σ-algebras with explicit bridge lemmas
connecting them.

## Main definitions

* `tailFamily X n`: The n-th reverse (future) σ-algebra generated by the tails of X
* `tailProcess X`: Tail σ-algebra of a process X : ℕ → Ω → α
* `tailShift α`: Tail σ-algebra on path space (ℕ → α) defined via one-sided shifts

## Main results

* `tailProcess_coords_eq_tailShift`: The critical bridge between path-space and process formulations
* `tailProcess_eq_comap_path`: Pullback formulation (most convenient in practice)
* `tailProcess_eq_iInf_revFiltration`: Connection to reverse filtration formulation

## Implementation notes

This file is designed to be mathlib-ready:
- Only imports mathlib (no project dependencies)
- Comprehensive docstrings
- Conservative use of attributes (@[simp] only on definitional aliases)

-/

namespace Exchangeability.Tail

open MeasureTheory

section Tail

variable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]

/-! ### Index Arithmetic (isolate Nat arithmetic once) -/

section NatIndexArithmetic

@[simp] lemma nat_add_assoc (n m k : ℕ) : n + (m + k) = (n + m) + k := (add_assoc n m k).symm

end NatIndexArithmetic

/-! ### Process-Relative Tail -/

/-- The `n`-th reverse (future) σ-algebra generated by the tails of `X`. -/
def tailFamily (X : ℕ → Ω → α) (n : ℕ) : MeasurableSpace Ω :=
  iSup (fun k : ℕ => MeasurableSpace.comap (fun ω => X (n + k) ω) inferInstance)

/-- Tail σ-algebra of a process `X : ℕ → Ω → α`. -/
def tailProcess (X : ℕ → Ω → α) : MeasurableSpace Ω :=
  iInf (tailFamily X)

omit [MeasurableSpace Ω] in
@[simp]
lemma tailProcess_def (X : ℕ → Ω → α) :
    tailProcess X = iInf (tailFamily X) := rfl

omit [MeasurableSpace Ω] in
lemma tailFamily_antitone (X : ℕ → Ω → α) :
    Antitone (tailFamily X) := by
  intro n m hnm
  simp only [tailFamily]
  apply iSup_le
  intro k
  have : n + (k + (m - n)) = m + k := by omega
  calc MeasurableSpace.comap (fun ω => X (m + k) ω) inferInstance
      = MeasurableSpace.comap (fun ω => X (n + (k + (m - n))) ω) inferInstance := by rw [← this]
    _ ≤ _ := le_iSup (fun j => MeasurableSpace.comap (fun ω => X (n + j) ω) inferInstance) (k + (m - n))

omit [MeasurableSpace Ω] in
lemma tailProcess_le_tailFamily (X : ℕ → Ω → α) (n : ℕ) :
    tailProcess X ≤ tailFamily X n := by
  exact iInf_le (tailFamily X) n

/-! ### Path-Space Tail -/

/-- Tail σ-algebra on path space `(ℕ → α)` defined via one-sided shifts. -/
def tailShift (α : Type*) [MeasurableSpace α] : MeasurableSpace (ℕ → α) :=
  iInf (fun n : ℕ =>
    MeasurableSpace.comap
      (fun (ω : ℕ → α) => fun k => ω (n + k))
      (inferInstance : MeasurableSpace (ℕ → α)))

/-! ### Helper Lemmas for comap and Infima -/

omit [MeasurableSpace Ω] [MeasurableSpace α] in
/-- `comap` preserves arbitrary infima (right adjoint property).

    Key insight: In the Galois connection `map f ⊣ comap f`, the RIGHT adjoint `comap`
    preserves all infima, while the LEFT adjoint `map` preserves all suprema.
    This is why `comap_iInf` holds unconditionally (no surjectivity needed). -/
lemma comap_iInf {ι : Sort*} (f : α → β) (m : ι → MeasurableSpace β) :
    MeasurableSpace.comap f (iInf m) = iInf (fun i => MeasurableSpace.comap f (m i)) := by
  refine le_antisymm ?_ ?_
  · -- ≤ direction by monotonicity of comap
    refine le_iInf (fun i => ?_)
    exact MeasurableSpace.comap_mono (iInf_le m i)
  · -- ≥ direction via GC
    sorry -- TODO: Need to show map f (⨅ i, comap f (m i)) ≤ ⨅ i, m i
          -- This uses the counit of the Galois connection map f ⊣ comap f
          -- The user's code uses map_comap_le which may not exist in this mathlib version

/-! ### Bridge Lemmas (LOAD-BEARING - Phase 1a) -/

/-- On path space: the pullback of the product σ-algebra by the `n`-fold shift equals
    the join of the coordinate pullbacks at indices `n+k`.

    **Proof strategy:** Use that the product σ-algebra on (ℕ → α) is generated by
    coordinate maps ω ↦ ω k. Apply comap_comp with eval (n+k) = (eval k) ∘ (shift^[n]),
    then bundle via iSup_congr. -/
lemma comap_shift_eq_iSup_comap_coords (n : ℕ) :
    MeasurableSpace.comap (fun (ω : ℕ → α) => fun k => ω (n + k))
        (inferInstance : MeasurableSpace (ℕ → α))
      =
    iSup (fun k : ℕ =>
      MeasurableSpace.comap (fun (ω : ℕ → α) => ω (n + k))
        (inferInstance : MeasurableSpace α)) := by
  -- Product σ-algebra is the supremum of coordinate pullbacks
  conv_lhs => rw [show (inferInstance : MeasurableSpace (ℕ → α)) = MeasurableSpace.pi from rfl]
  -- Expand pi as supremum of coordinate comaps
  rw [show MeasurableSpace.pi = iSup (fun k : ℕ => MeasurableSpace.comap (fun ω => ω k) inferInstance) from rfl]
  -- Distribute comap over supremum
  rw [MeasurableSpace.comap_iSup]
  -- Compose: (eval k) ∘ (shift n) = eval (n+k)
  congr 1
  ext k
  rw [MeasurableSpace.comap_comp]

omit [MeasurableSpace Ω] in
/-- Helper: Each `tailFamily X n` equals the pullback along the sample-path map of the
    n-shifted path-space σ-algebra. This is the key to connecting the two formulations. -/
lemma tailFamily_eq_comap_sample_path_shift (X : ℕ → Ω → α) (n : ℕ) :
    tailFamily X n =
    MeasurableSpace.comap (fun ω : Ω => fun k => X k ω)
      (MeasurableSpace.comap (fun (ω : ℕ → α) => fun k => ω (n + k)) inferInstance) := by
  simp only [tailFamily]
  -- LHS: ⨆ k, comap (X (n+k))
  -- RHS: comap Φ (comap shift_n) = comap Φ (⨆ k, comap (eval (n+k)))
  calc ⨆ k, MeasurableSpace.comap (fun ω => X (n + k) ω) inferInstance
      = ⨆ k, MeasurableSpace.comap ((fun ω => ω (n + k)) ∘ (fun ω k => X k ω)) inferInstance := by
        rfl
    _ = ⨆ k, MeasurableSpace.comap (fun ω k => X k ω) (MeasurableSpace.comap (fun ω => ω (n + k)) inferInstance) := by
        congr 1; funext k; rw [MeasurableSpace.comap_comp]
    _ = MeasurableSpace.comap (fun ω k => X k ω) (⨆ k, MeasurableSpace.comap (fun ω => ω (n + k)) inferInstance) := by
        rw [← MeasurableSpace.comap_iSup]
    _ = MeasurableSpace.comap (fun ω k => X k ω) (MeasurableSpace.comap (fun ω k => ω (n + k)) inferInstance) := by
        rw [← comap_shift_eq_iSup_comap_coords n]

/-- **Bridge 1 (path ↔ process).**
    For the coordinate process on path space, `tailProcess` equals `tailShift`.

    **Proof strategy:** Apply iInf_congr using comap_shift_eq_iSup_comap_coords. -/
lemma tailProcess_coords_eq_tailShift :
    tailProcess (fun k (ω : ℕ → α) => ω k) = tailShift α := by
  -- The key observation: for X = (fun k ω => ω k), we have X (n+k) ω = ω (n+k)
  simp only [tailProcess, tailShift]
  -- Both sides are iInf over n of the same expression (by comap_shift_eq_iSup_comap_coords)
  congr 1
  funext n
  -- Goal: ⨆ k, comap (fun ω => ω (n+k)) = comap (shift n) pi
  exact (comap_shift_eq_iSup_comap_coords n).symm

/-- **Bridge 2 (pullback along sample-path map).**
    Let `Φ : Ω → (ℕ → α)` be `Φ ω k := X k ω`. Then the process tail equals the
    pullback of the path tail along `Φ`.

    **Proof strategy:** Use that `comap` preserves `iInf` (right adjoint property). -/
lemma tailProcess_eq_comap_path (X : ℕ → Ω → α) :
    tailProcess X
      =
    MeasurableSpace.comap (fun ω : Ω => fun k => X k ω) (tailShift α) := by
  -- TODO: Requires completing comap_iInf proof (right adjoint property)
  -- Once that's done, this should be a one-liner:
  -- simp only [tailProcess, tailShift, tailFamily_eq_comap_sample_path_shift, comap_iInf]
  sorry

omit [MeasurableSpace Ω] in
/-- **Bridge 3 (to ViaMartingale's revFiltration).**
    If `revFiltration X m` is defined as the σ-algebra generated by all `X (m+k)`,
    then the tail equals `⨅ m, revFiltration X m`.

    **Proof strategy:** Rewrite each slice using hrev, then unfold tailProcess. -/
lemma tailProcess_eq_iInf_revFiltration
    (X : ℕ → Ω → α)
    (revFiltration : (ℕ → Ω → α) → ℕ → MeasurableSpace Ω)
    (hrev :
      ∀ m, revFiltration X m
            =
          iSup (fun k : ℕ =>
            MeasurableSpace.comap (fun ω => X (m + k) ω) inferInstance)) :
    tailProcess X = iInf (fun m => revFiltration X m) := by
  simp only [tailProcess]
  congr 1
  funext m
  simp only [tailFamily]
  rw [hrev m]

/-! ### General Properties -/

/-- Tail σ-algebra is sub-σ-algebra of ambient space when all X_k are measurable. -/
lemma tailProcess_le_ambient (X : ℕ → Ω → α) (hX : ∀ k, Measurable (X k)) :
    tailProcess X ≤ (inferInstance : MeasurableSpace Ω) := by
  apply iInf_le_of_le 0
  apply iSup_le
  intro k
  -- comap (X (0+k)) ≤ ambient iff ambient ≤ map (X (0+k)) ambient
  -- which holds because X (0+k) is measurable
  rw [MeasurableSpace.comap_le_iff_le_map]
  exact (hX (0 + k)).le_map

/-! NOTE: For probability/finite measures, trimming to the tail σ-algebra preserves
    sigma-finiteness. This is automatic via type class inference in mathlib. -/

end Tail

end Exchangeability.Tail
