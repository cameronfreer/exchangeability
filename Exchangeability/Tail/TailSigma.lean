/-
Copyright (c) 2025 Cameron Freer.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/

import Mathlib.MeasureTheory.MeasurableSpace.Pi
import Mathlib.MeasureTheory.Measure.MeasureSpace

/-!
# Tail σ-algebras on path space and for general processes

This file provides two canonical viewpoints on tail σ-algebras with explicit bridge lemmas
connecting them.

## Main definitions

* `tailFamily X n`: The n-th reverse (future) σ-algebra generated by the tails of X
* `tailProcess X`: Tail σ-algebra of a process X : ℕ → Ω → α
* `tailShift α`: Tail σ-algebra on path space (ℕ → α) defined via one-sided shifts

## Main results

* `tailProcess_coords_eq_tailShift`: The critical bridge between path-space and process formulations
* `tailProcess_eq_comap_path`: Pullback formulation (most convenient in practice)
* `tailProcess_eq_iInf_revFiltration`: Connection to reverse filtration formulation

## Implementation notes

This file is designed to be mathlib-ready:
- Only imports mathlib (no project dependencies)
- Comprehensive docstrings
- Conservative use of attributes (@[simp] only on definitional aliases)

-/

namespace Exchangeability.Tail

open MeasureTheory

section Tail

variable {Ω α : Type*} [MeasurableSpace Ω] [MeasurableSpace α]

/-! ### Index Arithmetic (isolate Nat arithmetic once) -/

section NatIndexArithmetic

@[simp] lemma nat_add_assoc (n m k : ℕ) : n + (m + k) = (n + m) + k := (add_assoc n m k).symm

end NatIndexArithmetic

/-! ### Process-Relative Tail -/

/-- The `n`-th reverse (future) σ-algebra generated by the tails of `X`. -/
def tailFamily (X : ℕ → Ω → α) (n : ℕ) : MeasurableSpace Ω :=
  iSup (fun k : ℕ => MeasurableSpace.comap (fun ω => X (n + k) ω) inferInstance)

/-- Tail σ-algebra of a process `X : ℕ → Ω → α`. -/
def tailProcess (X : ℕ → Ω → α) : MeasurableSpace Ω :=
  iInf (tailFamily X)

omit [MeasurableSpace Ω] in
@[simp]
lemma tailProcess_def (X : ℕ → Ω → α) :
    tailProcess X = iInf (tailFamily X) := rfl

omit [MeasurableSpace Ω] in
lemma tailFamily_antitone (X : ℕ → Ω → α) :
    Antitone (tailFamily X) := by
  intro n m hnm
  simp only [tailFamily]
  apply iSup_le
  intro k
  have : n + (k + (m - n)) = m + k := by omega
  calc MeasurableSpace.comap (fun ω => X (m + k) ω) inferInstance
      = MeasurableSpace.comap (fun ω => X (n + (k + (m - n))) ω) inferInstance := by rw [← this]
    _ ≤ _ := le_iSup (fun j => MeasurableSpace.comap (fun ω => X (n + j) ω) inferInstance) (k + (m - n))

omit [MeasurableSpace Ω] in
lemma tailProcess_le_tailFamily (X : ℕ → Ω → α) (n : ℕ) :
    tailProcess X ≤ tailFamily X n := by
  exact iInf_le (tailFamily X) n

/-! ### Path-Space Tail -/

/-- Tail σ-algebra on path space `(ℕ → α)` defined via one-sided shifts. -/
def tailShift (α : Type*) [MeasurableSpace α] : MeasurableSpace (ℕ → α) :=
  iInf (fun n : ℕ =>
    MeasurableSpace.comap
      (fun (ω : ℕ → α) => fun k => ω (n + k))
      (inferInstance : MeasurableSpace (ℕ → α)))

/-! ### Helper Lemmas for comap and Infima -/

namespace MeasurableSpace

/-- Preimage is injective on sets when `f` is surjective. -/
lemma preimage_injective_of_surjective {α β} {f : α → β}
    (hf : Function.Surjective f) :
  Function.Injective (fun (s : Set β) => f ⁻¹' s) := by
  intro s t hpre
  have : f ⁻¹' s = f ⁻¹' t := hpre
  ext y
  rcases hf y with ⟨x, rfl⟩
  -- compare membership in equal preimages
  have := congrArg (fun A => x ∈ A) this
  simpa using this

/-- If `f` is surjective, then `map f (comap f m) = m`. -/
lemma map_comap_eq_of_surjective {α β} {f : α → β}
    (hf : Function.Surjective f) (m : MeasurableSpace β) :
  MeasurableSpace.map f (MeasurableSpace.comap f m) = m := by
  classical
  -- Prove by extensionality on measurable sets.
  ext S; constructor
  · -- `S ∈ map f (comap f m)` iff `f ⁻¹' S ∈ comap f m`
    intro hS
    change MeasurableSet[MeasurableSpace.comap f m] (f ⁻¹' S) at hS
    rcases hS with ⟨T, hT, hpre⟩
    -- injectivity of preimage under surjectivity identifies `S = T`
    have hinj := preimage_injective_of_surjective (α := α) (β := β) hf
    have : S = T := by
      apply hinj
      exact hpre.symm
    simpa [this]
  · -- unit inequality `m ≤ map f (comap f m)`
    intro hS
    change MeasurableSet[MeasurableSpace.comap f m] (f ⁻¹' S)
    exact ⟨S, hS, rfl⟩

end MeasurableSpace

omit [MeasurableSpace Ω] [MeasurableSpace α] in
/-- `comap` distributes over `iInf` unconditionally (≤ direction only).

    The inequality `comap f (⨅ i, m i) ≤ ⨅ i, comap f (m i)` holds by monotonicity.
    The reverse inequality (and hence equality) requires `f` to be surjective.
    See `iInf_comap_eq_comap_iInf_of_surjective` for the surjective case. -/
lemma comap_iInf_le {ι : Sort*} (f : α → β) (m : ι → MeasurableSpace β) :
    MeasurableSpace.comap f (iInf m) ≤ iInf (fun i => MeasurableSpace.comap f (m i)) := by
  refine le_iInf (fun i => ?_)
  exact MeasurableSpace.comap_mono (iInf_le m i)

omit [MeasurableSpace Ω] [MeasurableSpace α] in
/-- With `f` surjective and a nonempty index type, `comap` commutes with `⨅`. -/
lemma iInf_comap_eq_comap_iInf_of_surjective
    {ι : Type*} [Nonempty ι] {α β : Type*} {f : α → β}
    (hf : Function.Surjective f)
    (m : ι → MeasurableSpace β) :
  iInf (fun i => MeasurableSpace.comap f (m i))
    = MeasurableSpace.comap f (iInf m) := by
  classical
  -- We'll prove both inequalities by elementwise (membership) arguments.

  -- (≥) direction holds unconditionally (monotonicity).
  have hge :
      MeasurableSpace.comap f (iInf m)
        ≤ iInf (fun i => MeasurableSpace.comap f (m i)) := by
    refine le_iInf (fun i => ?_)
    exact MeasurableSpace.comap_mono (iInf_le _ i)

  -- (≤) direction uses surjectivity to unify the witnesses.
  have hle :
      iInf (fun i => MeasurableSpace.comap f (m i))
        ≤ MeasurableSpace.comap f (iInf m) := by
    -- Unfold the `≤` relation for measurable spaces: elementwise on measurable sets.
    intro s hs
    -- In `⨅ i, comap f (m i)`, measurability is "for all i, there exists Tᵢ with s = f ⁻¹' Tᵢ".
    -- For each i, hs gives us that s is measurable in each comap.
    have hs_all : ∀ i, MeasurableSet[MeasurableSpace.comap f (m i)] s := by
      rw [MeasurableSpace.measurableSet_iInf] at hs
      exact hs
    have : ∀ i, ∃ (T : Set β), MeasurableSet[m i] T ∧ s = f ⁻¹' T := by
      intro i
      -- Measurability in comap means s = f ⁻¹' T for some measurable T
      have hi := hs_all i
      rw [MeasurableSpace.measurableSet_comap] at hi
      rcases hi with ⟨T, hT, hpre⟩
      exact ⟨T, hT, hpre.symm⟩
    -- Choose the witnesses Tᵢ along with measurability and the preimage identity.
    choose T hTmeas hspre using this
    -- All `T i` are equal because their preimages are all `s` and `f` is surjective.
    have hinj := MeasurableSpace.preimage_injective_of_surjective (α := α) (β := β) hf
    have Tall : ∀ i j, T i = T j := by
      intro i j
      have : f ⁻¹' T i = f ⁻¹' T j := by rw [← hspre i, ← hspre j]
      exact hinj this
    -- Fix an index `i₀` and set `T₀ := T i₀`.
    rcases ‹Nonempty ι› with ⟨i₀⟩
    let T0 : Set β := T i₀
    have T_all : ∀ i, T i = T0 := fun i => Tall i i₀
    -- Rewrite the data with `T0`.
    have s_pre : s = f ⁻¹' T0 := by simpa [T_all i₀] using hspre i₀
    have T0_meas_all : ∀ i, MeasurableSet[m i] T0 := fun i => by simpa [T_all i] using hTmeas i
    -- Conclude: `s` is the preimage of a set measurable in every `m i`,
    -- hence `s` is measurable in `comap f (⨅ i, m i)`.
    refine ⟨T0, ?_, s_pre.symm⟩
    -- Measurable in `⨅ i, m i` means measurable in every slice.
    rw [MeasurableSpace.measurableSet_iInf]
    exact T0_meas_all

  exact le_antisymm hle hge

/-! ### Bridge Lemmas (LOAD-BEARING - Phase 1a) -/

/-- On path space: the pullback of the product σ-algebra by the `n`-fold shift equals
    the join of the coordinate pullbacks at indices `n+k`.

    **Proof strategy:** Use that the product σ-algebra on (ℕ → α) is generated by
    coordinate maps ω ↦ ω k. Apply comap_comp with eval (n+k) = (eval k) ∘ (shift^[n]),
    then bundle via iSup_congr. -/
lemma comap_shift_eq_iSup_comap_coords (n : ℕ) :
    MeasurableSpace.comap (fun (ω : ℕ → α) => fun k => ω (n + k))
        (inferInstance : MeasurableSpace (ℕ → α))
      =
    iSup (fun k : ℕ =>
      MeasurableSpace.comap (fun (ω : ℕ → α) => ω (n + k))
        (inferInstance : MeasurableSpace α)) := by
  -- Product σ-algebra is the supremum of coordinate pullbacks
  conv_lhs => rw [show (inferInstance : MeasurableSpace (ℕ → α)) = MeasurableSpace.pi from rfl]
  -- Expand pi as supremum of coordinate comaps
  rw [show MeasurableSpace.pi = iSup (fun k : ℕ => MeasurableSpace.comap (fun ω => ω k) inferInstance) from rfl]
  -- Distribute comap over supremum
  rw [MeasurableSpace.comap_iSup]
  -- Compose: (eval k) ∘ (shift n) = eval (n+k)
  congr 1
  ext k
  rw [MeasurableSpace.comap_comp]

omit [MeasurableSpace Ω] in
/-- Helper: Each `tailFamily X n` equals the pullback along the sample-path map of the
    n-shifted path-space σ-algebra. This is the key to connecting the two formulations. -/
lemma tailFamily_eq_comap_sample_path_shift (X : ℕ → Ω → α) (n : ℕ) :
    tailFamily X n =
    MeasurableSpace.comap (fun ω : Ω => fun k => X k ω)
      (MeasurableSpace.comap (fun (ω : ℕ → α) => fun k => ω (n + k)) inferInstance) := by
  simp only [tailFamily]
  -- LHS: ⨆ k, comap (X (n+k))
  -- RHS: comap Φ (comap shift_n) = comap Φ (⨆ k, comap (eval (n+k)))
  calc ⨆ k, MeasurableSpace.comap (fun ω => X (n + k) ω) inferInstance
      = ⨆ k, MeasurableSpace.comap ((fun ω => ω (n + k)) ∘ (fun ω k => X k ω)) inferInstance := by
        rfl
    _ = ⨆ k, MeasurableSpace.comap (fun ω k => X k ω) (MeasurableSpace.comap (fun ω => ω (n + k)) inferInstance) := by
        congr 1; funext k; rw [MeasurableSpace.comap_comp]
    _ = MeasurableSpace.comap (fun ω k => X k ω) (⨆ k, MeasurableSpace.comap (fun ω => ω (n + k)) inferInstance) := by
        rw [← MeasurableSpace.comap_iSup]
    _ = MeasurableSpace.comap (fun ω k => X k ω) (MeasurableSpace.comap (fun ω k => ω (n + k)) inferInstance) := by
        rw [← comap_shift_eq_iSup_comap_coords n]

/-- **Bridge 1 (path ↔ process).**
    For the coordinate process on path space, `tailProcess` equals `tailShift`.

    **Proof strategy:** Apply iInf_congr using comap_shift_eq_iSup_comap_coords. -/
lemma tailProcess_coords_eq_tailShift :
    tailProcess (fun k (ω : ℕ → α) => ω k) = tailShift α := by
  -- The key observation: for X = (fun k ω => ω k), we have X (n+k) ω = ω (n+k)
  simp only [tailProcess, tailShift]
  -- Both sides are iInf over n of the same expression (by comap_shift_eq_iSup_comap_coords)
  congr 1
  funext n
  -- Goal: ⨆ k, comap (fun ω => ω (n+k)) = comap (shift n) pi
  exact (comap_shift_eq_iSup_comap_coords n).symm

omit [MeasurableSpace Ω] in
/-- **Bridge 2a (unconditional inequality).**
    The process tail is always at least as coarse as the pullback of the path tail.

    **Note:** Equality holds when the sample-path map is surjective.
    See `tailProcess_eq_comap_path_of_surjective`. -/
lemma comap_path_tailShift_le_tailProcess (X : ℕ → Ω → α) :
    MeasurableSpace.comap (fun ω : Ω => fun k => X k ω) (tailShift α) ≤ tailProcess X := by
  simp only [tailProcess, tailShift]
  trans (iInf (fun n => MeasurableSpace.comap (fun ω : Ω => fun k => X k ω)
    (MeasurableSpace.comap (fun (ω : ℕ → α) => fun k => ω (n + k)) inferInstance)))
  · exact comap_iInf_le _ _
  · apply le_iInf
    intro m
    have : tailFamily X m =
        MeasurableSpace.comap (fun ω k => X k ω)
          (MeasurableSpace.comap (fun ω k => ω (m + k)) inferInstance) :=
      tailFamily_eq_comap_sample_path_shift X m
    rw [this]
    exact iInf_le (fun n => MeasurableSpace.comap (fun ω k => X k ω)
      (MeasurableSpace.comap (fun ω k => ω (n + k)) inferInstance)) m

omit [MeasurableSpace Ω] in
/-- **Bridge 2b (surjective equality).**
    When the sample-path map `Φ : Ω → (ℕ → α)` given by `Φ ω k := X k ω` is surjective,
    the process tail equals the pullback of the path tail along `Φ`.

    **Proof strategy:** Use `iInf_comap_eq_comap_iInf_of_surjective` with `Nonempty ℕ`. -/
lemma tailProcess_eq_comap_path_of_surjective
    (X : ℕ → Ω → α)
    (hΦ : Function.Surjective (fun ω : Ω => fun k => X k ω)) :
  tailProcess X
    =
  MeasurableSpace.comap (fun ω : Ω => fun k => X k ω) (tailShift α) := by
  classical
  simp only [tailProcess, tailShift]
  have step1 : iInf (tailFamily X) =
      iInf (fun n => MeasurableSpace.comap (fun ω k => X k ω)
        (MeasurableSpace.comap (fun ω k => ω (n + k)) inferInstance)) := by
    congr 1; funext n; exact tailFamily_eq_comap_sample_path_shift X n
  rw [step1]
  haveI : Nonempty ℕ := ⟨0⟩
  exact iInf_comap_eq_comap_iInf_of_surjective (α := Ω) (β := (ℕ → α)) hΦ
    (fun n => MeasurableSpace.comap (fun ω k => ω (n + k)) inferInstance)

omit [MeasurableSpace Ω] in
/-- **Bridge 3 (to ViaMartingale's revFiltration).**
    If `revFiltration X m` is defined as the σ-algebra generated by all `X (m+k)`,
    then the tail equals `⨅ m, revFiltration X m`.

    **Proof strategy:** Rewrite each slice using hrev, then unfold tailProcess. -/
lemma tailProcess_eq_iInf_revFiltration
    (X : ℕ → Ω → α)
    (revFiltration : (ℕ → Ω → α) → ℕ → MeasurableSpace Ω)
    (hrev :
      ∀ m, revFiltration X m
            =
          iSup (fun k : ℕ =>
            MeasurableSpace.comap (fun ω => X (m + k) ω) inferInstance)) :
    tailProcess X = iInf (fun m => revFiltration X m) := by
  simp only [tailProcess]
  congr 1
  funext m
  simp only [tailFamily]
  rw [hrev m]

/-! ### General Properties -/

/-- Tail σ-algebra is sub-σ-algebra of ambient space when all X_k are measurable. -/
lemma tailProcess_le_ambient (X : ℕ → Ω → α) (hX : ∀ k, Measurable (X k)) :
    tailProcess X ≤ (inferInstance : MeasurableSpace Ω) := by
  apply iInf_le_of_le 0
  apply iSup_le
  intro k
  -- comap (X (0+k)) ≤ ambient iff ambient ≤ map (X (0+k)) ambient
  -- which holds because X (0+k) is measurable
  rw [MeasurableSpace.comap_le_iff_le_map]
  exact (hX (0 + k)).le_map

/-! NOTE: For probability/finite measures, trimming to the tail σ-algebra preserves
    sigma-finiteness. This is automatic via type class inference in mathlib. -/

end Tail

end Exchangeability.Tail
