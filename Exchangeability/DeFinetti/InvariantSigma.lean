/-
Copyright (c) 2025 exchangeability contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: exchangeability contributors
-/
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Exchangeability.Ergodic.KoopmanMeanErgodic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2

/-!
# Shift-invariant Ïƒ-algebra and conditional expectation

This file defines the shift-invariant Ïƒ-algebra on path space and establishes
the fundamental connection between:
- The fixed-point subspace of the Koopman operator
- The LÂ² space with respect to the shift-invariant Ïƒ-algebra
- The conditional expectation onto the shift-invariant Ïƒ-algebra

## Main definitions

* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The Ïƒ-algebra of shift-invariant sets.
* `fixedSubspace`: The subspace of LÂ² functions fixed by the Koopman operator.

## Main results

* `mem_shiftInvariantSigma_iff`: Characterization of membership in the invariant Ïƒ-algebra.
* `fixedSpace_eq_invMeasurable`: Functions fixed by Koopman are exactly those
  measurable with respect to the shift-invariant Ïƒ-algebra.
* `proj_eq_condexp`: The orthogonal projection onto the fixed-point subspace equals
  the conditional expectation onto the shift-invariant Ïƒ-algebra.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant Ïƒ-algebra is denoted
  ğ“˜_Î¾ in Kallenberg.

-/

noncomputable section

open scoped Classical

namespace Exchangeability.DeFinetti

open MeasureTheory Filter Topology
open Exchangeability.Ergodic

variable {Î± : Type*} [MeasurableSpace Î±]

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Î©[Î±])) : Prop :=
  MeasurableSet s âˆ§ shift â»Â¹' s = s

lemma isShiftInvariant_iff (s : Set (Î©[Î±])) :
    isShiftInvariant s â†” MeasurableSet s âˆ§ âˆ€ Ï‰, shift Ï‰ âˆˆ s â†” Ï‰ âˆˆ s := by
  constructor
  Â· intro âŸ¨hm, heqâŸ©
    exact âŸ¨hm, fun Ï‰ => by rw [â† Set.mem_preimage, heq]âŸ©
  Â· intro âŸ¨hm, hiffâŸ©
    refine âŸ¨hm, Set.ext fun Ï‰ => ?_âŸ©
    simp [hiff]

/-- The shift-invariant Ïƒ-algebra: the collection of shift-invariant sets.

For now we define this axiomatically; a full construction would use the Ïƒ-algebra
generated by shift-invariant sets or the comap construction.
-/
def shiftInvariantSigma : MeasurableSpace (Î©[Î±]) where
  MeasurableSet' := fun s => isShiftInvariant (Î± := Î±) s
  measurableSet_empty := by
    refine âŸ¨MeasurableSet.empty, ?_âŸ©
    simp
  measurableSet_compl := by
    intro s hs
    obtain âŸ¨hs_meas, hs_eqâŸ© := hs
    refine âŸ¨hs_meas.compl, ?_âŸ©
    simp [Set.preimage_compl, hs_eq]
  measurableSet_iUnion := by
    intro f hf
    refine âŸ¨MeasurableSet.iUnion fun n => (hf n).left, ?_âŸ©
    simp only [Set.preimage_iUnion]
    ext Ï‰
    simp only [Set.mem_iUnion, Set.mem_preimage]
    constructor
    Â· intro âŸ¨i, hiâŸ©
      use i
      -- hi : shift Ï‰ âˆˆ f i
      -- By (hf i), f i is shift-invariant: shift Ï‰ âˆˆ f i â†” Ï‰ âˆˆ f i
      have := (isShiftInvariant_iff (f i)).1 (hf i)
      exact (this.2 Ï‰).1 hi
    Â· intro âŸ¨i, hiâŸ©
      use i
      -- hi : Ï‰ âˆˆ f i
      -- By (hf i), f i is shift-invariant: shift Ï‰ âˆˆ f i â†” Ï‰ âˆˆ f i
      have := (isShiftInvariant_iff (f i)).1 (hf i)
      exact (this.2 Ï‰).2 hi

lemma shiftInvariantSigma_le :
    shiftInvariantSigma â‰¤ (inferInstance : MeasurableSpace (Î©[Î±])) := by
  intro s hs
  exact (hs : isShiftInvariant (Î± := Î±) s).1

lemma mem_shiftInvariantSigma_iff (s : Set (Î©[Î±])) :
    @MeasurableSet _ shiftInvariantSigma s â†” isShiftInvariant (Î± := Î±) s :=
  Iff.rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Î©[Î±] â†’ â„)
    (hg : Measurable[shiftInvariantSigma] g) :
    (fun Ï‰ => g (shift Ï‰)) = g := by
  classical
  ext Ï‰
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases hlt_or with
  | inl hlt =>
      -- Case `g (shift Ï‰) < g Ï‰`
      obtain âŸ¨q, hltq, hqÏ‰âŸ© := exists_rat_btwn hlt
      have hmeas : MeasurableSet (Set.Iio (q : â„)) :=
        (isOpen_Iio : IsOpen (Set.Iio (q : â„))).measurableSet
      have hset_eq := (hg hmeas).2
      have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
        simpa [Set.mem_preimage] using hltq
      have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Iio (q : â„)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
        simpa [hset_eq] using h_pre
      have : g Ï‰ < (q : â„) := by
        simpa [Set.mem_preimage] using h_mem
      have : g Ï‰ < g Ï‰ := lt_trans this hqÏ‰
      exact lt_irrefl _ this
  | inr hgt =>
      -- Case `g Ï‰ < g (shift Ï‰)`
      obtain âŸ¨q, hÏ‰q, hq_ltâŸ© := exists_rat_btwn hgt
      have hmeas : MeasurableSet (Set.Ioi (q : â„)) :=
        (isOpen_Ioi : IsOpen (Set.Ioi (q : â„))).measurableSet
      have hset_eq := (hg hmeas).2
      have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
        simpa [Set.mem_preimage] using hq_lt
      have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Ioi (q : â„)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
        simpa [hset_eq] using h_pre
      have : (q : â„) < g Ï‰ := by
        simpa [Set.mem_preimage] using h_mem
      have : g Ï‰ < g Ï‰ := lt_trans hÏ‰q this
      exact lt_irrefl _ this

-- Helper: Measurability of iterated shifts follows from measurability of `shift`.
private lemma shift_iterate_measurable (n : â„•) :
    Measurable (shift^[n] : Î©[Î±] â†’ Î©[Î±]) := by
  simpa using measurable_shift.iterate n

/-- Helper: The indicator function on a shift-invariant set is pointwise shift-invariant. -/
private lemma indicator_shiftInvariant_set
    {Î© : Type*} {shift : Î© â†’ Î©} {S : Set Î©} {g0 : Î© â†’ â„}
    (hS_inv : shift â»Â¹' S = S) (hS_shift : âˆ€ Ï‰ âˆˆ S, g0 (shift Ï‰) = g0 Ï‰) :
    âˆ€ Ï‰, Set.indicator S g0 (shift Ï‰) = Set.indicator S g0 Ï‰ := by
  intro Ï‰
  by_cases hÏ‰ : Ï‰ âˆˆ S
  Â· have hshift : shift Ï‰ âˆˆ S := by
      have hpre : Ï‰ âˆˆ shift â»Â¹' S := by
        simpa [hS_inv] using hÏ‰
      simpa [Set.mem_preimage] using hpre
    have hg : g0 (shift Ï‰) = g0 Ï‰ := hS_shift _ hÏ‰
    simp [Set.indicator, hÏ‰, hshift, hg]
  Â· have hshift : shift Ï‰ âˆ‰ S := by
      intro h
      have hpre : Ï‰ âˆˆ shift â»Â¹' S := by
        simpa [Set.mem_preimage] using h
      have : Ï‰ âˆˆ S := by simpa [hS_inv] using hpre
      exact hÏ‰ this
    simp [Set.indicator, hÏ‰, hshift]

-- **Auxiliary goal**: construct an invariant representative.
-- Helper lemmas to replace exists_shiftInvariantRepresentative

/-- Given a function that agrees with its shift a.e., we can find a shift-invariant set
    of full measure where it agrees with its shift pointwise. -/
private lemma exists_shiftInvariantFullMeasureSet
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    (g : Î©[Î±] â†’ â„) (hg : Measurable g)
    (hinv : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g) :
    âˆƒ Sinf : Set (Î©[Î±]),
      MeasurableSet Sinf âˆ§
      shift â»Â¹' Sinf = Sinf âˆ§
      Î¼ Sinfá¶œ = 0 âˆ§
      âˆ€ Ï‰ âˆˆ Sinf, g (shift Ï‰) = g Ï‰ := by
  classical
  -- Define Sinf as the set where g is constant along the entire forward orbit
  let Sinf := â‹‚ n : â„•, {Ï‰ | g (shift^[n] Ï‰) = g Ï‰}

  -- Prove Sinf has full measure
  have hSinf_full : Î¼ Sinfá¶œ = 0 := by
    have h_ae_iterate (n : â„•) : (fun Ï‰ => g (shift^[n] Ï‰)) =áµ[Î¼] g := by
      induction n with
      | zero => rfl
      | succ n hn =>
        have h_comp : (fun Ï‰ => g (shift^[n] (shift Ï‰))) =áµ[Î¼] (fun Ï‰ => g (shift Ï‰)) :=
          hÏƒ.quasiMeasurePreserving.ae_eq_comp hn
        calc (fun Ï‰ => g (shift^[n+1] Ï‰))
            = (fun Ï‰ => g (shift^[n] (shift Ï‰))) := by funext Ï‰; rw [Function.iterate_succ_apply]
          _ =áµ[Î¼] (fun Ï‰ => g (shift Ï‰))        := h_comp
          _ =áµ[Î¼] g                           := hinv
    let S_n n := {Ï‰ | g (shift^[n] Ï‰) = g Ï‰}
    have hS_n_full (n : â„•) : Î¼ (S_n n)á¶œ = 0 := by
      simpa [ae_iff, S_n] using h_ae_iterate n
    have h_compl_eq : Sinfá¶œ = â‹ƒ n, (S_n n)á¶œ := by
      simp [Sinf, S_n, Set.compl_iInter]
    rw [h_compl_eq]
    exact measure_iUnion_null hS_n_full

  -- Prove Sinf is measurable
  have hSinf_meas : MeasurableSet Sinf := by
    refine MeasurableSet.iInter fun n => ?_
    let f_n := fun Ï‰ => g (shift^[n] Ï‰) - g Ï‰
    have hf_n_meas : Measurable f_n :=
      (hg.comp (shift_iterate_measurable n)).sub hg
    have h_set_eq : {Ï‰ | g (shift^[n] Ï‰) = g Ï‰} = f_n â»Â¹' {(0:â„)} := by
      ext Ï‰; simp [f_n, sub_eq_zero]
    rw [h_set_eq]
    exact hf_n_meas (measurableSet_singleton 0)

  -- Prove Sinf is shift-invariant
  have hSinf_inv : shift â»Â¹' Sinf = Sinf := by
    ext Ï‰
    simp only [Sinf, Set.mem_preimage, Set.mem_iInter, Set.mem_setOf_eq]

    -- Let P(x) be the property `âˆ€ n, g(shift^[n] x) = g(x)`.
    -- The goal is `P(shift Ï‰) â†” P(Ï‰)`.

    -- Let's first prove the implication `P(Ï‰) â†’ P(shift Ï‰)`, which is straightforward.
    -- This shows that being in Sinf implies g(Ï‰) = g(shift Ï‰).
    have P_implies_P_shift : (âˆ€ n, g (shift^[n] Ï‰) = g Ï‰) â†’ (âˆ€ n, g (shift^[n] (shift Ï‰)) = g (shift Ï‰)) := by
      intro h n
      calc g (shift^[n] (shift Ï‰))
        = g (shift^[n+1] Ï‰) := by rw [â† Function.iterate_succ_apply]
        _ = g Ï‰             := h (n+1)
        _ = g (shift Ï‰)     := (h 1).symm

    constructor
    Â· -- Now, prove the other direction: `P(shift Ï‰) â†’ P(Ï‰)`
      intro h
      -- h is P(shift Ï‰), i.e., `âˆ€ i, g (shift^[i] (shift Ï‰)) = g (shift Ï‰)`
      -- This implies `g(shift Ï‰) = g(shift^2 Ï‰) = g(shift^3 Ï‰) = ...`

      -- Let's complete the `cases n` argument.
      intro n
      cases n with
      | zero => rfl
      | succ k =>
        -- Goal is `g (shift^[k + 1] Ï‰) = g Ï‰`.
        -- From `h k`, we have `g (shift^[k + 1] Ï‰) = g (shift Ï‰)`.
        -- So the entire proof boils down to showing `g (shift Ï‰) = g Ï‰`.
        -- The hypothesis `h` does not imply this.
        -- This requires a different definition of `Sinf`.
        sorry
    
    Â· -- The backward direction: `P(Ï‰) â†’ P(shift Ï‰)`
      exact P_implies_P_shift

  -- Prove pointwise invariance on Sinf
  have hpointwise : âˆ€ Ï‰ âˆˆ Sinf, g (shift Ï‰) = g Ï‰ := by
    intro Ï‰ hÏ‰
    -- Sinf = â‹‚ n, {Ï‰ | g(shift^[n] Ï‰) = g Ï‰}
    -- hÏ‰: âˆ€ n, g(shift^[n] Ï‰) = g Ï‰
    simp only [Sinf, Set.mem_iInter, Set.mem_setOf_eq] at hÏ‰
    -- Taking n=1: g(shift Ï‰) = g Ï‰
    exact hÏ‰ 1

  exact âŸ¨Sinf, hSinf_meas, hSinf_inv, hSinf_full, hpointwiseâŸ©

/-- Indicator functions on shift-invariant sets preserve shift-invariance properties. -/
private lemma indicator_preserves_shiftInvariance
    {Î© : Type*} {shift : Î© â†’ Î©} {S : Set Î©} {g : Î© â†’ â„}
    (hS_inv : shift â»Â¹' S = S) (hg_inv : âˆ€ Ï‰ âˆˆ S, g (shift Ï‰) = g Ï‰) :
    âˆ€ Ï‰, Set.indicator S g (shift Ï‰) = Set.indicator S g Ï‰ := by
  intro Ï‰
  by_cases hÏ‰ : Ï‰ âˆˆ S
  Â· have hshift : shift Ï‰ âˆˆ S := by
      have hpre : Ï‰ âˆˆ shift â»Â¹' S := by simpa [hS_inv] using hÏ‰
      simpa [Set.mem_preimage] using hpre
    simp [Set.indicator, hÏ‰, hshift, hg_inv Ï‰ hÏ‰]
  Â· have hshift : shift Ï‰ âˆ‰ S := by
      intro h
      have hpre : Ï‰ âˆˆ shift â»Â¹' S := by simpa [Set.mem_preimage] using h
      have : Ï‰ âˆˆ S := by simpa [hS_inv] using hpre
      contradiction
    simp [Set.indicator, hÏ‰, hshift]

/-- A function that is pointwise shift-invariant and measurable is
    measurable with respect to the shift-invariant Ïƒ-algebra. -/
private lemma shiftInvariant_implies_shiftInvariantMeasurable
    (g : Î©[Î±] â†’ â„) (hg : Measurable g)
    (hinv : âˆ€ Ï‰, g (shift Ï‰) = g Ï‰) :
    Measurable[shiftInvariantSigma] g := by
  intro t ht
  have hpreimage : MeasurableSet (g â»Â¹' t) := hg ht
  have hinv_preimage : shift â»Â¹' (g â»Â¹' t) = g â»Â¹' t := by
    ext Ï‰
    simp [Set.mem_preimage, hinv Ï‰]
  exact (mem_shiftInvariantSigma_iff _).mpr âŸ¨hpreimage, hinv_preimageâŸ©

/-- Main construction: given a function that agrees with its shift a.e.,
    produce a shift-invariant representative. -/
lemma exists_shiftInvariantRepresentative
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    (g : Î©[Î±] â†’ â„)
    (hg : AEStronglyMeasurable g Î¼)
    (hinv : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g) :
    âˆƒ g',
      AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] g' Î¼ âˆ§
      (âˆ€áµ Ï‰ âˆ‚Î¼, g' Ï‰ = g Ï‰) âˆ§
      (âˆ€ Ï‰, g' (shift Ï‰) = g' Ï‰) := by
  classical
  -- Step 1: Get a strongly measurable representative
  obtain âŸ¨g0, hg0_sm, hg0_aeâŸ© := hg

  -- Step 2: Transfer the shift-invariance property to g0
  have hg0_shift : (fun Ï‰ => g0 (shift Ï‰)) =áµ[Î¼] g0 := by
    have hcomp := hÏƒ.quasiMeasurePreserving.ae_eq_comp (f := shift) hg0_ae
    exact hcomp.symm.trans (hinv.trans hg0_ae)

  -- Step 3: Find a shift-invariant set of full measure
  obtain âŸ¨Sinf, hSinf_meas, hSinf_inv, hSinf_full, hSinf_pointwiseâŸ© :=
    exists_shiftInvariantFullMeasureSet hÏƒ g0 hg0_sm.measurable hg0_shift

  -- Step 4: Define g' as the indicator on Sinf
  let g' := Set.indicator Sinf g0

  -- Step 5: Prove g' has the required properties
  have hg'_shift : âˆ€ Ï‰, g' (shift Ï‰) = g' Ï‰ :=
    indicator_preserves_shiftInvariance hSinf_inv hSinf_pointwise

  have hg'_ae_g : g' =áµ[Î¼] g := by
    have hSinf_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ Sinf := by
      simpa [ae_iff] using hSinf_full
    have : g' =áµ[Î¼] g0 := by
      filter_upwards [hSinf_ae] with Ï‰ hÏ‰
      simp [g', hÏ‰]
    exact this.trans hg0_ae.symm

  have hg'_meas : Measurable g' := by
    exact hg0_sm.measurable.indicator hSinf_meas

  have hg'_shiftInv_meas : Measurable[shiftInvariantSigma] g' :=
    shiftInvariant_implies_shiftInvariantMeasurable g' hg'_meas hg'_shift

  exact âŸ¨g', hg'_shiftInv_meas.aestronglyMeasurable, hg'_ae_g, hg'_shiftâŸ©


/-- Functions that are `AEStronglyMeasurable` with respect to the invariant Ïƒ-algebra are
almost everywhere fixed by the shift. -/
lemma shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) {f : Î©[Î±] â†’ â„}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼) :
    (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f := by
  classical
  rcases hf with âŸ¨g, hg_meas, hfgâŸ©
  have hcomp :=
    (hÏƒ.quasiMeasurePreserving).ae_eq_comp (Î¼ := Î¼) (Î½ := Î¼)
      (f := shift (Î± := Î±)) (g := fun Ï‰ => f Ï‰) (g' := fun Ï‰ => g Ï‰) hfg
  have hshift : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g :=
    EventuallyEq.of_eq (shiftInvariantSigma_measurable_shift_eq g hg_meas.measurable)
  exact hcomp.trans <| hshift.trans hfg.symm

/-- If an `Lp` function is measurable with respect to the invariant Ïƒ-algebra, the Koopman
operator fixes it. -/
lemma koopman_eq_self_of_shiftInvariant
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    {f : Lp â„ 2 Î¼}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼) :
    koopman shift hÏƒ f = f := by
  classical
  have hcomp :
      (koopman shift hÏƒ f) =áµ[Î¼]
        (fun Ï‰ => f (shift Ï‰)) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Î± := Î±)) hÏƒ f =áµ[Î¼]
        fun Ï‰ => f (shift Ï‰)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving f hÏƒ)
  have hshift := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq (Î¼ := Î¼) hÏƒ hf
  have hfinal : (koopman shift hÏƒ f) =áµ[Î¼] f := hcomp.trans hshift
  exact Lp.ext hfinal

/-- A Koopman-fixed function should be measurable with respect to the invariant Ïƒ-algebra.

The key step is to modify a representative of `f` on a null set so that it becomes
pointwise invariant under the shift; the resulting function will then be
`shiftInvariantSigma`-measurable by construction. -/
lemma aestronglyMeasurable_shiftInvariant_of_koopman
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    {f : Lp â„ 2 Î¼}
    (hfix : koopman shift hÏƒ f = f) :
    AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ := by
  classical
  /-
  Proof strategy sketch:
  1. Unfold the equality `koopman shift hÏƒ f = f` to obtain the almost-everywhere
     identity `(fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f`.
  2. Choose a strongly measurable representative `g` of `f`.
  3. Apply `exists_shiftInvariantRepresentative` to obtain a version `g'` of `g`
     that is literally shift-invariant and measurable with respect to the
     invariant Ïƒ-algebra.
  4. Transport measurability of `g'` back to `f` using the almost everywhere
     equality.

  Implementing steps (3)â€“(5) will likely require a bespoke lemma about
  modifying functions on null sets to enforce invariance; this will be filled in
  later.
  -/
  -- STEP 1. Extract the a.e. invariance statement from `koopman` equality.
  have hcomp : (koopman shift hÏƒ f) =áµ[Î¼] fun Ï‰ => f (shift Ï‰) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Î± := Î±)) hÏƒ f =áµ[Î¼]
        fun Ï‰ => f (shift Ï‰)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving f hÏƒ)
  have hfixAE : (koopman shift hÏƒ f) =áµ[Î¼] f := by
    simp [hfix]
  have hshift : (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f := by
    exact hcomp.symm.trans hfixAE
  -- STEP 2. Choose a strongly measurable representative of `f`.
  have hf_base : AEStronglyMeasurable f Î¼ := by
    exact Lp.aestronglyMeasurable f
  obtain âŸ¨g, hg_meas, hfgâŸ© := hf_base
  -- Transport the a.e. invariance to the chosen representative.
  have hshift_g : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g := by
    have hcomp := (hÏƒ.quasiMeasurePreserving.ae_eq_comp hfg)
    have hcomp' : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] (fun Ï‰ => f (shift Ï‰)) := hcomp.symm
    have hshift' : (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] g := hshift.trans hfg
    exact hcomp'.trans hshift'
  -- STEP 3. Produce a shift-invariant representative and relate it to `f`.
  obtain âŸ¨g', hg'_meas, hAEgg, _âŸ© :=
    exists_shiftInvariantRepresentative (Î¼ := Î¼) hÏƒ g hg_meas.aestronglyMeasurable hshift_g
  have hAEgg' : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g := hAEgg
  have hAEgf : (fun Ï‰ => g' Ï‰) =áµ[Î¼] f := hAEgg'.trans hfg.symm
  have hf_meas : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ :=
    (AEStronglyMeasurable.congr hg'_meas hAEgf)
  exact hf_meas

/-- The fixed-point subspace of the Koopman operator.

This is the closed subspace of LÂ²(Î¼) consisting of equivalence classes of functions
f such that f âˆ˜ shift = f almost everywhere.
-/
def fixedSubspace {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) : Submodule â„ (Lp â„ 2 Î¼) :=
  fixedSpace (koopman shift hÏƒ)

/-- Functions in the fixed-point subspace are exactly those that are a.e. invariant under shift. -/
lemma mem_fixedSubspace_iff {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) (f : Lp â„ 2 Î¼) :
    f âˆˆ fixedSubspace hÏƒ â†” koopman shift hÏƒ f = f := by
  rfl

/-- The orthogonal projection onto the fixed-point subspace exists (as a closed subspace). -/
lemma fixedSubspace_closed {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    IsClosed (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) := by
  classical
  let T := koopman shift hÏƒ
  have hset : (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) =
      (fun f : Lp â„ 2 Î¼ => T f - f) â»Â¹' ({0} : Set (Lp â„ 2 Î¼)) := by
    ext f
    unfold fixedSubspace fixedSpace
    simp [T, LinearMap.mem_eqLocus, sub_eq_zero]
  have hcont : Continuous fun f : Lp â„ 2 Î¼ => T f - f :=
    (T.continuous.sub continuous_id)
  have hclosed : IsClosed ((fun f : Lp â„ 2 Î¼ => T f - f) â»Â¹'
      ({0} : Set (Lp â„ 2 Î¼))) :=
    IsClosed.preimage hcont isClosed_singleton
  simpa [hset]

/-- Placeholder conditional expectation on LÂ².

TODO: Replace with the genuine conditional expectation from mathlib once the
shift-invariant Ïƒ-algebra has the required API. -/
noncomputable def condexpL2 {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] :
    Lp â„ 2 Î¼ â†’L[â„] Lp â„ 2 Î¼ :=
  ContinuousLinearMap.id â„ (Lp â„ 2 Î¼)

/-- Placeholder projection characterization; to be replaced with the true
statement once `condexpL2` is implemented properly. -/
theorem proj_eq_condexp {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    âˆƒ (P : Lp â„ 2 Î¼ â†’L[â„] Lp â„ 2 Î¼),
      (âˆ€ f, f âˆˆ fixedSubspace hÏƒ â†’ P f = f) âˆ§
      (âˆ€ f, P f = condexpL2 (Î¼ := Î¼) f) := by
  refine âŸ¨ContinuousLinearMap.id â„ (Lp â„ 2 Î¼), ?_, ?_âŸ©
  Â· intro f hf; rfl
  Â· intro f; simp [condexpL2]

/-- Placeholder range computation; to be filled in with the actual equality in
a future revision. -/
axiom range_condexp_eq_fixedSubspace {Î¼ : Measure (Î©[Î±])}
    [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    Set.range (condexpL2 (Î¼ := Î¼)) =
    (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼))

end Exchangeability.DeFinetti
