/-
Copyright (c) 2025 exchangeability contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: exchangeability contributors
-/
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Exchangeability.Ergodic.KoopmanMeanErgodic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2

/-!
# Shift-invariant Ïƒ-algebra and conditional expectation

This file defines the shift-invariant Ïƒ-algebra on path space and establishes
the fundamental connection between:
- The fixed-point subspace of the Koopman operator
- The LÂ² space with respect to the shift-invariant Ïƒ-algebra
- The conditional expectation onto the shift-invariant Ïƒ-algebra

## Main definitions

* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The Ïƒ-algebra of shift-invariant sets.
* `fixedSubspace`: The subspace of LÂ² functions fixed by the Koopman operator.

## Main results

* `mem_shiftInvariantSigma_iff`: Characterization of membership in the invariant Ïƒ-algebra.
* `fixedSpace_eq_invMeasurable`: Functions fixed by Koopman are exactly those
  measurable with respect to the shift-invariant Ïƒ-algebra.
* `proj_eq_condexp`: The orthogonal projection onto the fixed-point subspace equals
  the conditional expectation onto the shift-invariant Ïƒ-algebra.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant Ïƒ-algebra is denoted
  ğ“˜_Î¾ in Kallenberg.

-/

noncomputable section

open scoped Classical

namespace Exchangeability.DeFinetti

open MeasureTheory Filter Topology
open Exchangeability.Ergodic

variable {Î± : Type*} [MeasurableSpace Î±]

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Î©[Î±])) : Prop :=
  MeasurableSet s âˆ§ shift â»Â¹' s = s

lemma isShiftInvariant_iff (s : Set (Î©[Î±])) :
    isShiftInvariant s â†” MeasurableSet s âˆ§ âˆ€ Ï‰, shift Ï‰ âˆˆ s â†” Ï‰ âˆˆ s := by
  constructor
  Â· intro âŸ¨hm, heqâŸ©
    exact âŸ¨hm, fun Ï‰ => by rw [â† Set.mem_preimage, heq]âŸ©
  Â· intro âŸ¨hm, hiffâŸ©
    refine âŸ¨hm, Set.ext fun Ï‰ => ?_âŸ©
    simp [hiff]

/-- The shift-invariant Ïƒ-algebra: the collection of shift-invariant sets.

For now we define this axiomatically; a full construction would use the Ïƒ-algebra
generated by shift-invariant sets or the comap construction.
-/
def shiftInvariantSigma : MeasurableSpace (Î©[Î±]) where
  MeasurableSet' := fun s => isShiftInvariant (Î± := Î±) s
  measurableSet_empty := by
    refine âŸ¨MeasurableSet.empty, ?_âŸ©
    simp
  measurableSet_compl := by
    intro s hs
    obtain âŸ¨hs_meas, hs_eqâŸ© := hs
    refine âŸ¨hs_meas.compl, ?_âŸ©
    simp [Set.preimage_compl, hs_eq]
  measurableSet_iUnion := by
    intro f hf
    refine âŸ¨MeasurableSet.iUnion fun n => (hf n).left, ?_âŸ©
    simp only [Set.preimage_iUnion]
    ext Ï‰
    simp only [Set.mem_iUnion, Set.mem_preimage]
    constructor
    Â· intro âŸ¨i, hiâŸ©
      use i
      -- hi : shift Ï‰ âˆˆ f i
      -- By (hf i), f i is shift-invariant: shift Ï‰ âˆˆ f i â†” Ï‰ âˆˆ f i
      have := (isShiftInvariant_iff (f i)).1 (hf i)
      exact (this.2 Ï‰).1 hi
    Â· intro âŸ¨i, hiâŸ©
      use i
      -- hi : Ï‰ âˆˆ f i
      -- By (hf i), f i is shift-invariant: shift Ï‰ âˆˆ f i â†” Ï‰ âˆˆ f i
      have := (isShiftInvariant_iff (f i)).1 (hf i)
      exact (this.2 Ï‰).2 hi

lemma shiftInvariantSigma_le :
    shiftInvariantSigma â‰¤ (inferInstance : MeasurableSpace (Î©[Î±])) := by
  intro s hs
  exact (hs : isShiftInvariant (Î± := Î±) s).1

lemma mem_shiftInvariantSigma_iff (s : Set (Î©[Î±])) :
    @MeasurableSet _ shiftInvariantSigma s â†” isShiftInvariant (Î± := Î±) s :=
  Iff.rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Î©[Î±] â†’ â„)
    (hg : Measurable[shiftInvariantSigma] g) :
    (fun Ï‰ => g (shift Ï‰)) = g := by
  classical
  ext Ï‰
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases hlt_or with
  | inl hlt =>
      -- Case `g (shift Ï‰) < g Ï‰`
      obtain âŸ¨q, hltq, hqÏ‰âŸ© := exists_rat_btwn hlt
      have hmeas : MeasurableSet (Set.Iio (q : â„)) :=
        (isOpen_Iio : IsOpen (Set.Iio (q : â„))).measurableSet
      have hset_eq := (hg hmeas).2
      have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
        simpa [Set.mem_preimage] using hltq
      have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Iio (q : â„)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
        simpa [hset_eq] using h_pre
      have : g Ï‰ < (q : â„) := by
        simpa [Set.mem_preimage] using h_mem
      have : g Ï‰ < g Ï‰ := lt_trans this hqÏ‰
      exact lt_irrefl _ this
  | inr hgt =>
      -- Case `g Ï‰ < g (shift Ï‰)`
      obtain âŸ¨q, hÏ‰q, hq_ltâŸ© := exists_rat_btwn hgt
      have hmeas : MeasurableSet (Set.Ioi (q : â„)) :=
        (isOpen_Ioi : IsOpen (Set.Ioi (q : â„))).measurableSet
      have hset_eq := (hg hmeas).2
      have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
        simpa [Set.mem_preimage] using hq_lt
      have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Ioi (q : â„)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
        simpa [hset_eq] using h_pre
      have : (q : â„) < g Ï‰ := by
        simpa [Set.mem_preimage] using h_mem
      have : g Ï‰ < g Ï‰ := lt_trans hÏ‰q this
      exact lt_irrefl _ this

-- Helper: Measurability of iterated shifts follows from measurability of `shift`.
private lemma shift_iterate_measurable (n : â„•) :
    Measurable (shift^[n] : Î©[Î±] â†’ Î©[Î±]) := by
  simpa using measurable_shift.iterate n

/-- Helper: The indicator function on a shift-invariant set is pointwise shift-invariant. -/
private lemma indicator_shiftInvariant_set {S : Set (Î©[Î±])} {g0 : Î©[Î±] â†’ â„}
    (hS_inv : shift â»Â¹' S = S) (hS_shift : âˆ€ Ï‰ âˆˆ S, g0 (shift Ï‰) = g0 Ï‰) :
    âˆ€ Ï‰, Set.indicator S g0 (shift Ï‰) = Set.indicator S g0 Ï‰ := by
  intro Ï‰
  by_cases hÏ‰ : Ï‰ âˆˆ S
  Â· have hshift : shift Ï‰ âˆˆ S := by
      have : Ï‰ âˆˆ shift â»Â¹' S := by
        simpa [hS_inv] using hÏ‰
      simpa [Set.mem_preimage] using this
    have hg : g0 (shift Ï‰) = g0 Ï‰ := hS_shift _ hÏ‰
    simp [Set.indicator, hÏ‰, hshift, hg]
  Â· have hshift : shift Ï‰ âˆ‰ S := by
      intro h
      have : Ï‰ âˆˆ shift â»Â¹' S := by
        simpa [Set.mem_preimage] using h
      have : Ï‰ âˆˆ S := by simpa [hS_inv] using this
      exact hÏ‰ this
    simp [Set.indicator, hÏ‰, hshift]

/-- **Auxiliary goal**: construct an invariant representative.

Once `g : Î©[Î±] â†’ â„` is strongly measurable and agrees a.e. with its shift, we expect to
modify it on a null set so that it becomes literally invariant under `shift` while remaining
measurable with respect to `shiftInvariantSigma`.  Filling in this lemma (or a closely related
variant) will let us finish `aestronglyMeasurable_shiftInvariant_of_koopman`. -/
lemma exists_shiftInvariantRepresentative
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    (g : Î©[Î±] â†’ â„)
    (hg : AEStronglyMeasurable g Î¼)
    (hinv : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g) :
    âˆƒ g',
      AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] g' Î¼ âˆ§
      (âˆ€áµ Ï‰ âˆ‚Î¼, g' Ï‰ = g Ï‰) âˆ§
      (âˆ€ Ï‰, g' (shift Ï‰) = g' Ï‰) := by
  classical
  obtain âŸ¨g0, hg0_sm, hAEg0âŸ© := hg
  have hcomp :=
    (hÏƒ.quasiMeasurePreserving.ae_eq_comp (Î¼ := Î¼) (Î½ := Î¼)
      (f := shift (Î± := Î±)) (g := fun Ï‰ => g Ï‰) (g' := fun Ï‰ => g0 Ï‰) hAEg0)
  have hshift0 : (fun Ï‰ => g0 (shift Ï‰)) =áµ[Î¼] g0 := hcomp.symm.trans (hinv.trans hAEg0)
  let S : Set (Î©[Î±]) := {Ï‰ | g0 (shift Ï‰) = g0 Ï‰}
  have hS_null : Î¼ Sá¶œ = 0 := by
    have hS_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ S := by simpa [S, Set.mem_setOf_eq] using hshift0
    simpa [ae_iff, S, Set.mem_setOf_eq] using hS_ae
  let Sâˆ : Set (Î©[Î±]) := â‹‚ n : â„•, (shift^[n]) â»Â¹' S
  have hSinf_null : Î¼ Sâˆá¶œ = 0 := by
    have hcompl : Sâˆá¶œ = â‹ƒ n : â„•, (shift^[n]) â»Â¹' Sá¶œ := by
      simpa [Sâˆ, Set.preimage_compl] using Set.compl_iInter fun n => (shift^[n]) â»Â¹' S
    have hpreimage_null : âˆ€ n : â„•, Î¼ ((shift^[n]) â»Â¹' Sá¶œ) = 0 := fun n =>
      (MeasurePreserving.iterate hÏƒ n).preimage_null hS_null
    simpa [hcompl] using measure_iUnion_null hpreimage_null
  have hSinf_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ Sâˆ := by simpa [ae_iff, Sâˆ] using hSinf_null
  have hSinf_preimage : shift â»Â¹' Sâˆ = Sâˆ := by
    ext Ï‰
    simp only [Set.mem_preimage, Set.mem_iInter]
    constructor
    Â· intro h n
      simpa [Function.iterate_succ, Function.comp] using h (n + 1)
    Â· intro h n
      cases n with
      | zero => simpa using h 0
      | succ n => simpa [Function.iterate_succ, Function.comp] using h n
  let g' : Î©[Î±] â†’ â„ := Set.indicator Sâˆ g0
  have hg'_ae_eq_g : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g := by
    have hg'_ae_eq_g0 : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g0 := by
      filter_upwards [hSinf_ae] with Ï‰ hÏ‰
      simp [g', hÏ‰]
    exact hg'_ae_eq_g0.trans hAEg0
  have hshift_g' : âˆ€ Ï‰, g' (shift Ï‰) = g' Ï‰ := by
    have hS_shift : âˆ€ Ï‰ âˆˆ S, g0 (shift Ï‰) = g0 Ï‰ := by
      intro Ï‰ hÏ‰
      simpa [S, Set.mem_setOf_eq] using hÏ‰
    have hSinf_shift : âˆ€ Ï‰ âˆˆ Sâˆ, g0 (shift Ï‰) = g0 Ï‰ := by
      intro Ï‰ hÏ‰
      have hÏ‰S : Ï‰ âˆˆ S := by
        have := Set.mem_iInter.mp hÏ‰ 0
        simpa [Sâˆ] using this
      exact hS_shift _ hÏ‰S
    exact indicator_shiftInvariant_set hSinf_preimage hSinf_shift
  refine âŸ¨g', ?_, hg'_ae_eq_g, hshift_g'âŸ©
  have hS_meas : MeasurableSet S := by
    have hdiff_meas : Measurable fun Ï‰ => g0 (shift Ï‰) - g0 Ï‰ :=
      (hg0_sm.measurable.comp measurable_shift).sub hg0_sm.measurable
    have hset_eq : S = (fun Ï‰ => g0 (shift Ï‰) - g0 Ï‰) â»Â¹' {0} := by ext Ï‰; simp [S]
    simpa [hset_eq] using hdiff_meas measurableSet_singleton
  have hSinf_meas : MeasurableSet Sâˆ := by
    refine MeasurableSet.iInter fun n => ?_
    simpa [Sâˆ] using (shift_iterate_measurable n) hS_meas
  have hg'_meas : Measurable g' := by
    simpa [g'] using hg0_sm.measurable.indicator hSinf_meas
  have hg'_meas_shift : Measurable[shiftInvariantSigma] g' := by
    intro t ht
    have hset_meas : MeasurableSet (g' â»Â¹' t) := hg'_meas ht
    have hset_inv : shift â»Â¹' (g' â»Â¹' t) = g' â»Â¹' t := by
      ext Ï‰; simp [Set.mem_preimage, hshift_g']
    exact (mem_shiftInvariantSigma_iff (g' â»Â¹' t)).mpr âŸ¨hset_meas, hset_invâŸ©
  exact hg'_meas_shift.aestronglyMeasurable

/-- A pointwise shift-invariant function that is ambient-measurable is measurable with
respect to the shift-invariant Ïƒ-algebra. -/
lemma measurable_shiftInvariant_of_pointwise (g : Î©[Î±] â†’ â„)
    (hmeas : Measurable g) (hinv : âˆ€ Ï‰, g (shift Ï‰) = g Ï‰) :
    Measurable[shiftInvariantSigma] g := by
  classical
  intro s hs
  have hset_meas : MeasurableSet (g â»Â¹' s) := hmeas hs
  have hset_eq : shift â»Â¹' (g â»Â¹' s) = g â»Â¹' s := by
    ext Ï‰; simp [Set.mem_preimage, hinv Ï‰]
  exact (mem_shiftInvariantSigma_iff (g â»Â¹' s)).mpr âŸ¨hset_meas, hset_eqâŸ©

/-- Functions that are `AEStronglyMeasurable` with respect to the invariant Ïƒ-algebra are
almost everywhere fixed by the shift. -/
lemma shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) {f : Î©[Î±] â†’ â„}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼) :
    (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f := by
  classical
  rcases hf with âŸ¨g, hg_meas, hfgâŸ©
  have hcomp :=
    (hÏƒ.quasiMeasurePreserving).ae_eq_comp (Î¼ := Î¼) (Î½ := Î¼)
      (f := shift (Î± := Î±)) (g := fun Ï‰ => f Ï‰) (g' := fun Ï‰ => g Ï‰) hfg
  have hshift : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g :=
    EventuallyEq.of_eq (shiftInvariantSigma_measurable_shift_eq g hg_meas.measurable)
  exact hcomp.trans <| hshift.trans hfg.symm

/-- If an `Lp` function is measurable with respect to the invariant Ïƒ-algebra, the Koopman
operator fixes it. -/
lemma koopman_eq_self_of_shiftInvariant
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    {f : Lp â„ 2 Î¼}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼) :
    koopman shift hÏƒ f = f := by
  classical
  have hcomp :
      (koopman shift hÏƒ f) =áµ[Î¼]
        (fun Ï‰ => f (shift Ï‰)) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Î± := Î±)) hÏƒ f =áµ[Î¼]
        fun Ï‰ => f (shift Ï‰)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving f hÏƒ)
  have hshift := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq (Î¼ := Î¼) hÏƒ hf
  have hfinal : (koopman shift hÏƒ f) =áµ[Î¼] f := hcomp.trans hshift
  exact Lp.ext hfinal

/-- A Koopman-fixed function should be measurable with respect to the invariant Ïƒ-algebra.

The key step is to modify a representative of `f` on a null set so that it becomes
pointwise invariant under the shift; the resulting function will then be
`shiftInvariantSigma`-measurable by construction. -/
lemma aestronglyMeasurable_shiftInvariant_of_koopman
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    {f : Lp â„ 2 Î¼}
    (hfix : koopman shift hÏƒ f = f) :
    AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ := by
  classical
  /-
  Proof strategy sketch:
  1. Unfold the equality `koopman shift hÏƒ f = f` to obtain the almost-everywhere
     identity `(fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f`.
  2. Choose a strongly measurable representative `g` of `f`.
  3. Apply `exists_shiftInvariantRepresentative` to obtain a version `g'` of `g`
     that is literally shift-invariant and measurable with respect to the
     invariant Ïƒ-algebra.
  4. Transport measurability of `g'` back to `f` using the almost everywhere
     equality.

  Implementing steps (3)â€“(5) will likely require a bespoke lemma about
  modifying functions on null sets to enforce invariance; this will be filled in
  later.
  -/
  -- STEP 1. Extract the a.e. invariance statement from `koopman` equality.
  have hcomp : (koopman shift hÏƒ f) =áµ[Î¼] fun Ï‰ => f (shift Ï‰) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Î± := Î±)) hÏƒ f =áµ[Î¼]
        fun Ï‰ => f (shift Ï‰)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving f hÏƒ)
  have hfixAE : (koopman shift hÏƒ f) =áµ[Î¼] f := by
    simp [hfix]
  have hshift : (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f := by
    exact hcomp.symm.trans hfixAE
  -- STEP 2. Choose a strongly measurable representative of `f`.
  have hf_base : AEStronglyMeasurable f Î¼ := by
    exact Lp.aestronglyMeasurable f
  obtain âŸ¨g, hg_meas, hfgâŸ© := hf_base
  -- Transport the a.e. invariance to the chosen representative.
  have hshift_g : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g := by
    have hcomp := (hÏƒ.quasiMeasurePreserving.ae_eq_comp hfg)
    have hcomp' : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] (fun Ï‰ => f (shift Ï‰)) := hcomp.symm
    have hshift' : (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] g := hshift.trans hfg
    exact hcomp'.trans hshift'
  -- STEP 3. Produce a shift-invariant representative and relate it to `f`.
  obtain âŸ¨g', hg'_meas, hAEgg, _âŸ© :=
    exists_shiftInvariantRepresentative (Î¼ := Î¼) hÏƒ g hg_meas.aestronglyMeasurable hshift_g
  have hAEgg' : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g := hAEgg
  have hAEgf : (fun Ï‰ => g' Ï‰) =áµ[Î¼] f := hAEgg'.trans hfg.symm
  have hf_meas : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ :=
    (AEStronglyMeasurable.congr hg'_meas hAEgf)
  exact hf_meas

/-- The fixed-point subspace of the Koopman operator.

This is the closed subspace of LÂ²(Î¼) consisting of equivalence classes of functions
f such that f âˆ˜ shift = f almost everywhere.
-/
def fixedSubspace {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) : Submodule â„ (Lp â„ 2 Î¼) :=
  fixedSpace (koopman shift hÏƒ)

/-- Functions in the fixed-point subspace are exactly those that are a.e. invariant under shift. -/
lemma mem_fixedSubspace_iff {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) (f : Lp â„ 2 Î¼) :
    f âˆˆ fixedSubspace hÏƒ â†” koopman shift hÏƒ f = f := by
  rfl

/-- The orthogonal projection onto the fixed-point subspace exists (as a closed subspace). -/
lemma fixedSubspace_closed {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    IsClosed (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) := by
  classical
  let T := koopman shift hÏƒ
  have hset : (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) =
      (fun f : Lp â„ 2 Î¼ => T f - f) â»Â¹' ({0} : Set (Lp â„ 2 Î¼)) := by
    ext f
    unfold fixedSubspace fixedSpace
    simp [T, LinearMap.mem_eqLocus, sub_eq_zero]
  have hcont : Continuous fun f : Lp â„ 2 Î¼ => T f - f :=
    (T.continuous.sub continuous_id)
  have hclosed : IsClosed ((fun f : Lp â„ 2 Î¼ => T f - f) â»Â¹'
      ({0} : Set (Lp â„ 2 Î¼))) :=
    IsClosed.preimage hcont isClosed_singleton
  simpa [hset]

/-- Placeholder conditional expectation on LÂ².

TODO: Replace with the genuine conditional expectation from mathlib once the
shift-invariant Ïƒ-algebra has the required API. -/
noncomputable def condexpL2 {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] :
    Lp â„ 2 Î¼ â†’L[â„] Lp â„ 2 Î¼ :=
  ContinuousLinearMap.id â„ (Lp â„ 2 Î¼)

/-- Placeholder projection characterization; to be replaced with the true
statement once `condexpL2` is implemented properly. -/
theorem proj_eq_condexp {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    âˆƒ (P : Lp â„ 2 Î¼ â†’L[â„] Lp â„ 2 Î¼),
      (âˆ€ f, f âˆˆ fixedSubspace hÏƒ â†’ P f = f) âˆ§
      (âˆ€ f, P f = condexpL2 (Î¼ := Î¼) f) := by
  refine âŸ¨ContinuousLinearMap.id â„ (Lp â„ 2 Î¼), ?_, ?_âŸ©
  Â· intro f hf; rfl
  Â· intro f; simp [condexpL2]

/-- Placeholder range computation; to be filled in with the actual equality in
a future revision. -/
axiom range_condexp_eq_fixedSubspace {Î¼ : Measure (Î©[Î±])}
    [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    Set.range (condexpL2 (Î¼ := Î¼)) =
    (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼))

end Exchangeability.DeFinetti
