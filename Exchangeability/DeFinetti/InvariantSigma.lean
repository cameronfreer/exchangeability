/-
Copyright (c) 2025 exchangeability contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: exchangeability contributors
-/
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Exchangeability.Ergodic.KoopmanMeanErgodic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2

/-!
# Shift-invariant œÉ-algebra and conditional expectation

This file defines the shift-invariant œÉ-algebra on path space and establishes
the fundamental connection between:
- The fixed-point subspace of the Koopman operator
- The L¬≤ space with respect to the shift-invariant œÉ-algebra
- The conditional expectation onto the shift-invariant œÉ-algebra

## Main definitions

* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The œÉ-algebra of shift-invariant sets.
* `fixedSubspace`: The subspace of L¬≤ functions fixed by the Koopman operator.

## Main results

* `mem_shiftInvariantSigma_iff`: Characterization of membership in the invariant œÉ-algebra.
* `fixedSpace_eq_invMeasurable`: Functions fixed by Koopman are exactly those
  measurable with respect to the shift-invariant œÉ-algebra.
* `proj_eq_condexp`: The orthogonal projection onto the fixed-point subspace equals
  the conditional expectation onto the shift-invariant œÉ-algebra.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant œÉ-algebra is denoted
  ùìò_Œæ in Kallenberg.

-/

noncomputable section

open scoped Classical

namespace Exchangeability.DeFinetti

open MeasureTheory Filter Topology
open Exchangeability.Ergodic

variable {Œ± : Type*} [MeasurableSpace Œ±]

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Œ©[Œ±])) : Prop :=
  MeasurableSet s ‚àß shift ‚Åª¬π' s = s

lemma isShiftInvariant_iff (s : Set (Œ©[Œ±])) :
    isShiftInvariant s ‚Üî MeasurableSet s ‚àß ‚àÄ œâ, shift œâ ‚àà s ‚Üî œâ ‚àà s := by
  constructor
  ¬∑ intro ‚ü®hm, heq‚ü©
    exact ‚ü®hm, fun œâ => by rw [‚Üê Set.mem_preimage, heq]‚ü©
  ¬∑ intro ‚ü®hm, hiff‚ü©
    refine ‚ü®hm, Set.ext fun œâ => ?_‚ü©
    simp [hiff]

/-- The shift-invariant œÉ-algebra: the collection of shift-invariant sets.

For now we define this axiomatically; a full construction would use the œÉ-algebra
generated by shift-invariant sets or the comap construction.
-/
def shiftInvariantSigma : MeasurableSpace (Œ©[Œ±]) where
  MeasurableSet' := fun s => isShiftInvariant (Œ± := Œ±) s
  measurableSet_empty := by
    refine ‚ü®MeasurableSet.empty, ?_‚ü©
    simp
  measurableSet_compl := by
    intro s hs
    obtain ‚ü®hs_meas, hs_eq‚ü© := hs
    refine ‚ü®hs_meas.compl, ?_‚ü©
    simp [Set.preimage_compl, hs_eq]
  measurableSet_iUnion := by
    intro f hf
    refine ‚ü®MeasurableSet.iUnion fun n => (hf n).left, ?_‚ü©
    simp only [Set.preimage_iUnion]
    ext œâ
    simp only [Set.mem_iUnion, Set.mem_preimage]
    constructor
    ¬∑ intro ‚ü®i, hi‚ü©
      use i
      -- hi : shift œâ ‚àà f i
      -- By (hf i), f i is shift-invariant: shift œâ ‚àà f i ‚Üî œâ ‚àà f i
      have := (isShiftInvariant_iff (f i)).1 (hf i)
      exact (this.2 œâ).1 hi
    ¬∑ intro ‚ü®i, hi‚ü©
      use i
      -- hi : œâ ‚àà f i
      -- By (hf i), f i is shift-invariant: shift œâ ‚àà f i ‚Üî œâ ‚àà f i
      have := (isShiftInvariant_iff (f i)).1 (hf i)
      exact (this.2 œâ).2 hi

lemma shiftInvariantSigma_le :
    shiftInvariantSigma ‚â§ (inferInstance : MeasurableSpace (Œ©[Œ±])) := by
  intro s hs
  exact (hs : isShiftInvariant (Œ± := Œ±) s).1

lemma mem_shiftInvariantSigma_iff (s : Set (Œ©[Œ±])) :
    @MeasurableSet _ shiftInvariantSigma s ‚Üî isShiftInvariant (Œ± := Œ±) s :=
  Iff.rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Œ©[Œ±] ‚Üí ‚Ñù)
    (hg : Measurable[shiftInvariantSigma] g) :
    (fun œâ => g (shift œâ)) = g := by
  classical
  ext œâ
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases hlt_or with
  | inl hlt =>
      -- Case `g (shift œâ) < g œâ`
      obtain ‚ü®q, hltq, hqœâ‚ü© := exists_rat_btwn hlt
      have hmeas : MeasurableSet (Set.Iio (q : ‚Ñù)) :=
        (isOpen_Iio : IsOpen (Set.Iio (q : ‚Ñù))).measurableSet
      have hset_eq := (hg hmeas).2
      have h_shift_mem : shift œâ ‚àà g ‚Åª¬π' Set.Iio (q : ‚Ñù) := by
        simpa [Set.mem_preimage] using hltq
      have h_pre : œâ ‚àà shift ‚Åª¬π' (g ‚Åª¬π' Set.Iio (q : ‚Ñù)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : œâ ‚àà g ‚Åª¬π' Set.Iio (q : ‚Ñù) := by
        simpa [hset_eq] using h_pre
      have : g œâ < (q : ‚Ñù) := by
        simpa [Set.mem_preimage] using h_mem
      have : g œâ < g œâ := lt_trans this hqœâ
      exact lt_irrefl _ this
  | inr hgt =>
      -- Case `g œâ < g (shift œâ)`
      obtain ‚ü®q, hœâq, hq_lt‚ü© := exists_rat_btwn hgt
      have hmeas : MeasurableSet (Set.Ioi (q : ‚Ñù)) :=
        (isOpen_Ioi : IsOpen (Set.Ioi (q : ‚Ñù))).measurableSet
      have hset_eq := (hg hmeas).2
      have h_shift_mem : shift œâ ‚àà g ‚Åª¬π' Set.Ioi (q : ‚Ñù) := by
        simpa [Set.mem_preimage] using hq_lt
      have h_pre : œâ ‚àà shift ‚Åª¬π' (g ‚Åª¬π' Set.Ioi (q : ‚Ñù)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : œâ ‚àà g ‚Åª¬π' Set.Ioi (q : ‚Ñù) := by
        simpa [hset_eq] using h_pre
      have : (q : ‚Ñù) < g œâ := by
        simpa [Set.mem_preimage] using h_mem
      have : g œâ < g œâ := lt_trans hœâq this
      exact lt_irrefl _ this

/-- **Auxiliary goal**: construct an invariant representative.

Once `g : Œ©[Œ±] ‚Üí ‚Ñù` is strongly measurable and agrees a.e. with its shift, we expect to
modify it on a null set so that it becomes literally invariant under `shift` while remaining
measurable with respect to `shiftInvariantSigma`.  Filling in this lemma (or a closely related
variant) will let us finish `aestronglyMeasurable_shiftInvariant_of_koopman`. -/
lemma exists_shiftInvariantRepresentative
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    (g : Œ©[Œ±] ‚Üí ‚Ñù)
    (hg : AEStronglyMeasurable g Œº)
    (hinv : (fun œâ => g (shift œâ)) =·µê[Œº] g) :
    ‚àÉ g',
      AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] g' Œº ‚àß
      (‚àÄ·µê œâ ‚àÇŒº, g' œâ = g œâ) ‚àß
      (‚àÄ œâ, g' (shift œâ) = g' œâ) := by
  classical
  rcases hg with ‚ü®g0, hg0_sm, hAEg0‚ü©
  have hcomp :=
    (hœÉ.quasiMeasurePreserving.ae_eq_comp (Œº := Œº) (ŒΩ := Œº)
      (f := shift (Œ± := Œ±)) (g := fun œâ => g œâ) (g' := fun œâ => g0 œâ) hAEg0)
  have hshift0 : (fun œâ => g0 (shift œâ)) =·µê[Œº] g0 :=
    hcomp.trans (hinv.trans hAEg0)
  let S : Set (Œ©[Œ±]) := {œâ | g0 (shift œâ) = g0 œâ}
  have hS_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà S := by
    simpa [S, Set.mem_setOf_eq] using hshift0
  have hS_null : Œº S·∂ú = 0 := by
    simpa [ae_iff, S, Set.mem_setOf_eq] using hS_ae
  let S‚àû : Set (Œ©[Œ±]) := ‚ãÇ n : ‚Ñï, (shift^[n]) ‚Åª¬π' S
  have hSinf_null : Œº S‚àû·∂ú = 0 := by
    have hcompl : S‚àû·∂ú = ‚ãÉ n : ‚Ñï, (shift^[n]) ‚Åª¬π' S·∂ú := by
      classical
      simpa [S‚àû, Set.preimage_compl]
        using (Set.compl_iInter (fun n : ‚Ñï => (shift^[n]) ‚Åª¬π' S))
    have hpreimage_null : ‚àÄ n : ‚Ñï, Œº ((shift^[n]) ‚Åª¬π' S·∂ú) = 0 := by
      intro n
      simpa using ((MeasurePreserving.iterate hœÉ n).preimage_null hS_null)
    simpa [hcompl] using measure_iUnion_null hpreimage_null
  have hSinf_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà S‚àû := by
    simpa [ae_iff, S‚àû] using hSinf_null
  have hSinf_preimage : shift ‚Åª¬π' S‚àû = S‚àû := by
    classical
    ext œâ
    constructor
    ¬∑ intro hœâ
      refine Set.mem_iInter.mpr ?_
      intro n
      have := Set.mem_iInter.mp hœâ (n + 1)
      simpa [Function.iterate_succ] using this
    ¬∑ intro hœâ
      have : shift œâ ‚àà S‚àû := by
        refine Set.mem_iInter.mpr ?_
        intro n
        have := Set.mem_iInter.mp hœâ n
        simpa [Function.iterate_succ, Function.comp] using this
      simpa [Set.mem_preimage] using this
  have hSinf_equiv : ‚àÄ œâ, œâ ‚àà S‚àû ‚Üî shift œâ ‚àà S‚àû := by
    intro œâ
    have hmem := congrArg (fun s => œâ ‚àà s) hSinf_preimage
    simpa [Set.mem_preimage] using hmem
  let g' : Œ©[Œ±] ‚Üí ‚Ñù := fun œâ => if œâ ‚àà S‚àû then g0 œâ else 0
  have g'_def : g' = Set.indicator S‚àû g0 := by
    classical
    funext œâ
    by_cases hœâ : œâ ‚àà S‚àû
    ¬∑ simp [g', hœâ, Set.indicator_of_mem]
    ¬∑ simp [g', hœâ, Set.indicator_of_not_mem]
  have hg'_ae_eq_g0 : (fun œâ => g' œâ) =·µê[Œº] g0 := by
    filter_upwards [hSinf_ae] with œâ hœâ
    simp [g', hœâ]
  have hg'_ae_eq_g : (fun œâ => g' œâ) =·µê[Œº] g :=
    hg'_ae_eq_g0.trans hAEg0
  have hshift_g' : ‚àÄ œâ, g' (shift œâ) = g' œâ := by
    intro œâ
    by_cases hœâ : œâ ‚àà S‚àû
    ¬∑ have hshiftœâ : shift œâ ‚àà S‚àû := (hSinf_equiv œâ).1 hœâ
      have hSœâ : œâ ‚àà S := by
        simpa [S] using Set.mem_iInter.mp hœâ 0
      simp [g', hœâ, hshiftœâ, S, hSœâ]
    ¬∑ have hshiftœâ : shift œâ ‚àâ S‚àû := by
        exact (not_congr (hSinf_equiv œâ)).1 hœâ
      simp [g', hœâ, hshiftœâ]
  -- measurability of the invariant representative
  refine ‚ü®g', ?_, hg'_ae_eq_g, hshift_g'‚ü©
  ¬∑ -- `g'` is measurable with respect to the invariant œÉ-algebra
    have hshift_meas : Measurable fun œâ => g0 (shift œâ) :=
      hg0_sm.measurable.comp measurable_shift
    have hS_meas : MeasurableSet S := by
      classical
      have hdiff_meas : Measurable fun œâ => g0 (shift œâ) - g0 œâ :=
        hshift_meas.sub hg0_sm.measurable
      have hset_eq : S = (fun œâ => g0 (shift œâ) - g0 œâ) ‚Åª¬π' {0} := by
        ext œâ; simp [S]
      simpa [hset_eq] using hdiff_meas measurableSet_singleton
    have hshift_iter_meas : ‚àÄ n : ‚Ñï, Measurable fun œâ => shift^[n] œâ := by
      intro n
      induction' n with n ih
      ¬∑ simpa using measurable_id
      ¬∑ simpa [Function.iterate_succ, Function.comp] using measurable_shift.comp ih
    have hSinf_meas : MeasurableSet S‚àû := by
      classical
      refine MeasurableSet.iInter fun n => ?_
      simpa [S‚àû] using (hshift_iter_meas n) hS_meas
    have hg0_meas : Measurable g0 := hg0_sm.measurable
    have hg'_meas : Measurable g' := by
      classical
      simpa [g'_def] using hg0_meas.indicator hSinf_meas
    have hg'_meas_shift : Measurable[shiftInvariantSigma] g' := by
      classical
      intro t ht
      have hset_meas : MeasurableSet (g' ‚Åª¬π' t) := hg'_meas ht
      have hset_inv : shift ‚Åª¬π' (g' ‚Åª¬π' t) = g' ‚Åª¬π' t := by
        ext œâ; simp [Set.mem_preimage, hshift_g']
      exact (mem_shiftInvariantSigma_iff (g' ‚Åª¬π' t)).mpr ‚ü®hset_meas, hset_inv‚ü©
    exact hg'_meas_shift.aestronglyMeasurable

/-- A pointwise shift-invariant function that is ambient-measurable is measurable with
respect to the shift-invariant œÉ-algebra. -/
lemma measurable_shiftInvariant_of_pointwise (g : Œ©[Œ±] ‚Üí ‚Ñù)
    (hmeas : Measurable g) (hinv : ‚àÄ œâ, g (shift œâ) = g œâ) :
    Measurable[shiftInvariantSigma] g := by
  classical
  intro s hs
  have hset_meas : MeasurableSet (g ‚Åª¬π' s) := hmeas hs
  have hset_eq : shift ‚Åª¬π' (g ‚Åª¬π' s) = g ‚Åª¬π' s := by
    ext œâ; simp [Set.mem_preimage, hinv œâ]
  exact (mem_shiftInvariantSigma_iff (g ‚Åª¬π' s)).mpr ‚ü®hset_meas, hset_eq‚ü©

/-- Functions that are `AEStronglyMeasurable` with respect to the invariant œÉ-algebra are
almost everywhere fixed by the shift. -/
lemma shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) {f : Œ©[Œ±] ‚Üí ‚Ñù}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº) :
    (fun œâ => f (shift œâ)) =·µê[Œº] f := by
  classical
  rcases hf with ‚ü®g, hg_meas, hfg‚ü©
  have hcomp :=
    (hœÉ.quasiMeasurePreserving).ae_eq_comp (Œº := Œº) (ŒΩ := Œº)
      (f := shift (Œ± := Œ±)) (g := fun œâ => f œâ) (g' := fun œâ => g œâ) hfg
  have hshift : (fun œâ => g (shift œâ)) =·µê[Œº] g :=
    EventuallyEq.of_eq (shiftInvariantSigma_measurable_shift_eq g hg_meas.measurable)
  exact hcomp.trans <| hshift.trans hfg.symm

/-- If an `Lp` function is measurable with respect to the invariant œÉ-algebra, the Koopman
operator fixes it. -/
lemma koopman_eq_self_of_shiftInvariant
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f : Lp ‚Ñù 2 Œº}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº) :
    koopman shift hœÉ f = f := by
  classical
  have hcomp :
      (koopman shift hœÉ f) =·µê[Œº]
        (fun œâ => f (shift œâ)) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Œ± := Œ±)) hœÉ f =·µê[Œº]
        fun œâ => f (shift œâ)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving (Œº := Œº) (Œºb := Œº)
            (p := (2 : ‚Ñù‚â•0‚àû)) f hœÉ)
  have hshift := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq (Œº := Œº) hœÉ hf
  have hfinal : (koopman shift hœÉ f) =·µê[Œº] f := hcomp.trans hshift
  exact Lp.ext hfinal

/-- A Koopman-fixed function should be measurable with respect to the invariant œÉ-algebra.

The key step is to modify a representative of `f` on a null set so that it becomes
pointwise invariant under the shift; the resulting function will then be
`shiftInvariantSigma`-measurable by construction. -/
lemma aestronglyMeasurable_shiftInvariant_of_koopman
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f : Lp ‚Ñù 2 Œº}
    (hfix : koopman shift hœÉ f = f) :
    AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº := by
  classical
  /-
  Proof strategy sketch:
  1. Unfold the equality `koopman shift hœÉ f = f` to obtain the almost-everywhere
     identity `(fun œâ => f (shift œâ)) =·µê[Œº] f`.
  2. Choose a strongly measurable representative `g` of `f`.
  3. Apply `exists_shiftInvariantRepresentative` to obtain a version `g'` of `g`
     that is literally shift-invariant and measurable with respect to the
     invariant œÉ-algebra.
  4. Transport measurability of `g'` back to `f` using the almost everywhere
     equality.

  Implementing steps (3)‚Äì(5) will likely require a bespoke lemma about
  modifying functions on null sets to enforce invariance; this will be filled in
  later.
  -/
  -- STEP 1. Extract the a.e. invariance statement from `koopman` equality.
  have hshift : (fun œâ => f (shift œâ)) =·µê[Œº] f := by
    have := congrArg (fun g : Lp ‚Ñù 2 Œº => g) hfix
    exact this
  -- STEP 2. Choose a strongly measurable representative of `f`.
  have hf_base : AEStronglyMeasurable f Œº := by
    simpa using (Lp.aestronglyMeasurable (Œº := Œº) (p := (2 : ‚Ñù‚â•0‚àû)) f)
  obtain ‚ü®g, hg_meas, hfg‚ü© := hf_base
  -- Transport the a.e. invariance to the chosen representative.
  have hshift_g : (fun œâ => g (shift œâ)) =·µê[Œº] g := by
    have hcomp := (hœÉ.quasiMeasurePreserving.ae_eq_comp hfg)
    have hcomp' : (fun œâ => g (shift œâ)) =·µê[Œº] (fun œâ => f (shift œâ)) := by
      simpa using hcomp
    have hshift' : (fun œâ => f (shift œâ)) =·µê[Œº] g := hshift.trans hfg
    exact hcomp'.trans hshift'
  -- STEP 3. Produce a shift-invariant representative and relate it to `f`.
  obtain ‚ü®g', hg'_meas, hAEgg, _‚ü© :=
    exists_shiftInvariantRepresentative (Œº := Œº) hœÉ g hg_meas hshift_g
  have hAEgg' : (fun œâ => g' œâ) =·µê[Œº] g := hAEgg
  have hAEgf : (fun œâ => g' œâ) =·µê[Œº] f := hAEgg'.trans hfg
  have hf_meas : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº :=
    (AEStronglyMeasurable.congr hg'_meas hAEgf)
  exact hf_meas

/-- The fixed-point subspace of the Koopman operator.

This is the closed subspace of L¬≤(Œº) consisting of equivalence classes of functions
f such that f ‚àò shift = f almost everywhere.
-/
def fixedSubspace {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) : Submodule ‚Ñù (Lp ‚Ñù 2 Œº) :=
  fixedSpace (koopman shift hœÉ)

/-- Functions in the fixed-point subspace are exactly those that are a.e. invariant under shift. -/
lemma mem_fixedSubspace_iff {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) (f : Lp ‚Ñù 2 Œº) :
    f ‚àà fixedSubspace hœÉ ‚Üî koopman shift hœÉ f = f := by
  rfl

/-- The orthogonal projection onto the fixed-point subspace exists (as a closed subspace). -/
lemma fixedSubspace_closed {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    IsClosed (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  let T := koopman shift hœÉ
  have hset : (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) =
      (fun f : Lp ‚Ñù 2 Œº => T f - f) ‚Åª¬π' ({0} : Set (Lp ‚Ñù 2 Œº)) := by
    ext f
    rfl
  have hcont : Continuous fun f : Lp ‚Ñù 2 Œº => T f - f :=
    (T.continuous.sub continuous_id)
  have hclosed : IsClosed ((fun f : Lp ‚Ñù 2 Œº => T f - f) ‚Åª¬π'
      ({0} : Set (Lp ‚Ñù 2 Œº))) :=
    IsClosed.preimage hcont isClosed_singleton
  simpa [hset]

/-- Conditional expectation on L¬≤ can be viewed as an orthogonal projection.

For a sub-œÉ-algebra ùìñ, the conditional expectation condexp[ùìñ] is the orthogonal
projection from L¬≤(Œº) onto L¬≤(ùìñ), the closed subspace of functions measurable
with respect to ùìñ.

TODO: Use mathlib's condexpL2 once we have the proper sub-œÉ-algebra instance.
-/
noncomputable def condexpL2 {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº] :
    Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº :=
  ((lpMeas ‚Ñù ‚Ñù (shiftInvariantSigma (Œ± := Œ±)) 2 Œº).subtypeL).comp
    (MeasureTheory.condExpL2 ‚Ñù ‚Ñù (shiftInvariantSigma_le (Œ± := Œ±)))

/-- Key theorem: The orthogonal projection onto the fixed-point subspace of the Koopman
operator equals the conditional expectation onto the shift-invariant œÉ-algebra.

This is the bridge between ergodic theory (operator fixed points) and probability
(conditional expectation).
-/
theorem proj_eq_condexp {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    ‚àÉ (P : Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº),
      (‚àÄ f, f ‚àà fixedSubspace hœÉ ‚Üí P f = f) ‚àß
      (‚àÄ f, P f = condexpL2 (Œº := Œº) f) := by
  refine ‚ü®condexpL2 (Œº := Œº), ?_, ?_‚ü©
  ¬∑ intro f hf
    have hfix : koopman shift hœÉ f = f :=
      (mem_fixedSubspace_iff (hœÉ := hœÉ) (f := f)).1 hf
    have hmeas : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº :=
      aestronglyMeasurable_shiftInvariant_of_koopman (hœÉ := hœÉ) hfix
    have hf_mem : f ‚àà lpMeas ‚Ñù ‚Ñù (shiftInvariantSigma (Œ± := Œ±)) 2 Œº := by
      exact (MeasureTheory.mem_lpMeas_iff_aestronglyMeasurable (m := shiftInvariantSigma)
        (m0 := inferInstance) (Œº := Œº) (p := (2 : ‚Ñù‚â•0‚àû)) (f := f)).mpr hmeas
    let fSub : lpMeas ‚Ñù ‚Ñù (shiftInvariantSigma (Œ± := Œ±)) 2 Œº := ‚ü®f, hf_mem‚ü©
    have hproj :
        MeasureTheory.condExpL2 ‚Ñù ‚Ñù (shiftInvariantSigma_le (Œ± := Œ±)) f = fSub := by
      simpa [MeasureTheory.condExpL2, fSub]
        using Submodule.orthogonalProjection_mem_subspace_eq_self fSub
    unfold condexpL2
    simpa [fSub, hproj]
  ¬∑ intro f; rfl

/-- The range of conditional expectation onto the invariant œÉ-algebra equals
the fixed-point subspace. -/
lemma range_condexp_eq_fixedSubspace {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    Set.range (condexpL2 (Œº := Œº)) =
    (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  ext f
  constructor
  ¬∑ -- (‚äÜ) Range of condexpL2 ‚äÜ fixedSubspace
    intro ‚ü®g, hg‚ü©
    rw [‚Üê hg]
    -- condexpL2 g is measurable w.r.t. shiftInvariantSigma
    -- hence invariant under shift, so Koopman fixes it
    classical
    have hmeas :
        AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)]
          (condexpL2 (Œº := Œº) g : Œ©[Œ±] ‚Üí ‚Ñù) Œº := by
      simpa using
        (lpMeas.aestronglyMeasurable
          (MeasureTheory.condExpL2 ‚Ñù ‚Ñù (shiftInvariantSigma_le (Œ± := Œ±)) g))
    have hkoop :=
      koopman_eq_self_of_shiftInvariant (hœÉ := hœÉ) hmeas
    exact (mem_fixedSubspace_iff (hœÉ := hœÉ)
        (f := condexpL2 (Œº := Œº) g)).mpr hkoop
  ¬∑ -- (‚äá) fixedSubspace ‚äÜ Range of condexpL2
    intro hf
    -- If f is fixed by Koopman, then f is shift-invariant a.e.
    -- hence measurable w.r.t. shiftInvariantSigma
    -- so f = condexpL2 f
    use f
    have hfix : koopman shift hœÉ f = f :=
      (mem_fixedSubspace_iff (hœÉ := hœÉ) (f := f)).1 hf
    have hmeas : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº :=
      aestronglyMeasurable_shiftInvariant_of_koopman (hœÉ := hœÉ) hfix
    have hf_mem : f ‚àà lpMeas ‚Ñù ‚Ñù (shiftInvariantSigma (Œ± := Œ±)) 2 Œº :=
      (MeasureTheory.mem_lpMeas_iff_aestronglyMeasurable (m := shiftInvariantSigma)
        (m0 := inferInstance) (Œº := Œº) (p := (2 : ‚Ñù‚â•0‚àû)) (f := f)).mpr hmeas
    let fSub : lpMeas ‚Ñù ‚Ñù (shiftInvariantSigma (Œ± := Œ±)) 2 Œº := ‚ü®f, hf_mem‚ü©
    have hproj :
        MeasureTheory.condExpL2 ‚Ñù ‚Ñù (shiftInvariantSigma_le (Œ± := Œ±)) f = fSub := by
      simpa [MeasureTheory.condExpL2, fSub]
        using Submodule.orthogonalProjection_mem_subspace_eq_self fSub
    unfold condexpL2
    simp [fSub, hproj]

end Exchangeability.DeFinetti
