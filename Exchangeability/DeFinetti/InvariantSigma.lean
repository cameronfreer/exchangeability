/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.Data.EReal.Basic
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Exchangeability.Ergodic.KoopmanMeanErgodic
import Exchangeability.DeFinetti.ProjectionLemmas
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2

/-!
# Shift-invariant œÉ-algebra and conditional expectation

This file defines the shift-invariant œÉ-algebra on path space and establishes
the fundamental connection between:
- The fixed-point subspace of the Koopman operator
- The L¬≤ space with respect to the shift-invariant œÉ-algebra
- The conditional expectation onto the shift-invariant œÉ-algebra

## Main definitions

* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The œÉ-algebra of shift-invariant sets.
* `fixedSubspace`: The subspace of L¬≤ functions fixed by the Koopman operator.

## Main results

* `mem_shiftInvariantSigma_iff`: Characterization of membership in the invariant œÉ-algebra.
* `fixedSpace_eq_invMeasurable`: Functions fixed by Koopman are exactly those
  measurable with respect to the shift-invariant œÉ-algebra.
* `proj_eq_condexp`: The orthogonal projection onto the fixed-point subspace equals
  the conditional expectation onto the shift-invariant œÉ-algebra.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant œÉ-algebra is denoted
  ùìò_Œæ in Kallenberg.
* FMP 10.4: Invariant sets and functions (Chapter 10, pages 180-181).
  Key results used in the first proof.

## FMP 10.4: Invariant Sets and Functions

For a measure-preserving transformation T on (S, ùíÆ, Œº):

**Definitions**:
- A set I ‚àà ùíÆ is **invariant** if I = T‚Åª¬πI
- A set I is **almost invariant** if Œº(I Œî T‚Åª¬πI) = 0
- ùìò = invariant œÉ-field (invariant sets in ùíÆ)
- ùìò' = almost invariant œÉ-field (almost invariant sets in ùíÆ^Œº)
- A function f is **invariant** if f = f ‚àò T
- A function f is **almost invariant** if f = f ‚àò T a.s. Œº

**Lemma 1 (invariant sets and functions)**:
A measurable function f: S ‚Üí S' (Borel space) is invariant/almost invariant
iff it is ùìò-measurable/ùìò^Œº-measurable, respectively.

**Lemma 2 (almost invariance)**:
For any distribution Œº and Œº-preserving transformation T,
the invariant and almost invariant œÉ-fields satisfy: ùìò' = ùìò^Œº
(almost invariant = completion of invariant).

**Lemma 3 (ergodicity)**:
Let Œæ be a random element in S with distribution Œº, and T a Œº-preserving map on S.
Then Œæ is T-ergodic iff the sequence (T^n Œæ) is Œ∏-ergodic, in which case
even Œ∑ = (f ‚àò T^n Œæ) is Œ∏-ergodic for every measurable f: S ‚Üí S'.

-/

noncomputable section

open scoped Classical Topology

namespace Exchangeability.DeFinetti

open MeasureTheory Filter Topology
open Exchangeability.Ergodic

variable {Œ± : Type*} [MeasurableSpace Œ±]

/-- The tail œÉ-algebra generated by the iterates of the left shift on path space. -/
def tailSigma : MeasurableSpace (Œ©[Œ±]) :=
  ‚®Ö n : ‚Ñï, MeasurableSpace.comap (fun œâ => (shift^[n]) œâ) inferInstance

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Œ©[Œ±])) : Prop :=
  MeasurableSet s ‚àß shift ‚Åª¬π' s = s

lemma isShiftInvariant_iff {s : Set (Œ©[Œ±])} :
    isShiftInvariant s ‚Üî MeasurableSet s ‚àß ‚àÄ œâ, shift œâ ‚àà s ‚Üî œâ ‚àà s := by
  constructor
  ¬∑ intro ‚ü®hm, heq‚ü©
    exact ‚ü®hm, fun œâ => by rw [‚Üê Set.mem_preimage, heq]‚ü©
  ¬∑ intro ‚ü®hm, hiff‚ü©
    refine ‚ü®hm, Set.ext fun œâ => ?_‚ü©
    simp [hiff]

/-- The shift-invariant œÉ-algebra: the collection of shift-invariant sets.

For now we define this axiomatically; a full construction would use the œÉ-algebra
generated by shift-invariant sets or the comap construction.
-/
def shiftInvariantSigma : MeasurableSpace (Œ©[Œ±]) where
  MeasurableSet' := fun s => isShiftInvariant (Œ± := Œ±) s
  measurableSet_empty := by
    refine ‚ü®MeasurableSet.empty, ?_‚ü©
    simp
  measurableSet_compl := by
    intro s hs
    obtain ‚ü®hs_meas, hs_eq‚ü© := hs
    refine ‚ü®hs_meas.compl, ?_‚ü©
    simp [Set.preimage_compl, hs_eq]
  measurableSet_iUnion := by
    intro f hf
    refine ‚ü®MeasurableSet.iUnion fun n => (hf n).1, ?_‚ü©
    simp only [Set.preimage_iUnion]
    ext œâ
    simp only [Set.mem_iUnion, Set.mem_preimage]
    constructor
    ¬∑ intro ‚ü®i, hi‚ü©
      use i
      -- hi : shift œâ ‚àà f i
      -- By (hf i), f i is shift-invariant: shift œâ ‚àà f i ‚Üî œâ ‚àà f i
<<<<<<< HEAD
      have := isShiftInvariant_iff.1 (hf i)
=======
      have : isShiftInvariant (Œ± := Œ±) (f i) := (hf i)
      have := (isShiftInvariant_iff (Œ± := Œ±) (s := f i)).1 this
>>>>>>> 4e8f38e93f9f062dccf1119d5ffdf54126d2081e
      exact (this.2 œâ).1 hi
    ¬∑ intro ‚ü®i, hi‚ü©
      use i
      -- hi : œâ ‚àà f i
      -- By (hf i), f i is shift-invariant: shift œâ ‚àà f i ‚Üî œâ ‚àà f i
<<<<<<< HEAD
      have := isShiftInvariant_iff.1 (hf i)
=======
      have : isShiftInvariant (Œ± := Œ±) (f i) := (hf i)
      have := (isShiftInvariant_iff (Œ± := Œ±) (s := f i)).1 this
>>>>>>> 4e8f38e93f9f062dccf1119d5ffdf54126d2081e
      exact (this.2 œâ).2 hi

lemma shiftInvariantSigma_le :
    shiftInvariantSigma ‚â§ (inferInstance : MeasurableSpace (Œ©[Œ±])) := by
  intro s hs
  exact hs.1

lemma mem_shiftInvariantSigma_iff {s : Set (Œ©[Œ±])} :
    @MeasurableSet _ shiftInvariantSigma s ‚Üî isShiftInvariant (Œ± := Œ±) s := by
  rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Œ©[Œ±] ‚Üí ‚Ñù)
    (hg : Measurable[shiftInvariantSigma] g) :
    (fun œâ => g (shift œâ)) = g := by
  classical
  ext œâ
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases hlt_or with
  | inl hlt =>
      -- Case `g (shift œâ) < g œâ`
      obtain ‚ü®q, hltq, hqœâ‚ü© := exists_rat_btwn hlt
      have hmeas : MeasurableSet (Set.Iio (q : ‚Ñù)) :=
        (isOpen_Iio : IsOpen (Set.Iio (q : ‚Ñù))).measurableSet
<<<<<<< HEAD
      have hset_eq := (hg hmeas : isShiftInvariant (g ‚Åª¬π' Set.Iio ‚Üëq)).2
=======
      have hset : isShiftInvariant (Œ± := Œ±) (g ‚Åª¬π' Set.Iio (q : ‚Ñù)) := hg hmeas
      have hset_eq := hset.2
>>>>>>> 4e8f38e93f9f062dccf1119d5ffdf54126d2081e
      have h_shift_mem : shift œâ ‚àà g ‚Åª¬π' Set.Iio (q : ‚Ñù) := by
        simpa [Set.mem_preimage] using hltq
      have h_pre : œâ ‚àà shift ‚Åª¬π' (g ‚Åª¬π' Set.Iio (q : ‚Ñù)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : œâ ‚àà g ‚Åª¬π' Set.Iio (q : ‚Ñù) := by
        simpa [hset_eq] using h_pre
      have : g œâ < (q : ‚Ñù) := by
        simpa [Set.mem_preimage] using h_mem
      have : g œâ < g œâ := lt_trans this hqœâ
      exact lt_irrefl _ this
  | inr hgt =>
      -- Case `g œâ < g (shift œâ)`
      obtain ‚ü®q, hœâq, hq_lt‚ü© := exists_rat_btwn hgt
      have hmeas : MeasurableSet (Set.Ioi (q : ‚Ñù)) :=
        (isOpen_Ioi : IsOpen (Set.Ioi (q : ‚Ñù))).measurableSet
<<<<<<< HEAD
      have hset_eq := (hg hmeas : isShiftInvariant (g ‚Åª¬π' Set.Ioi ‚Üëq)).2
=======
      have hset : isShiftInvariant (Œ± := Œ±) (g ‚Åª¬π' Set.Ioi (q : ‚Ñù)) := hg hmeas
      have hset_eq := hset.2
>>>>>>> 4e8f38e93f9f062dccf1119d5ffdf54126d2081e
      have h_shift_mem : shift œâ ‚àà g ‚Åª¬π' Set.Ioi (q : ‚Ñù) := by
        simpa [Set.mem_preimage] using hq_lt
      have h_pre : œâ ‚àà shift ‚Åª¬π' (g ‚Åª¬π' Set.Ioi (q : ‚Ñù)) := by
        simpa [Set.mem_preimage] using h_shift_mem
      have h_mem : œâ ‚àà g ‚Åª¬π' Set.Ioi (q : ‚Ñù) := by
        simpa [hset_eq] using h_pre
      have : (q : ‚Ñù) < g œâ := by
        simpa [Set.mem_preimage] using h_mem
      have : g œâ < g œâ := lt_trans hœâq this
      exact lt_irrefl _ this

-- Helper: Measurability of iterated shifts follows from measurability of `shift`.
private lemma shift_iterate_measurable (n : ‚Ñï) :
    Measurable (shift^[n] : Œ©[Œ±] ‚Üí Œ©[Œ±]) := by
  simpa using measurable_shift.iterate n

/-- A function that is pointwise shift-invariant and measurable is
    measurable with respect to the shift-invariant œÉ-algebra. -/
private lemma shiftInvariant_implies_shiftInvariantMeasurable
    (g : Œ©[Œ±] ‚Üí ‚Ñù) (hg : Measurable g)
    (hinv : ‚àÄ œâ, g (shift œâ) = g œâ) :
    Measurable[shiftInvariantSigma] g := by
  intro t ht
  have hpreimage : MeasurableSet (g ‚Åª¬π' t) := hg ht
  have hinv_preimage : shift ‚Åª¬π' (g ‚Åª¬π' t) = g ‚Åª¬π' t := by
    ext œâ
    simp [Set.mem_preimage, hinv œâ]
  exact (mem_shiftInvariantSigma_iff (s:=g ‚Åª¬π' t)).mpr ‚ü®hpreimage, hinv_preimage‚ü©

-- Tail limsup construction for pointwise invariant representatives.
section LimsupConstruction

/-- EReal limsup along the shift orbit. -/
private def gLimsupE (g0 : Œ©[Œ±] ‚Üí ‚Ñù) (œâ : Œ©[Œ±]) : EReal :=
  limsup (fun n : ‚Ñï => (g0 (shift^[n] œâ) : EReal)) atTop

/-- The shift-invariant representative (pulled back to `‚Ñù` via `toReal`). -/
def gRep (g0 : Œ©[Œ±] ‚Üí ‚Ñù) : Œ©[Œ±] ‚Üí ‚Ñù :=
  fun œâ => (gLimsupE g0 œâ).toReal


lemma gRep_measurable {g0 : Œ©[Œ±] ‚Üí ‚Ñù} (hg0 : Measurable g0) :
    Measurable (gRep g0) := by
  have hstep : ‚àÄ n : ‚Ñï, Measurable fun œâ => (g0 (shift^[n] œâ) : EReal) := by
    intro n
    have hreal : Measurable fun œâ => g0 (shift^[n] œâ) :=
      hg0.comp (shift_iterate_measurable (Œ± := Œ±) n)
    exact measurable_coe_real_ereal.comp hreal
  have h_meas_ereal : Measurable fun œâ => gLimsupE g0 œâ := by
    simpa [gLimsupE] using (Measurable.limsup hstep)
  simpa [gRep, gLimsupE] using measurable_ereal_toReal.comp h_meas_ereal

set_option linter.unusedSectionVars false in
lemma gRep_shiftInvariant {g0 : Œ©[Œ±] ‚Üí ‚Ñù} :
    ‚àÄ œâ, gRep g0 (shift œâ) = gRep g0 œâ := by
  intro œâ
  have hlimsupEq :
      limsup (fun n : ‚Ñï => (g0 (shift^[n + 1] œâ) : EReal)) atTop
        = limsup (fun n : ‚Ñï => (g0 (shift^[n] œâ) : EReal)) atTop := by
    simpa [Function.iterate_succ_apply, Nat.succ_eq_add_one]
      using (limsup_nat_add (fun n => (g0 (shift^[n] œâ) : EReal)) 1)
  simpa [gRep, gLimsupE, Function.iterate_succ_apply, Nat.succ_eq_add_one]
    using congrArg EReal.toReal hlimsupEq

set_option linter.unusedSectionVars false in
lemma gRep_eq_of_constant_orbit {g0 : Œ©[Œ±] ‚Üí ‚Ñù} {œâ : Œ©[Œ±]}
    (hconst : ‚àÄ n : ‚Ñï, g0 (shift^[n] œâ) = g0 œâ) :
    gRep g0 œâ = g0 œâ := by
  have hlim :
      limsup (fun n : ‚Ñï => (g0 (shift^[n] œâ) : EReal)) atTop
        = (g0 œâ : EReal) := by
    have hfunext :
        (fun n : ‚Ñï => (g0 (shift^[n] œâ) : EReal))
          = fun _ => (g0 œâ : EReal) := by
      funext n; simpa using congrArg (fun y : ‚Ñù => (y : EReal)) (hconst n)
    simpa [hfunext] using (limsup_const (f := atTop) (a := (g0 œâ : EReal)))
  simpa [gRep, gLimsupE] using congrArg EReal.toReal hlim

lemma gRep_ae_eq_of_constant_orbit {g0 : Œ©[Œ±] ‚Üí ‚Ñù}
    {Œº : Measure (Œ©[Œ±])}
    (hconst : ‚àÄ·µê œâ ‚àÇŒº, ‚àÄ n : ‚Ñï, g0 (shift^[n] œâ) = g0 œâ) :
    gRep g0 =·µê[Œº] g0 := by
  classical
  filter_upwards [hconst] with œâ hœâ
  exact gRep_eq_of_constant_orbit (g0 := g0) hœâ


lemma ae_shift_invariance_on_rep
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f g : Œ©[Œ±] ‚Üí ‚Ñù}
    (hfg : g =·µê[Œº] f)
    (hshift : (fun œâ => f (shift œâ)) =·µê[Œº] f) :
    (fun œâ => g (shift œâ)) =·µê[Œº] g := by
  classical
  have h1 : (fun œâ => g (shift œâ)) =·µê[Œº] fun œâ => f (shift œâ) := by
    simpa [Function.comp] using
      (hœÉ.quasiMeasurePreserving.ae_eq_comp (Œº := Œº) (ŒΩ := Œº)
        (f := shift) (g := g) (g' := f) hfg)
  have h2 : (fun œâ => f (shift œâ)) =·µê[Œº] f := by
    simpa [Function.comp] using hshift
  have h3 : f =·µê[Œº] g := hfg.symm
  exact h1.trans (h2.trans h3)

<<<<<<< HEAD
lemma mkShiftInvariantRep
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    (g : Œ©[Œ±] ‚Üí ‚Ñù) (hg : AEStronglyMeasurable g Œº)
    (hshift : (fun œâ => g (shift œâ)) =·µê[Œº] g) :
    ‚àÉ g',
      AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] g' Œº ‚àß
      (‚àÄ·µê œâ ‚àÇŒº, g' œâ = g œâ) ‚àß
      (‚àÄ œâ, g' (shift œâ) = g' œâ) := by
  classical
  obtain ‚ü®g0, hg0_sm, hg0_ae‚ü© := hg
  have hshift_g0 : (fun œâ => g0 (shift œâ)) =·µê[Œº] g0 :=
    ae_shift_invariance_on_rep (Œº := Œº) hœÉ hg0_ae hshift
  have hg0_meas : Measurable g0 := hg0_sm.measurable
  obtain ‚ü®S, hS_meas, _hSymm, hS_null, hS_subset, hS_point‚ü© :=
    exists_shiftInvariantFullMeasureSet (Œº := Œº) hœÉ g0 hg0_meas hshift_g0
  have hforward : ‚àÄ œâ ‚àà S, shift œâ ‚àà S := by
    intro œâ hœâ
    have : œâ ‚àà shift ‚Åª¬π' S := hS_subset hœâ
    simpa [Set.mem_preimage] using this
  have hS_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà S := by
    simpa [ae_iff] using hS_null
  have hconst_on_S : ‚àÄ œâ ‚àà S, ‚àÄ n : ‚Ñï, g0 (shift^[n] œâ) = g0 œâ := by
    intro œâ hœâ
    have hmem : ‚àÄ n : ‚Ñï, shift^[n] œâ ‚àà S := by
      refine Nat.rec (by simpa [Function.iterate_zero_apply] using hœâ) ?_
      intro n hn
      have hnext : shift (shift^[n] œâ) ‚àà S := hforward _ hn
      simpa [Function.iterate_succ_apply] using hnext
    refine Nat.rec (by simpa [Function.iterate_zero_apply]) ?_
    intro n ih
    have hstep : g0 (shift^[n.succ] œâ) = g0 (shift^[n] œâ) := by
      have := hS_point (shift^[n] œâ) (hmem n)
      simpa [Function.iterate_succ_apply] using this
    exact hstep.trans ih
  have hconst : ‚àÄ·µê œâ ‚àÇŒº, ‚àÄ n : ‚Ñï, g0 (shift^[n] œâ) = g0 œâ := by
    filter_upwards [hS_ae] with œâ hœâ using hconst_on_S œâ hœâ
  let g' := gRep g0
  have hg'_meas : Measurable g' := gRep_measurable g0 hg0_meas
  have hg'_ae_g0 : g' =·µê[Œº] g0 := gRep_ae_eq_of_constant_orbit (g0 := g0) hconst
  have hg'_inv : ‚àÄ œâ, g' (shift œâ) = g' œâ := gRep_shiftInvariant g0
  have hg'_tail : Measurable[shiftInvariantSigma (Œ± := Œ±)] g' :=
    shiftInvariant_implies_shiftInvariantMeasurable g' hg'_meas hg'_inv
  refine ‚ü®g', hg'_tail.aestronglyMeasurable, ?_, hg'_inv‚ü©
  exact hg'_ae_g0.trans hg0_ae

=======
>>>>>>> 4e8f38e93f9f062dccf1119d5ffdf54126d2081e
end LimsupConstruction

-- **Auxiliary goal**: construct an invariant representative.
-- Helper lemmas to replace exists_shiftInvariantRepresentative

/-- Build a shift-invariant full-measure set on which `g ‚àò shift = g` holds pointwise,
    *without* appealing to additional axioms. The construction iterates the
    equality set and intersects all pullbacks to obtain a forward-invariant set
    on which the equality holds everywhere. -/
private lemma exists_shiftInvariantFullMeasureSet
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    (g : Œ©[Œ±] ‚Üí ‚Ñù) (hg : Measurable g)
    (hinv : (fun œâ => g (shift œâ)) =·µê[Œº] g) :
    ‚àÉ Sinf : Set (Œ©[Œ±]),
      MeasurableSet Sinf ‚àß
      Œº (symmDiff (shift ‚Åª¬π' Sinf) Sinf) = 0 ‚àß
      Œº Sinf·∂ú = 0 ‚àß
      Sinf ‚äÜ shift ‚Åª¬π' Sinf ‚àß
      ‚àÄ œâ ‚àà Sinf, g (shift œâ) = g œâ := by
  classical
  -- Build the basic equality set where the orbit agrees pointwise.
  set S0 : Set (Œ©[Œ±]) := {œâ | g (shift œâ) = g œâ} with hS0_def

  -- This set is measurable because it arises as the `{0}`-preimage of a measurable function.
  have hS0_meas : MeasurableSet S0 := by
    have hdiff : Measurable fun œâ => g (shift œâ) - g œâ :=
      (hg.comp measurable_shift).sub hg
    have hsingleton : MeasurableSet ({0} : Set ‚Ñù) := by
      simp
    have :
        MeasurableSet ((fun œâ => g (shift œâ) - g œâ) ‚Åª¬π' ({0} : Set ‚Ñù)) :=
      hdiff hsingleton
    simpa [S0, Set.preimage, Set.mem_setOf_eq, Set.mem_singleton_iff, sub_eq_zero] using this

  -- `S0` has full measure thanks to the `ae` equality.
  have hS0_full : Œº S0·∂ú = 0 := by
    have hS0_ae : ‚àÄ·µê œâ ‚àÇŒº, g (shift œâ) = g œâ := hinv
    simpa [S0, ae_iff] using hS0_ae

  -- All forward preimages of `S0` also have full measure via measure-preservation.
  have hpre_full : ‚àÄ n : ‚Ñï, Œº (((shift^[n]) ‚Åª¬π' S0)·∂ú) = 0 := by
    intro n
    have hœÉn : MeasurePreserving (shift^[n]) Œº Œº := hœÉ.iterate n
    have hpre : Œº ((shift^[n]) ‚Åª¬π' S0·∂ú) = Œº S0·∂ú := by
      rw [hœÉn.measure_preimage hS0_meas.compl.nullMeasurableSet]
    simpa [Set.preimage_compl] using hpre.trans hS0_full

  -- Intersect the forward preimages to obtain a forward-invariant full-measure set.
  set Sinf : Set (Œ©[Œ±]) := ‚ãÇ n : ‚Ñï, (shift^[n]) ‚Åª¬π' S0 with hSinf_def

  have hSinf_meas : MeasurableSet Sinf := by
    refine MeasurableSet.iInter ?_;
    intro n
    simpa using (shift_iterate_measurable (Œ± := Œ±) n) hS0_meas

  have hSinf_full : Œº Sinf·∂ú = 0 := by
    have h_forall : ‚àÄ n : ‚Ñï, ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà (shift^[n]) ‚Åª¬π' S0 := by
      intro n
      have : Œº (((shift^[n]) ‚Åª¬π' S0)·∂ú) = 0 := hpre_full n
      simpa [ae_iff] using this
    have hSinf_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà Sinf := by
      simpa [Sinf, hSinf_def, Set.mem_iInter] using (ae_all_iff.mpr h_forall)
    simpa [ae_iff] using hSinf_ae

  -- Close the forward-invariant set under further pullbacks to target exact invariance.
  set Sstar : Set (Œ©[Œ±]) := ‚ãÇ k : ‚Ñï, (shift^[k]) ‚Åª¬π' Sinf with hSstar_def

  have hSstar_meas : MeasurableSet Sstar := by
    refine MeasurableSet.iInter ?_;
    intro k
    simpa using (shift_iterate_measurable (Œ± := Œ±) k) hSinf_meas

  have hSstar_full : Œº Sstar·∂ú = 0 := by
    have h_forall : ‚àÄ k : ‚Ñï, ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà (shift^[k]) ‚Åª¬π' Sinf := by
      intro k
      have hœÉk : MeasurePreserving (shift^[k]) Œº Œº := hœÉ.iterate k
      have hpre : Œº ((shift^[k]) ‚Åª¬π' Sinf·∂ú) = Œº Sinf·∂ú := by
        rw [hœÉk.measure_preimage hSinf_meas.compl.nullMeasurableSet]
      have : Œº (((shift^[k]) ‚Åª¬π' Sinf)·∂ú) = 0 := by
        simpa [Set.preimage_compl] using hpre.trans hSinf_full
      simpa [ae_iff] using this
    have hSstar_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà Sstar := by
      simpa [Sstar, hSstar_def, Set.mem_iInter] using (ae_all_iff.mpr h_forall)
    simpa [ae_iff] using hSstar_ae

  -- Membership in `Sstar` ensures all forward iterates land back in `Sinf`.
  have hSstar_mem_Sinf : ‚àÄ {œâ}, œâ ‚àà Sstar ‚Üí œâ ‚àà Sinf := by
    intro œâ hœâ
    have hmem : ‚àÄ k : ‚Ñï, œâ ‚àà (shift^[k]) ‚Åª¬π' Sinf := by
      simpa [Sstar, hSstar_def, Set.mem_iInter] using hœâ
    have hzero : œâ ‚àà (shift^[0]) ‚Åª¬π' Sinf := hmem 0
    simpa [Function.iterate_zero, Set.preimage_id] using hzero

  -- Forward invariance: points in `Sstar` stay inside under the shift.
  have hSstar_forward : Sstar ‚äÜ shift ‚Åª¬π' Sstar := by
    intro œâ hœâ
    have hmem : ‚àÄ k : ‚Ñï, shift^[k] œâ ‚àà Sinf := by
      simpa [Sstar, hSstar_def, Set.mem_iInter, Set.mem_preimage] using hœâ
    have hshift_mem : ‚àÄ k : ‚Ñï, shift^[k] (shift œâ) ‚àà Sinf := by
      intro k
      have hk : shift^[k.succ] œâ ‚àà Sinf := hmem (Nat.succ k)
      simpa [Function.iterate_succ_apply, Nat.succ_eq_add_one] using hk
    have hshift : shift œâ ‚àà Sstar := by
      simpa [Sstar, hSstar_def, Set.mem_iInter, Set.mem_preimage, Function.iterate_succ_apply]
        using hshift_mem
    simpa [Set.mem_preimage] using hshift

  -- Pointwise equality holds on `Sstar` thanks to the base case in `Sinf`.
  have hSstar_pointwise : ‚àÄ œâ ‚àà Sstar, g (shift œâ) = g œâ := by
    intro œâ hœâ
    have hœâ_Sinf : œâ ‚àà Sinf := hSstar_mem_Sinf hœâ
    have hœâ_S0 : œâ ‚àà S0 := by
      have hmem : ‚àÄ n : ‚Ñï, œâ ‚àà (shift^[n]) ‚Åª¬π' S0 := by
        simpa [Sinf, hSinf_def, Set.mem_iInter] using hœâ_Sinf
      have hzero : œâ ‚àà (shift^[0]) ‚Åª¬π' S0 := hmem 0
      simpa [Function.iterate_zero, Set.preimage_id] using hzero
    simpa [S0, Set.mem_setOf_eq] using hœâ_S0

  -- The symmetric difference between `Sstar` and its pullback has measure zero.
  have hSstar_symmDiff_zero :
      Œº (symmDiff (shift ‚Åª¬π' Sstar) Sstar) = 0 := by
    have hsubset_diff : ((shift ‚Åª¬π' Sstar) \ Sstar) ‚äÜ Sstar·∂ú := by
      intro œâ hœâ; exact hœâ.2
    have hmeasure_diff : Œº ((shift ‚Åª¬π' Sstar) \ Sstar) = 0 :=
      measure_mono_null hsubset_diff hSstar_full
    have hsubset : Sstar ‚äÜ shift ‚Åª¬π' Sstar := hSstar_forward
    have hzero : Sstar \ shift ‚Åª¬π' Sstar = (‚àÖ : Set (Œ©[Œ±])) := by
      ext œâ; constructor
      ¬∑ intro hœâ
        have : œâ ‚àà shift ‚Åª¬π' Sstar := hsubset hœâ.1
        exact False.elim (hœâ.2 this)
      ¬∑ intro hœâ; simpa using hœâ.elim
    have hsymm :
        symmDiff (shift ‚Åª¬π' Sstar) Sstar
          = ((shift ‚Åª¬π' Sstar) \ Sstar) ‚à™ (Sstar \ shift ‚Åª¬π' Sstar) := rfl
    simpa [hsymm, hzero] using hmeasure_diff

  -- Package all components.
  refine ‚ü®Sstar, hSstar_meas, hSstar_symmDiff_zero, hSstar_full, hSstar_forward,
    hSstar_pointwise‚ü©

/-- Given an `AEStronglyMeasurable` function whose shift agrees with it almost
everywhere, construct a representative that is literally shift-invariant and
measurable with respect to the invariant œÉ-algebra. -/
lemma mkShiftInvariantRep
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    (g : Œ©[Œ±] ‚Üí ‚Ñù) (hg : AEStronglyMeasurable g Œº)
    (hshift : (fun œâ => g (shift œâ)) =·µê[Œº] g) :
    ‚àÉ g',
      AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] g' Œº ‚àß
      (‚àÄ·µê œâ ‚àÇŒº, g' œâ = g œâ) ‚àß
      (‚àÄ œâ, g' (shift œâ) = g' œâ) := by
  classical
  rcases hg with ‚ü®g0, hg0_sm, hg0_ae‚ü©
  have hshift_g0 : (fun œâ => g0 (shift œâ)) =·µê[Œº] g0 :=
    ae_shift_invariance_on_rep (Œº := Œº) hœÉ hg0_ae.symm hshift
  have hg0_meas : Measurable g0 := hg0_sm.measurable
  obtain ‚ü®S, hS_meas, _hSymm, hS_null, hS_subset, hS_point‚ü© :=
    exists_shiftInvariantFullMeasureSet (Œº := Œº) hœÉ g0 hg0_meas hshift_g0
  have hforward : ‚àÄ œâ ‚àà S, shift œâ ‚àà S := by
    intro œâ hœâ
    have : œâ ‚àà shift ‚Åª¬π' S := hS_subset hœâ
    simpa [Set.mem_preimage] using this
  have hS_ae : ‚àÄ·µê œâ ‚àÇŒº, œâ ‚àà S := by
    simpa [ae_iff] using hS_null
  have hconst_on_S : ‚àÄ œâ ‚àà S, ‚àÄ n : ‚Ñï, g0 (shift^[n] œâ) = g0 œâ := by
    intro œâ hœâ
    have hmem : ‚àÄ n : ‚Ñï, shift^[n] œâ ‚àà S := by
      intro n
      induction' n with n ih
      ¬∑ simpa [Function.iterate_zero_apply] using hœâ
      ¬∑ have := hforward _ ih
        simpa [Function.iterate_succ_apply, Nat.succ_eq_add_one] using this
    refine Nat.rec (by simpa [Function.iterate_zero_apply]) ?_
    intro n ih
    have hstep : g0 (shift^[n.succ] œâ) = g0 (shift^[n] œâ) := by
      have := hS_point (shift^[n] œâ) (hmem n)
      simpa [Function.iterate_succ_apply, Nat.succ_eq_add_one] using this
    exact hstep.trans ih
  have hconst : ‚àÄ·µê œâ ‚àÇŒº, ‚àÄ n : ‚Ñï, g0 (shift^[n] œâ) = g0 œâ := by
    filter_upwards [hS_ae] with œâ hœâ using hconst_on_S œâ hœâ
  let g' := gRep g0
  have hg'_meas : Measurable g' :=
    gRep_measurable (Œ± := Œ±) (g0 := g0) hg0_meas
  have hg'_ae_g0 : g' =·µê[Œº] g0 := gRep_ae_eq_of_constant_orbit (g0 := g0) hconst
  have hg'_inv : ‚àÄ œâ, g' (shift œâ) = g' œâ :=
    gRep_shiftInvariant (Œ± := Œ±) (g0 := g0)
  have hg'_tail : Measurable[shiftInvariantSigma (Œ± := Œ±)] g' :=
    shiftInvariant_implies_shiftInvariantMeasurable (Œ± := Œ±) g' hg'_meas hg'_inv
  refine ‚ü®g', hg'_tail.aestronglyMeasurable, ?_, hg'_inv‚ü©
  exact hg'_ae_g0.trans hg0_ae.symm

/-- Main construction: given a function that agrees with its shift a.e.,
    produce a shift-invariant representative. -/
lemma exists_shiftInvariantRepresentative
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    (g : Œ©[Œ±] ‚Üí ‚Ñù)
    (hg : AEStronglyMeasurable g Œº)
    (hinv : (fun œâ => g (shift œâ)) =·µê[Œº] g) :
    ‚àÉ g',
      AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] g' Œº ‚àß
      (‚àÄ·µê œâ ‚àÇŒº, g' œâ = g œâ) ‚àß
      (‚àÄ œâ, g' (shift œâ) = g' œâ) := by
  classical
  simpa using mkShiftInvariantRep (Œº := Œº) hœÉ g hg hinv


/-- Functions that are `AEStronglyMeasurable` with respect to the invariant œÉ-algebra are
almost everywhere fixed by the shift. -/
lemma shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) {f : Œ©[Œ±] ‚Üí ‚Ñù}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº) :
    (fun œâ => f (shift œâ)) =·µê[Œº] f := by
  classical
  rcases hf with ‚ü®g, hg_meas, hfg‚ü©
  have hcomp :=
    (hœÉ.quasiMeasurePreserving).ae_eq_comp (Œº := Œº) (ŒΩ := Œº)
      (f := shift (Œ± := Œ±)) (g := fun œâ => f œâ) (g' := fun œâ => g œâ) hfg
  have hshift : (fun œâ => g (shift œâ)) =·µê[Œº] g :=
    EventuallyEq.of_eq (shiftInvariantSigma_measurable_shift_eq g hg_meas.measurable)
  exact hcomp.trans <| hshift.trans hfg.symm

/-- If an `Lp` function is measurable with respect to the invariant œÉ-algebra, the Koopman
operator fixes it. -/
lemma koopman_eq_self_of_shiftInvariant
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f : Lp ‚Ñù 2 Œº}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº) :
    koopman shift hœÉ f = f := by
  classical
  have hcomp :
      (koopman shift hœÉ f) =·µê[Œº]
        (fun œâ => f (shift œâ)) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Œ± := Œ±)) hœÉ f =·µê[Œº]
        fun œâ => f (shift œâ)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving f hœÉ)
  have hshift := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq (Œº := Œº) hœÉ hf
  have hfinal : (koopman shift hœÉ f) =·µê[Œº] f := hcomp.trans hshift
  exact Lp.ext hfinal

/-- A Koopman-fixed function is automatically measurable with respect to the
invariant œÉ-algebra.

Starting from the a.e. identity `f ‚àò shift = f`, the previous lemma replaces a
representative of `f` by an actual shift-invariant function, and the resulting
measurability is transported back to `f`. -/
lemma aestronglyMeasurable_shiftInvariant_of_koopman
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº)
    {f : Lp ‚Ñù 2 Œº}
    (hfix : koopman shift hœÉ f = f) :
    AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº := by
  classical
  /-
  Proof strategy sketch:
  1. Unfold the equality `koopman shift hœÉ f = f` to obtain the almost-everywhere
     identity `(fun œâ => f (shift œâ)) =·µê[Œº] f`.
  2. Choose a strongly measurable representative `g` of `f`.
  3. Apply `exists_shiftInvariantRepresentative` to obtain a version `g'` of `g`
     that is literally shift-invariant and measurable with respect to the
     invariant œÉ-algebra.
  4. Transport measurability of `g'` back to `f` using the almost everywhere
     equality.

  Implementing steps (3)‚Äì(5) will likely require a bespoke lemma about
  modifying functions on null sets to enforce invariance; this will be filled in
  later.
  -/
  -- STEP 1. Extract the a.e. invariance statement from `koopman` equality.
  have hcomp : (koopman shift hœÉ f) =·µê[Œº] fun œâ => f (shift œâ) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Œ± := Œ±)) hœÉ f =·µê[Œº]
        fun œâ => f (shift œâ)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving f hœÉ)
  have hfixAE : (koopman shift hœÉ f) =·µê[Œº] f := by
    simp [hfix]
  have hshift : (fun œâ => f (shift œâ)) =·µê[Œº] f := by
    exact hcomp.symm.trans hfixAE
  have hf_base : AEStronglyMeasurable f Œº := Lp.aestronglyMeasurable f
  obtain ‚ü®g', hg'_meas, hAE, _‚ü© :=
    mkShiftInvariantRep (Œº := Œº) hœÉ (fun œâ => f œâ) hf_base hshift
  have hf_meas : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)] f Œº :=
    (AEStronglyMeasurable.congr hg'_meas hAE)
  exact hf_meas

/-- The fixed-point subspace of the Koopman operator.

This is the closed subspace of L¬≤(Œº) consisting of equivalence classes of functions
f such that f ‚àò shift = f almost everywhere.
-/
def fixedSubspace {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) : Submodule ‚Ñù (Lp ‚Ñù 2 Œº) :=
  fixedSpace (koopman shift hœÉ)

/-- Functions in the fixed-point subspace are exactly those that are a.e. invariant under shift. -/
lemma mem_fixedSubspace_iff {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) (f : Lp ‚Ñù 2 Œº) :
    f ‚àà fixedSubspace hœÉ ‚Üî koopman shift hœÉ f = f := by
  rfl

/-- The orthogonal projection onto the fixed-point subspace exists (as a closed subspace). -/
lemma fixedSubspace_closed {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    IsClosed (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  let T := koopman shift hœÉ
  have hset : (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) =
      (fun f : Lp ‚Ñù 2 Œº => T f - f) ‚Åª¬π' ({0} : Set (Lp ‚Ñù 2 Œº)) := by
    ext f
    unfold fixedSubspace fixedSpace
    simp [T, LinearMap.mem_eqLocus, sub_eq_zero]
  have hcont : Continuous fun f : Lp ‚Ñù 2 Œº => T f - f :=
    (T.continuous.sub continuous_id)
  have hclosed : IsClosed ((fun f : Lp ‚Ñù 2 Œº => T f - f) ‚Åª¬π'
      ({0} : Set (Lp ‚Ñù 2 Œº))) :=
    IsClosed.preimage hcont isClosed_singleton
  simpa [hset]

/-- The mean ergodic projection onto the fixed subspace. -/
noncomputable def METProjection
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) : Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº := by
  classical
  let S := fixedSubspace hœÉ
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  haveI : CompleteSpace S := hclosed.completeSpace_coe
  haveI : S.HasOrthogonalProjection := Submodule.HasOrthogonalProjection.ofCompleteSpace S
  exact (S.subtypeL).comp S.orthogonalProjection

lemma METProjection_apply
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) (f : Lp ‚Ñù 2 Œº) :
    let hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
    haveI : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
    haveI : (fixedSubspace hœÉ).HasOrthogonalProjection := 
      Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hœÉ)
    METProjection (Œº := Œº) hœÉ f =
      (fixedSubspace hœÉ).subtypeL ((fixedSubspace hœÉ).orthogonalProjection f) := by
  classical
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  haveI : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
  haveI : (fixedSubspace hœÉ).HasOrthogonalProjection := 
    Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hœÉ)
  rfl

lemma METProjection_mem
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) (f : Lp ‚Ñù 2 Œº) :
    METProjection (Œº := Œº) hœÉ f ‚àà fixedSubspace hœÉ := by
  classical
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  haveI : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
  haveI : (fixedSubspace hœÉ).HasOrthogonalProjection := 
    Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hœÉ)
  rw [METProjection_apply]
  simp

lemma METProjection_fixed
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) {g : Lp ‚Ñù 2 Œº}
    (hg : g ‚àà fixedSubspace hœÉ) :
    METProjection (Œº := Œº) hœÉ g = g := by
  classical
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  haveI : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
  haveI : (fixedSubspace hœÉ).HasOrthogonalProjection := 
    Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hœÉ)
  have hproj :=
      Submodule.orthogonalProjection_mem_subspace_eq_self
        (‚ü®g, hg‚ü© : fixedSubspace hœÉ)
  have hproj_val :
      (((fixedSubspace hœÉ).orthogonalProjection g) : Lp ‚Ñù 2 Œº) = g := by
    simpa using congrArg Subtype.val hproj
  simp [METProjection, hproj_val]

lemma METProjection_idem
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    (METProjection (Œº := Œº) hœÉ).comp (METProjection (Œº := Œº) hœÉ) =
      METProjection (Œº := Œº) hœÉ := by
  classical
  apply ContinuousLinearMap.ext
  intro f
  have hf_mem := METProjection_mem (Œº := Œº) hœÉ f
  simp [ContinuousLinearMap.coe_comp', Function.comp_apply,
    METProjection_fixed (Œº := Œº) hœÉ hf_mem]

lemma METProjection_range
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    Set.range (METProjection (Œº := Œº) hœÉ) =
      (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  have : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
  ext x
  constructor
  ¬∑ intro hx
    rcases hx with ‚ü®f, rfl‚ü©
    exact METProjection_mem (Œº := Œº) hœÉ f
  ¬∑ intro hx
    refine ‚ü®x, ?_‚ü©
    simpa using METProjection_fixed (Œº := Œº) hœÉ hx

lemma METProjection_isSymmetric
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    (METProjection (Œº := Œº) hœÉ).IsSymmetric := by
  classical
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  have : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
  simpa [METProjection] using
    (subtypeL_comp_orthogonalProjection_isSymmetric
      (fixedSubspace hœÉ : Submodule ‚Ñù (Lp ‚Ñù 2 Œº)))

lemma METProjection_tendsto
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) (f : Lp ‚Ñù 2 Œº) :
    Tendsto (fun n => birkhoffAverage ‚Ñù (koopman shift hœÉ) _root_.id n f)
      atTop (ùìù (METProjection (Œº := Œº) hœÉ f)) := by
  classical
  let K : Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº := koopman shift hœÉ
  have hnorm : ‚ÄñK‚Äñ ‚â§ (1 : ‚Ñù) := by
    refine ContinuousLinearMap.opNorm_le_bound _ (by norm_num) ?_
    intro g
    have hiso : Isometry (koopman shift hœÉ) := koopman_isometry shift hœÉ
    have hg : ‚ÄñK g‚Äñ = ‚Äñg‚Äñ := by
      simpa [K] using Isometry.norm_map_of_map_zero hiso (map_zero _) g
    simp [hg]
  have hclosed := fixedSubspace_closed (Œº := Œº) hœÉ
  haveI : CompleteSpace (fixedSubspace hœÉ) := hclosed.completeSpace_coe
  haveI : (fixedSubspace hœÉ).HasOrthogonalProjection := 
    Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hœÉ)
  have hS : (LinearMap.eqLocus K.toLinearMap 1) = fixedSubspace hœÉ := rfl
  -- Set up the instance context for the eqLocus subspace
  have : CompleteSpace (LinearMap.eqLocus K.toLinearMap 1) := by
    rw [hS]; exact hclosed.completeSpace_coe
  have : (LinearMap.eqLocus K.toLinearMap 1).HasOrthogonalProjection := by
    rw [hS]; exact Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hœÉ)
  have hlimit := ContinuousLinearMap.tendsto_birkhoffAverage_orthogonalProjection K hnorm f
  convert hlimit using 1

/-- The range of `METProjection` equals the fixed subspace. -/
lemma METProjection_range_fixedSubspace
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    Set.range (METProjection (Œº := Œº) hœÉ) =
      (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) :=
  METProjection_range (Œº := Œº) hœÉ

/-- `METProjection` fixes elements of the fixed subspace. -/
lemma METProjection_fixes_fixedSubspace
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) {g : Lp ‚Ñù 2 Œº}
    (hg : g ‚àà fixedSubspace hœÉ) :
    METProjection (Œº := Œº) hœÉ g = g :=
  METProjection_fixed (Œº := Œº) hœÉ hg

/-- Conditional expectation on L¬≤ with respect to the shift-invariant œÉ-algebra.

This is the orthogonal projection onto the subspace of shift-invariant L¬≤ functions,
implemented using mathlib's `condExpL2`. -/
noncomputable def condexpL2 {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº] :
    Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] Lp ‚Ñù 2 Œº :=
  -- Apply mathlib's conditional expectation to get projection onto lpMeas
  let ce : Lp ‚Ñù 2 Œº ‚ÜíL[‚Ñù] lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº :=
    MeasureTheory.condExpL2 ‚Ñù ‚Ñù (m := shiftInvariantSigma) shiftInvariantSigma_le
  -- Compose with subtype inclusion to get back to full Lp space
  (lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº).subtypeL.comp ce


/-- lpMeas functions are exactly the Koopman-fixed functions. -/

lemma condexpL2_idem {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº] :
    (condexpL2 (Œº := Œº)).comp (condexpL2 (Œº := Œº)) = condexpL2 (Œº := Œº) := by
  classical
  apply ContinuousLinearMap.ext
  intro f
  simp only [condexpL2, ContinuousLinearMap.coe_comp', Function.comp_apply]
  haveI :
      Fact
        (shiftInvariantSigma (Œ± := Œ±) ‚â§
          (inferInstance : MeasurableSpace (Œ©[Œ±]))) :=
    ‚ü®shiftInvariantSigma_le (Œ± := Œ±)‚ü©
  have hfix :=
    Submodule.orthogonalProjection_mem_subspace_eq_self
      (K := lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº)
      (MeasureTheory.condExpL2 ‚Ñù ‚Ñù (m := shiftInvariantSigma)
        shiftInvariantSigma_le f)
  simpa [MeasureTheory.condExpL2]
    using congrArg Subtype.val hfix

lemma lpMeas_eq_fixedSubspace
    {Œº : Measure (Œ©[Œ±])} [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    (Set.range (lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº).subtypeL : Set (Lp ‚Ñù 2 Œº)) =
    (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  apply Set.Subset.antisymm
  ¬∑ -- ‚Üí direction: range subtypeL ‚äÜ fixedSubspace
    intro f hf
    rcases hf with ‚ü®g, rfl‚ü©
    have hg : AEStronglyMeasurable[shiftInvariantSigma (Œ± := Œ±)]
        ((lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº).subtypeL g : Œ©[Œ±] ‚Üí ‚Ñù) Œº :=
      lpMeas.aestronglyMeasurable g
    -- Koopman fixes `g`:
    have := koopman_eq_self_of_shiftInvariant (Œº := Œº) hœÉ
      (f := (lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº).subtypeL g) hg
    simpa [fixedSubspace, fixedSpace] using this
  ¬∑ -- ‚Üê direction: fixedSubspace ‚äÜ range subtypeL
    intro f hf
    -- obtain a shift-invariant measurable representative
    have hmeas := aestronglyMeasurable_shiftInvariant_of_koopman (Œº := Œº) hœÉ
      (f := f) (by simpa [fixedSubspace, fixedSpace] using hf)
    -- put it in range of subtypeL
    exact ‚ü®‚ü®f, hmeas‚ü©, rfl‚ü©

/-- The conditional expectation equals the orthogonal projection onto the fixed-point subspace.

This fundamental connection links:
- Probability theory: conditional expectation with respect to shift-invariant œÉ-algebra  
- Functional analysis: orthogonal projection in Hilbert space
- Ergodic theory: fixed-point subspace of the Koopman operator
-/
lemma range_condexp_eq_fixedSubspace {Œº : Measure (Œ©[Œ±])}
    [IsProbabilityMeasure Œº]
    (hœÉ : MeasurePreserving shift Œº Œº) :
    Set.range (condexpL2 (Œº := Œº)) =
    (fixedSubspace hœÉ : Set (Lp ‚Ñù 2 Œº)) := by
  classical
  -- Range of the composition is the image of lpMeas
  have h_proj :
      Set.range (condexpL2 (Œº := Œº))
        = Set.range (lpMeas ‚Ñù ‚Ñù shiftInvariantSigma 2 Œº).subtypeL := by
    apply Set.Subset.antisymm
    ¬∑ intro f hf
      rcases hf with ‚ü®x, rfl‚ü©
      exact ‚ü®(MeasureTheory.condExpL2 ‚Ñù ‚Ñù (m := shiftInvariantSigma)
        shiftInvariantSigma_le) x, rfl‚ü©
    ¬∑ intro f hf
      rcases hf with ‚ü®y, rfl‚ü©
      refine ‚ü®(‚Üëy : Lp ‚Ñù 2 Œº), ?_‚ü©
      have hfix : (MeasureTheory.condExpL2 ‚Ñù ‚Ñù (m := shiftInvariantSigma)
        shiftInvariantSigma_le)
          (‚Üëy) = y := by
        classical
        haveI :
            Fact
              (shiftInvariantSigma (Œ± := Œ±) ‚â§
                (inferInstance : MeasurableSpace (Œ©[Œ±]))) :=
          ‚ü®shiftInvariantSigma_le (Œ± := Œ±)‚ü©
        simp [MeasureTheory.condExpL2]
      simp [condexpL2, ContinuousLinearMap.comp_apply, hfix]
  -- now swap range via lpMeas_eq_fixedSubspace
  rw [h_proj, lpMeas_eq_fixedSubspace (Œº := Œº) hœÉ]

end Exchangeability.DeFinetti
