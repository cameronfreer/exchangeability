/-
Copyright (c) 2025 exchangeability contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: exchangeability contributors
-/
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Exchangeability.Ergodic.KoopmanMeanErgodic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.CondexpL2

/-!
# Shift-invariant Ïƒ-algebra and conditional expectation

This file defines the shift-invariant Ïƒ-algebra on path space and establishes
the fundamental connection between:
- The fixed-point subspace of the Koopman operator
- The LÂ² space with respect to the shift-invariant Ïƒ-algebra
- The conditional expectation onto the shift-invariant Ïƒ-algebra

## Main definitions

* `isShiftInvariant`: Predicate for sets that are invariant under the shift map.
* `shiftInvariantSigma`: The Ïƒ-algebra of shift-invariant sets.
* `fixedSubspace`: The subspace of LÂ² functions fixed by the Koopman operator.

## Main results

* `mem_shiftInvariantSigma_iff`: Characterization of membership in the invariant Ïƒ-algebra.
* `fixedSpace_eq_invMeasurable`: Functions fixed by Koopman are exactly those
  measurable with respect to the shift-invariant Ïƒ-algebra.
* `proj_eq_condexp`: The orthogonal projection onto the fixed-point subspace equals
  the conditional expectation onto the shift-invariant Ïƒ-algebra.

## References

* Olav Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Springer, Chapter 1 (pages 26-27). The shift-invariant Ïƒ-algebra is denoted
  ğ“˜_Î¾ in Kallenberg.

-/

noncomputable section

open scoped Classical

namespace Exchangeability.DeFinetti

open MeasureTheory Filter Topology
open Exchangeability.Probability.Ergodic

variable {Î± : Type*} [MeasurableSpace Î±]

/-- A set is shift-invariant if it is measurable and equals its preimage under shift. -/
def isShiftInvariant (s : Set (Î©[Î±])) : Prop :=
  MeasurableSet s âˆ§ shift â»Â¹' s = s

lemma isShiftInvariant_iff (s : Set (Î©[Î±])) :
    isShiftInvariant s â†” MeasurableSet s âˆ§ âˆ€ Ï‰, shift Ï‰ âˆˆ s â†” Ï‰ âˆˆ s := by
  constructor
  Â· intro âŸ¨hm, heqâŸ©
    exact âŸ¨hm, fun Ï‰ => by rw [â† Set.mem_preimage, heq]âŸ©
  Â· intro âŸ¨hm, hiffâŸ©
    refine âŸ¨hm, Set.ext fun Ï‰ => ?_âŸ©
    simp [hiff]

/-- The shift-invariant Ïƒ-algebra: the collection of shift-invariant sets.

For now we define this axiomatically; a full construction would use the Ïƒ-algebra
generated by shift-invariant sets or the comap construction.
-/
def shiftInvariantSigma : MeasurableSpace (Î©[Î±]) where
  MeasurableSet' := fun s => isShiftInvariant (Î± := Î±) s
  measurableSet_empty := by
    refine âŸ¨measurableSet_empty, ?_âŸ©
    simp
  measurableSet_compl := by
    intro s hs
    obtain âŸ¨hs_meas, hs_eqâŸ© := hs
    refine âŸ¨hs_meas.compl, ?_âŸ©
    simpa [Set.preimage_compl, hs_eq, Set.compl_compl]
  measurableSet_iUnion := by
    intro f hf
    refine âŸ¨measurableSet_iUnion fun n => (hf n).left, ?_âŸ©
    ext Ï‰
    simp [Set.preimage_iUnion, hf]

lemma shiftInvariantSigma_le :
    shiftInvariantSigma â‰¤ (inferInstance : MeasurableSpace (Î©[Î±])) := by
  intro s hs
  exact (hs : isShiftInvariant (Î± := Î±) s).1

lemma mem_shiftInvariantSigma_iff (s : Set (Î©[Î±])) :
    @MeasurableSet _ shiftInvariantSigma s â†” isShiftInvariant (Î± := Î±) s :=
  Iff.rfl

/-- Shift-invariant measurability forces pointwise invariance under the shift map. -/
lemma shiftInvariantSigma_measurable_shift_eq
    (g : Î©[Î±] â†’ â„)
    (hg : @Measurable _ shiftInvariantSigma _ g) :
    (fun Ï‰ => g (shift Ï‰)) = g := by
  classical
  ext Ï‰
  by_contra hneq
  have hlt_or := lt_or_gt_of_ne hneq
  cases' hlt_or with hlt hgt
  Â· -- Case `g (shift Ï‰) < g Ï‰`
    obtain âŸ¨q, hltq, hqÏ‰âŸ© := exists_rat_btwn hlt
    have hset_eq := (hg (MeasurableSet_Iio (q : â„))).2
    have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
      simpa [Set.mem_preimage] using hltq
    have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Iio (q : â„)) := by
      simpa [Set.mem_preimage] using h_shift_mem
    have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Iio (q : â„) := by
      simpa [hset_eq] using h_pre
    have : g Ï‰ < (q : â„) := by
      simpa [Set.mem_preimage] using h_mem
    have : g Ï‰ < g Ï‰ := lt_trans this hqÏ‰
    exact lt_irrefl _ this
  Â· -- Case `g Ï‰ < g (shift Ï‰)`
    obtain âŸ¨q, hÏ‰q, hq_ltâŸ© := exists_rat_btwn hgt
    have hset_eq := (hg (MeasurableSet_Ioi (q : â„))).2
    have h_shift_mem : shift Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
      simpa [Set.mem_preimage] using hq_lt
    have h_pre : Ï‰ âˆˆ shift â»Â¹' (g â»Â¹' Set.Ioi (q : â„)) := by
      simpa [Set.mem_preimage] using h_shift_mem
    have h_mem : Ï‰ âˆˆ g â»Â¹' Set.Ioi (q : â„) := by
      simpa [hset_eq] using h_pre
    have : (q : â„) < g Ï‰ := by
      simpa [Set.mem_preimage] using h_mem
  have : g Ï‰ < g Ï‰ := lt_trans hÏ‰q this
  exact lt_irrefl _ this

/-- **Auxiliary goal**: construct an invariant representative.

Once `g : Î©[Î±] â†’ â„` is strongly measurable and agrees a.e. with its shift, we expect to
modify it on a null set so that it becomes literally invariant under `shift` while remaining
measurable with respect to `shiftInvariantSigma`.  Filling in this lemma (or a closely related
variant) will let us finish `aestronglyMeasurable_shiftInvariant_of_koopman`. -/
lemma exists_shiftInvariantRepresentative
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    (g : Î©[Î±] â†’ â„)
    (hg : AEStronglyMeasurable g Î¼)
    (hinv : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g) :
    âˆƒ g',
      AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] g' Î¼ âˆ§
      (âˆ€áµ Ï‰ âˆ‚Î¼, g' Ï‰ = g Ï‰) âˆ§
      (âˆ€ Ï‰, g' (shift Ï‰) = g' Ï‰) := by
  classical
  rcases hg with âŸ¨g0, hg0_sm, hAEg0âŸ©
  have hcomp :=
    (hÏƒ.quasiMeasurePreserving.ae_eq_comp (Î¼ := Î¼) (Î½ := Î¼)
      (f := shift (Î± := Î±)) (g := fun Ï‰ => g Ï‰) (g' := fun Ï‰ => g0 Ï‰) hAEg0)
  have hshift0 : (fun Ï‰ => g0 (shift Ï‰)) =áµ[Î¼] g0 :=
    hcomp.trans (hinv.trans hAEg0)
  let S : Set (Î©[Î±]) := {Ï‰ | g0 (shift Ï‰) = g0 Ï‰}
  have hS_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ S := by
    simpa [S, Set.mem_setOf_eq] using hshift0
  have hS_null : Î¼ Sá¶œ = 0 := by
    simpa [ae_iff, S, Set.mem_setOf_eq] using hS_ae
  let Sâˆ : Set (Î©[Î±]) := â‹‚ n : â„•, (shift^[n]) â»Â¹' S
  have hSinf_null : Î¼ Sâˆá¶œ = 0 := by
    have hcompl : Sâˆá¶œ = â‹ƒ n : â„•, (shift^[n]) â»Â¹' Sá¶œ := by
      classical
      simpa [Sâˆ, Set.preimage_compl]
        using (Set.compl_iInter (fun n : â„• => (shift^[n]) â»Â¹' S))
    have hpreimage_null : âˆ€ n : â„•, Î¼ ((shift^[n]) â»Â¹' Sá¶œ) = 0 := by
      intro n
      simpa using ((MeasurePreserving.iterate hÏƒ n).preimage_null hS_null)
    simpa [hcompl] using measure_iUnion_null hpreimage_null
  have hSinf_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ Sâˆ := by
    simpa [ae_iff, Sâˆ] using hSinf_null
  have hSinf_preimage : shift â»Â¹' Sâˆ = Sâˆ := by
    classical
    ext Ï‰
    constructor
    Â· intro hÏ‰
      refine Set.mem_iInter.mpr ?_
      intro n
      have := Set.mem_iInter.mp hÏ‰ (n + 1)
      simpa [Function.iterate_succ] using this
    Â· intro hÏ‰
      have : shift Ï‰ âˆˆ Sâˆ := by
        refine Set.mem_iInter.mpr ?_
        intro n
        have := Set.mem_iInter.mp hÏ‰ n
        simpa [Function.iterate_succ, Function.comp] using this
      simpa [Set.mem_preimage] using this
  have hSinf_equiv : âˆ€ Ï‰, Ï‰ âˆˆ Sâˆ â†” shift Ï‰ âˆˆ Sâˆ := by
    intro Ï‰
    have hmem := congrArg (fun s => Ï‰ âˆˆ s) hSinf_preimage
    simpa [Set.mem_preimage] using hmem
  let g' : Î©[Î±] â†’ â„ := fun Ï‰ => if Ï‰ âˆˆ Sâˆ then g0 Ï‰ else 0
  have g'_def : g' = Set.indicator Sâˆ g0 := by
    classical
    funext Ï‰
    by_cases hÏ‰ : Ï‰ âˆˆ Sâˆ
    Â· simp [g', hÏ‰, Set.indicator_of_mem]
    Â· simp [g', hÏ‰, Set.indicator_of_not_mem]
  have hg'_ae_eq_g0 : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g0 := by
    filter_upwards [hSinf_ae] with Ï‰ hÏ‰
    simp [g', hÏ‰]
  have hg'_ae_eq_g : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g :=
    hg'_ae_eq_g0.trans hAEg0
  have hshift_g' : âˆ€ Ï‰, g' (shift Ï‰) = g' Ï‰ := by
    intro Ï‰
    by_cases hÏ‰ : Ï‰ âˆˆ Sâˆ
    Â· have hshiftÏ‰ : shift Ï‰ âˆˆ Sâˆ := (hSinf_equiv Ï‰).1 hÏ‰
      have hSÏ‰ : Ï‰ âˆˆ S := by
        simpa [S] using Set.mem_iInter.mp hÏ‰ 0
      simp [g', hÏ‰, hshiftÏ‰, S, hSÏ‰]
    Â· have hshiftÏ‰ : shift Ï‰ âˆ‰ Sâˆ := by
        exact (not_congr (hSinf_equiv Ï‰)).1 hÏ‰
      simp [g', hÏ‰, hshiftÏ‰]
  -- measurability of the invariant representative
  refine âŸ¨g', ?_, hg'_ae_eq_g, hshift_g'âŸ©
  Â· -- `g'` is measurable with respect to the invariant Ïƒ-algebra
    have hshift_meas : Measurable fun Ï‰ => g0 (shift Ï‰) :=
      hg0_sm.measurable.comp measurable_shift
    have hS_meas : MeasurableSet S := by
      classical
      have hdiff_meas : Measurable fun Ï‰ => g0 (shift Ï‰) - g0 Ï‰ :=
        hshift_meas.sub hg0_sm.measurable
      have hset_eq : S = (fun Ï‰ => g0 (shift Ï‰) - g0 Ï‰) â»Â¹' {0} := by
        ext Ï‰; simp [S]
      simpa [hset_eq] using hdiff_meas measurableSet_singleton
    have hshift_iter_meas : âˆ€ n : â„•, Measurable fun Ï‰ => shift^[n] Ï‰ := by
      intro n
      induction' n with n ih
      Â· simpa using measurable_id
      Â· simpa [Function.iterate_succ, Function.comp] using measurable_shift.comp ih
    have hSinf_meas : MeasurableSet Sâˆ := by
      classical
      refine MeasurableSet.iInter fun n => ?_
      simpa [Sâˆ] using (hshift_iter_meas n) hS_meas
    have hg0_meas : Measurable g0 := hg0_sm.measurable
    have hg'_meas : Measurable g' := by
      classical
      simpa [g'_def] using hg0_meas.indicator hSinf_meas
    have hg'_meas_shift : Measurable[shiftInvariantSigma] g' := by
      classical
      intro t ht
      have hset_meas : MeasurableSet (g' â»Â¹' t) := hg'_meas ht
      have hset_inv : shift â»Â¹' (g' â»Â¹' t) = g' â»Â¹' t := by
        ext Ï‰; simp [Set.mem_preimage, hshift_g']
      exact (mem_shiftInvariantSigma_iff (g' â»Â¹' t)).mpr âŸ¨hset_meas, hset_invâŸ©
    exact hg'_meas_shift.aestronglyMeasurable

/-- A function is measurable with respect to the shift-invariant Ïƒ-algebra iff
it is (a.e.) constant along shift orbits. -/
lemma invMeasurable_iff_shiftInvariant {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (_hÏƒ : MeasurePreserving shift Î¼ Î¼) (g : Î©[Î±] â†’ â„) :
    (âˆ€áµ Ï‰ âˆ‚Î¼, g (shift Ï‰) = g Ï‰) â†’
    (@Measurable _ _ shiftInvariantSigma _ g â†’
     âˆ€áµ Ï‰ âˆ‚Î¼, g (shift Ï‰) = g Ï‰) := by
  intro _ hmeas
  refine eventually_of_forall ?_
  intro Ï‰
  have hfun := congrArg (fun f => f Ï‰) (shiftInvariantSigma_measurable_shift_eq g hmeas)
  simpa using hfun

/-- Functions that are `AEStronglyMeasurable` with respect to the invariant Ïƒ-algebra are
almost everywhere fixed by the shift. -/
lemma shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) {f : Î©[Î±] â†’ â„}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼) :
    (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f := by
  classical
  rcases hf with âŸ¨g, hg_meas, hfgâŸ©
  have hcomp :=
    (hÏƒ.quasiMeasurePreserving).ae_eq_comp (Î¼ := Î¼) (Î½ := Î¼)
      (f := shift (Î± := Î±)) (g := fun Ï‰ => f Ï‰) (g' := fun Ï‰ => g Ï‰) hfg
  have hshift : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g :=
    EventuallyEq.of_eq (shiftInvariantSigma_measurable_shift_eq g hg_meas.measurable)
  exact hcomp.trans <| hshift.trans hfg.symm

/-- If an `Lp` function is measurable with respect to the invariant Ïƒ-algebra, the Koopman
operator fixes it. -/
lemma koopman_eq_self_of_shiftInvariant
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    {f : Lp â„ 2 Î¼}
    (hf : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼) :
    koopman shift hÏƒ f = f := by
  classical
  have hcomp :
      (koopman shift hÏƒ f) =áµ[Î¼]
        (fun Ï‰ => f (shift Ï‰)) := by
    change MeasureTheory.Lp.compMeasurePreserving (shift (Î± := Î±)) hÏƒ f =áµ[Î¼]
        fun Ï‰ => f (shift Ï‰)
    simpa [koopman]
      using
        (MeasureTheory.Lp.coeFn_compMeasurePreserving (Î¼ := Î¼) (Î¼b := Î¼)
            (p := (2 : â„â‰¥0âˆ)) f hÏƒ)
  have hshift := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq (Î¼ := Î¼) hÏƒ hf
  have hfinal : (koopman shift hÏƒ f) =áµ[Î¼] f := hcomp.trans hshift
  exact Lp.ext hfinal

/-- A Koopman-fixed function should be measurable with respect to the invariant Ïƒ-algebra.

The key step is to modify a representative of `f` on a null set so that it becomes
pointwise invariant under the shift; the resulting function will then be
`shiftInvariantSigma`-measurable by construction. -/
lemma aestronglyMeasurable_shiftInvariant_of_koopman
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    {f : Lp â„ 2 Î¼}
    (hfix : koopman shift hÏƒ f = f) :
    AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ := by
  classical
  /-
  Proof strategy sketch:
  1. Unfold the equality `koopman shift hÏƒ f = f` to obtain the almost-everywhere
     identity `(fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f`.
  2. Choose a strongly measurable representative `g` of `f`.
  3. Modify `g` on the Î¼-null set where the shift invariance fails to build a
     pointwise invariant function `g'` with `g' = g` almost everywhere.
  4. Perform the null-set modification inductively along the orbit to ensure
     `g' âˆ˜ shift = g'` on the nose.
  5. Conclude that the preimage of any Borel set under `g'` is shift-invariant,
     hence belongs to `shiftInvariantSigma` by definition, giving the desired
     measurability.
  6. Finally transport this back to the original `f` using the `AE` equality.

  Implementing steps (3)â€“(5) will likely require a bespoke lemma about
  modifying functions on null sets to enforce invariance; this will be filled in
  later.
  -/
  -- STEP 1. Extract the a.e. invariance statement from `koopman` equality.
  have hshift : (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] f := by
    have := congrArg (fun g : Lp â„ 2 Î¼ => g) hfix
    exact this
  -- STEP 2. Choose a strongly measurable representative of `f`.
  have hf_base : AEStronglyMeasurable f Î¼ := by
    simpa using (Lp.aestronglyMeasurable (Î¼ := Î¼) (p := (2 : â„â‰¥0âˆ)) f)
  obtain âŸ¨g, hg_meas, hfgâŸ© := hf_base
  -- Transport the a.e. invariance to the chosen representative.
  have hshift_g : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] g := by
    have hcomp := (hÏƒ.quasiMeasurePreserving.ae_eq_comp hfg)
    have hcomp' : (fun Ï‰ => g (shift Ï‰)) =áµ[Î¼] (fun Ï‰ => f (shift Ï‰)) := by
      simpa using hcomp
    have hshift' : (fun Ï‰ => f (shift Ï‰)) =áµ[Î¼] g := hshift.trans hfg
    exact hcomp'.trans hshift'
  -- STEP 3. Record the full-measure set on which the representative is pointwise invariant.
  let S : Set (Î©[Î±]) := {Ï‰ | g (shift Ï‰) = g Ï‰}
  have hS_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ S := by
    simpa [S, Set.mem_setOf_eq] using hshift_g
  have hS_null : Î¼ Sá¶œ = 0 := by
    simpa [ae_iff, S, Set.mem_setOf_eq] using hS_ae
  -- STEP 4. Upgrade to a set that encodes invariance along the entire orbit.
  classical
  let Sâˆ : Set (Î©[Î±]) := â‹‚ n : â„•, (shift^[n]) â»Â¹' S
  have hSinf_null : Î¼ Sâˆá¶œ = 0 := by
    have hcompl : Sâˆá¶œ = â‹ƒ n : â„•, (shift^[n]) â»Â¹' Sá¶œ := by
      classical
      simpa [Sâˆ, Set.preimage_compl] using
        (Set.compl_iInter (fun n : â„• => (shift^[n]) â»Â¹' S))
    have hpreimage_null : âˆ€ n : â„•, Î¼ ((shift^[n]) â»Â¹' Sá¶œ) = 0 := by
      intro n
      simpa using ((MeasurePreserving.iterate hÏƒ n).preimage_null hS_null)
    simpa [hcompl] using measure_iUnion_null hpreimage_null
  have hSinf_ae : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ Sâˆ := by
    simpa [ae_iff, Sâˆ] using hSinf_null
  have hSinf_mem : âˆ€ {Ï‰}, Ï‰ âˆˆ Sâˆ â†’ âˆ€ n : â„•, shift^[n] Ï‰ âˆˆ S := by
    intro Ï‰ hÏ‰ n
    have hmem := Set.mem_iInter.mp hÏ‰ n
    exact hmem
  have hSinf_one_step : âˆ€ {Ï‰}, Ï‰ âˆˆ Sâˆ â†’ g (shift Ï‰) = g Ï‰ := by
    intro Ï‰ hÏ‰
    have := hSinf_mem (Ï‰ := Ï‰) hÏ‰ 0
    simpa [S] using this
  have hSinf_forward : âˆ€ {Ï‰}, Ï‰ âˆˆ Sâˆ â†’ shift Ï‰ âˆˆ Sâˆ := by
    intro Ï‰ hÏ‰
    refine Set.mem_iInter.mpr ?_
    intro n
    have := hSinf_mem (Ï‰ := Ï‰) hÏ‰ (n + 1)
    simpa [Function.iterate_succ] using this
  have hSinf_preimage : shift â»Â¹' Sâˆ = Sâˆ := by
    classical
    ext Ï‰; constructor <;> intro hÏ‰
    Â· refine Set.mem_iInter.mpr ?_
      intro n
      have hmem := Set.mem_iInter.mp hÏ‰ (n + 1)
      simpa [Function.iterate_succ] using hmem
    Â· have := Set.mem_iInter.mp hÏ‰ 0
      simpa [Function.iterate_zero] using this
  obtain âŸ¨g', hg'_meas, hAEgg, hshift_g'âŸ© :=
    exists_shiftInvariantRepresentative (Î¼ := Î¼) hÏƒ g hg_meas hshift_g
  have hAEgg' : (fun Ï‰ => g' Ï‰) =áµ[Î¼] g := hAEgg
  have hAEgf : (fun Ï‰ => g' Ï‰) =áµ[Î¼] f := hAEgg'.trans hfg
  have hf_meas : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ :=
    (AEStronglyMeasurable.congr hg'_meas hAEgf)
  exact hf_meas

/-- The fixed-point subspace of the Koopman operator.

This is the closed subspace of LÂ²(Î¼) consisting of equivalence classes of functions
f such that f âˆ˜ shift = f almost everywhere.
-/
def fixedSubspace {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) : Submodule â„ (Lp â„ 2 Î¼) :=
  fixedSpace (koopman shift hÏƒ)

/-- Functions in the fixed-point subspace are exactly those that are a.e. invariant under shift. -/
lemma mem_fixedSubspace_iff {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) (f : Lp â„ 2 Î¼) :
    f âˆˆ fixedSubspace hÏƒ â†” koopman shift hÏƒ f = f := by
  rfl

/-- The orthogonal projection onto the fixed-point subspace exists (as a closed subspace). -/
lemma fixedSubspace_closed {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    IsClosed (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) := by
  classical
  let T := koopman shift hÏƒ
  have hset : (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) =
      (fun f : Lp â„ 2 Î¼ => T f - f) â»Â¹' ({0} : Set (Lp â„ 2 Î¼)) := by
    ext f
    rfl
  have hcont : Continuous fun f : Lp â„ 2 Î¼ => T f - f :=
    (T.continuous.sub continuous_id)
  have hclosed : IsClosed ((fun f : Lp â„ 2 Î¼ => T f - f) â»Â¹'
      ({0} : Set (Lp â„ 2 Î¼))) :=
    IsClosed.preimage hcont isClosed_singleton
  simpa [hset]

/-- Conditional expectation on LÂ² can be viewed as an orthogonal projection.

For a sub-Ïƒ-algebra ğ“–, the conditional expectation condexp[ğ“–] is the orthogonal
projection from LÂ²(Î¼) onto LÂ²(ğ“–), the closed subspace of functions measurable
with respect to ğ“–.

TODO: Use mathlib's condexpL2 once we have the proper sub-Ïƒ-algebra instance.
-/
noncomputable def condexpL2 {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] :
    Lp â„ 2 Î¼ â†’L[â„] Lp â„ 2 Î¼ :=
  ((lpMeas â„ â„ (shiftInvariantSigma (Î± := Î±)) 2 Î¼).subtypeL).comp
    (MeasureTheory.condExpL2 â„ â„ (shiftInvariantSigma_le (Î± := Î±)))

/-- Key theorem: The orthogonal projection onto the fixed-point subspace of the Koopman
operator equals the conditional expectation onto the shift-invariant Ïƒ-algebra.

This is the bridge between ergodic theory (operator fixed points) and probability
(conditional expectation).
-/
theorem proj_eq_condexp {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    âˆƒ (P : Lp â„ 2 Î¼ â†’L[â„] Lp â„ 2 Î¼),
      (âˆ€ f, f âˆˆ fixedSubspace hÏƒ â†’ P f = f) âˆ§
      (âˆ€ f, P f = condexpL2 shiftInvariantSigma f) := by
  refine âŸ¨condexpL2 shiftInvariantSigma, ?_, ?_âŸ©
  Â· intro f hf
    have hfix : koopman shift hÏƒ f = f :=
      (mem_fixedSubspace_iff (hÏƒ := hÏƒ) (f := f)).1 hf
    have hmeas : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ :=
      aestronglyMeasurable_shiftInvariant_of_koopman (hÏƒ := hÏƒ) hfix
    have hf_mem : f âˆˆ lpMeas â„ â„ (shiftInvariantSigma (Î± := Î±)) 2 Î¼ := by
      exact (MeasureTheory.mem_lpMeas_iff_aestronglyMeasurable (m := shiftInvariantSigma)
        (m0 := inferInstance) (Î¼ := Î¼) (p := (2 : â„â‰¥0âˆ)) (f := f)).mpr hmeas
    let fSub : lpMeas â„ â„ (shiftInvariantSigma (Î± := Î±)) 2 Î¼ := âŸ¨f, hf_memâŸ©
    have hproj :
        MeasureTheory.condExpL2 â„ â„ (shiftInvariantSigma_le (Î± := Î±)) f = fSub := by
      simpa [MeasureTheory.condExpL2, fSub]
        using Submodule.orthogonalProjection_mem_subspace_eq_self fSub
    unfold condexpL2
    simpa [fSub, hproj]
  Â· intro f; rfl

/-- The range of conditional expectation onto the invariant Ïƒ-algebra equals
the fixed-point subspace. -/
lemma range_condexp_eq_fixedSubspace {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    Set.range (condexpL2 shiftInvariantSigma) =
    (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) := by
  classical
  ext f
  constructor
  Â· -- (âŠ†) Range of condexpL2 âŠ† fixedSubspace
    intro âŸ¨g, hgâŸ©
    rw [â† hg]
    -- condexpL2 g is measurable w.r.t. shiftInvariantSigma
    -- hence invariant under shift, so Koopman fixes it
    classical
    have hmeas :
        AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)]
          (condexpL2 shiftInvariantSigma g : Î©[Î±] â†’ â„) Î¼ := by
      simpa using
        (lpMeas.aestronglyMeasurable
          (MeasureTheory.condExpL2 â„ â„ (shiftInvariantSigma_le (Î± := Î±)) g))
    have hkoop :=
      koopman_eq_self_of_shiftInvariant (hÏƒ := hÏƒ) hmeas
    exact (mem_fixedSubspace_iff (hÏƒ := hÏƒ)
        (f := condexpL2 shiftInvariantSigma g)).mpr hkoop
  Â· -- (âŠ‡) fixedSubspace âŠ† Range of condexpL2
    intro hf
    -- If f is fixed by Koopman, then f is shift-invariant a.e.
    -- hence measurable w.r.t. shiftInvariantSigma
    -- so f = condexpL2 f
    use f
    have hfix : koopman shift hÏƒ f = f :=
      (mem_fixedSubspace_iff (hÏƒ := hÏƒ) (f := f)).1 hf
    have hmeas : AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)] f Î¼ :=
      aestronglyMeasurable_shiftInvariant_of_koopman (hÏƒ := hÏƒ) hfix
    have hf_mem : f âˆˆ lpMeas â„ â„ (shiftInvariantSigma (Î± := Î±)) 2 Î¼ :=
      (MeasureTheory.mem_lpMeas_iff_aestronglyMeasurable (m := shiftInvariantSigma)
        (m0 := inferInstance) (Î¼ := Î¼) (p := (2 : â„â‰¥0âˆ)) (f := f)).mpr hmeas
    let fSub : lpMeas â„ â„ (shiftInvariantSigma (Î± := Î±)) 2 Î¼ := âŸ¨f, hf_memâŸ©
    have hproj :
        MeasureTheory.condExpL2 â„ â„ (shiftInvariantSigma_le (Î± := Î±)) f = fSub := by
      simpa [MeasureTheory.condExpL2, fSub]
        using Submodule.orthogonalProjection_mem_subspace_eq_self fSub
    unfold condexpL2
    simp [fSub, hproj]

end Exchangeability.DeFinetti
