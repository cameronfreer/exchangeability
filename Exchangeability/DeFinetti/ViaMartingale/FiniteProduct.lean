/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.Probability.ConditionalExpectation
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Exchangeability.Contractability
import Exchangeability.Probability.CondExp
import Exchangeability.Probability.Martingale
import Exchangeability.Probability.MeasureKernels
import Exchangeability.Tail.TailSigma
import Exchangeability.DeFinetti.ViaMartingale.ShiftOperations
import Exchangeability.DeFinetti.ViaMartingale.FutureFiltration
import Exchangeability.DeFinetti.ViaMartingale.FiniteCylinders
import Exchangeability.DeFinetti.ViaMartingale.CondExpConvergence
import Exchangeability.DeFinetti.ViaMartingale.Factorization
import Exchangeability.PathSpace.CylinderHelpers

/-!
# Finite Product Formula

This file proves the finite product formula: for a contractable process X,
the joint law of any strictly increasing subsequence equals the independent
product under the directing measure.

## Main results

* `measure_pi_univ_pi` - Product measures evaluate on rectangles as a finite product
* `bind_apply_univ_pi` - Bind computation on rectangles for finite product measures
* `finite_product_formula_id` - Core case: product formula for identity indexing
* `finite_product_formula_strictMono` - Product formula for strictly monotone subsequences
* `finite_product_formula` - Main wrapper theorem

## Proof strategy

1. Show equality on rectangles using factorization machinery
2. Use reverse martingale convergence for each coordinate
3. Extend from rectangles to full Ïƒ-algebra via Ï€-Î» theorem
4. Reduce strict-monotone case to identity case via contractability

## References

* Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Chapter 1, Theorem 1.1
-/

noncomputable section
open scoped MeasureTheory ProbabilityTheory Topology
open MeasureTheory Filter

namespace Exchangeability.DeFinetti.ViaMartingale

open Exchangeability.PathSpace

variable {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]

/-! ### Finite-dimensional product formula -/

/-! #### Helper lemmas for the product formula -/

/-- Convert lintegral of ENNReal product of probability measures to ofReal of real integral.

For probability measures Î½ Ï‰, the finite product âˆáµ¢ Î½ Ï‰ (Cáµ¢) can be computed as either:
- âˆ«â» Ï‰, (âˆáµ¢ Î½ Ï‰ (Cáµ¢)) âˆ‚Î¼ (as ENNReal)
- ENNReal.ofReal (âˆ« Ï‰, (âˆáµ¢ (Î½ Ï‰ (Cáµ¢)).toReal) âˆ‚Î¼) (as Real via toReal)

This helper establishes their equality, which is used in the finite product formula proof. -/
lemma lintegral_prod_prob_eq_ofReal_integral
    {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼]
    {m : â„•} (Î½ : Î© â†’ Measure Î±) [âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰)]
    (hÎ½_meas : âˆ€ B : Set Î±, MeasurableSet B â†’ Measurable (fun Ï‰ => Î½ Ï‰ B))
    (C : Fin m â†’ Set Î±) (hC : âˆ€ i, MeasurableSet (C i)) :
    âˆ«â» Ï‰, (âˆ i : Fin m, Î½ Ï‰ (C i)) âˆ‚Î¼
      = ENNReal.ofReal (âˆ« Ï‰, (âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal) âˆ‚Î¼) := by
  -- Each factor Î½ Ï‰ (C i) â‰¤ 1, hence the product p(Ï‰) â‰¤ 1 < âˆ and
  -- p(Ï‰) = ENNReal.ofReal (p(Ï‰).toReal). Use `lintegral_ofReal`.
  have h_point :
      (fun Ï‰ => (âˆ i : Fin m, Î½ Ï‰ (C i)))
        = (fun Ï‰ => ENNReal.ofReal (âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal)) := by
    funext Ï‰
    -- turn each factor into ofReal of its toReal (since it's â‰¤ 1 < âˆ)
    have hfactor :
        âˆ€ i : Fin m, Î½ Ï‰ (C i) = ENNReal.ofReal ((Î½ Ï‰ (C i)).toReal) := by
      intro i
      -- 0 â‰¤ Î¼(C) â‰¤ 1 â‡’ finite â‡’ ofReal_toReal
      have hle1 : Î½ Ï‰ (C i) â‰¤ 1 := prob_le_one
      have hfin : Î½ Ï‰ (C i) â‰  âŠ¤ := ne_of_lt (lt_of_le_of_lt hle1 ENNReal.one_lt_top)
      exact (ENNReal.ofReal_toReal hfin).symm
    -- product of ofReals = ofReal of product
    rw [Finset.prod_congr rfl (fun i _ => hfactor i)]
    exact (ENNReal.ofReal_prod_of_nonneg (fun i _ => ENNReal.toReal_nonneg)).symm
  -- now apply lintegral_ofReal
  rw [h_point]
  have h_nonneg : âˆ€áµ Ï‰ âˆ‚Î¼, 0 â‰¤ âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal :=
    ae_of_all _ fun _ => Finset.prod_nonneg fun _ _ => ENNReal.toReal_nonneg
  -- Step 1: Show measurability of the product function
  let f : Î© â†’ â„ := fun Ï‰ => âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal
  have h_meas : Measurable f := by
    -- Finite product of measurable functions is measurable
    apply Finset.measurable_prod
    intro i _
    -- Î½ Â· (C i) is measurable by hÎ½_meas, and toReal is continuous hence measurable
    exact Measurable.ennreal_toReal (hÎ½_meas (C i) (hC i))
  -- Step 2: Show integrability (bounded by 1) via integrable_of_bounded_on_prob
  have h_integrable : Integrable f Î¼ := by
    apply integrable_of_bounded_on_prob h_meas
    apply ae_of_all Î¼; intro Ï‰
    have h_nonneg_Ï‰ : 0 â‰¤ f Ï‰ :=
      Finset.prod_nonneg (fun i _ => ENNReal.toReal_nonneg (a := Î½ Ï‰ (C i)))
    rw [Real.norm_of_nonneg h_nonneg_Ï‰]
    have h_bound : âˆ€ i : Fin m, (Î½ Ï‰ (C i)).toReal â‰¤ 1 := fun i => by
      have h1 : Î½ Ï‰ (C i) â‰¤ 1 := prob_le_one
      rw [â† ENNReal.toReal_one]
      exact (ENNReal.toReal_le_toReal (ne_top_of_le_ne_top ENNReal.one_ne_top h1)
        ENNReal.one_ne_top).mpr h1
    calc f Ï‰ â‰¤ âˆ _i : Fin m, (1 : â„) :=
            Finset.prod_le_prod (fun i _ => ENNReal.toReal_nonneg) (fun i _ => h_bound i)
      _ = 1 := by simp
  -- Step 3: Apply ofReal_integral_eq_lintegral_ofReal
  symm
  exact ofReal_integral_eq_lintegral_ofReal h_integrable h_nonneg

/-! #### Core lemmas -/

/-- On a finite index type, product measures evaluate on rectangles as a finite product. -/
lemma measure_pi_univ_pi
    {Î± : Type*} [MeasurableSpace Î±] [StandardBorelSpace Î±]
    {m : â„•} (Î¼i : Fin m â†’ Measure Î±) [âˆ€ i, SigmaFinite (Î¼i i)]
    (C : Fin m â†’ Set Î±) :
  (Measure.pi (fun i : Fin m => Î¼i i)) (Set.univ.pi C)
    = âˆ i : Fin m, Î¼i i (C i) :=
  Measure.pi_pi Î¼i C

/-- Bind computation on rectangles for finite product measures. -/
lemma bind_apply_univ_pi
    {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±] [StandardBorelSpace Î±]
    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼]
    {m : â„•}
    (Î½ : Î© â†’ Measure Î±) [âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰)]
    (hÎ½_meas : âˆ€ (B : Set Î±), MeasurableSet B â†’ Measurable (fun Ï‰ => Î½ Ï‰ B))
    (C : Fin m â†’ Set Î±) (hC : âˆ€ i, MeasurableSet (C i)) :
  (Î¼.bind (fun Ï‰ => Measure.pi (fun _ : Fin m => Î½ Ï‰))) (Set.univ.pi C)
    = âˆ«â» Ï‰, (âˆ i : Fin m, Î½ Ï‰ (C i)) âˆ‚Î¼ := by
  -- Step 1: Apply Measure.bind_apply to get LHS = âˆ«â» Ï‰, (Measure.pi ...) (Set.univ.pi C) âˆ‚Î¼
  -- We need AEMeasurability of the kernel Ï‰ â†¦ Measure.pi (fun _ => Î½ Ï‰)
  have h_rect_meas : MeasurableSet (Set.univ.pi C) := by
    classical
    exact MeasurableSet.univ_pi hC

  -- AEMeasurability of the product measure kernel (using MeasureKernels.aemeasurable_measure_pi)
  have h_aemeas : AEMeasurable (fun Ï‰ => Measure.pi (fun _ : Fin m => Î½ Ï‰)) Î¼ :=
    aemeasurable_measure_pi Î½ (fun Ï‰ => inferInstance) hÎ½_meas

  calc (Î¼.bind (fun Ï‰ => Measure.pi (fun _ : Fin m => Î½ Ï‰))) (Set.univ.pi C)
      = âˆ«â» Ï‰, (Measure.pi (fun _ : Fin m => Î½ Ï‰)) (Set.univ.pi C) âˆ‚Î¼ :=
          Measure.bind_apply h_rect_meas h_aemeas
    _ = âˆ«â» Ï‰, (âˆ i : Fin m, Î½ Ï‰ (C i)) âˆ‚Î¼ := by
          -- Step 2: Use measure_pi_univ_pi to convert the product measure on a rectangle
          congr 1
          funext Ï‰
          exact measure_pi_univ_pi (fun _ => Î½ Ï‰) C

/-- **Finite product formula for the first m coordinates** (identity case).

This is the core case where we prove the product formula for `(Xâ‚€, Xâ‚, ..., X_{m-1})`.
The general case for strictly monotone subsequences reduces to this via contractability.

**Important**: The statement with arbitrary `k : Fin m â†’ â„•` is **false** if `k` has duplicates
(e.g., `(Xâ‚€, Xâ‚€)` is not an independent product unless Î½ is Dirac). We avoid this by:
1. Proving the identity case here (no index map)
2. Reducing strict-monotone subsequences to the identity case via contractability

**Proof strategy:**
1. Show equality on rectangles using factorization machinery
2. Extend from rectangles to full Ïƒ-algebra via Ï€-Î» theorem -/
lemma finite_product_formula_id
    [StandardBorelSpace Î©]
    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼]
    {Î± : Type*} [MeasurableSpace Î±] [StandardBorelSpace Î±] [Nonempty Î±]
    (X : â„• â†’ Î© â†’ Î±)
    (hX : Contractable Î¼ X)
    (hX_meas : âˆ€ n, Measurable (X n))
    (Î½ : Î© â†’ Measure Î±)
    (hÎ½_prob : âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰))
    (hÎ½_meas : âˆ€ B : Set Î±, MeasurableSet B â†’ Measurable (fun Ï‰ => Î½ Ï‰ B))
    (hÎ½_law : âˆ€ n B, MeasurableSet B â†’
        (fun Ï‰ => (Î½ Ï‰ B).toReal) =áµ[Î¼] Î¼[Set.indicator B (fun _ => (1 : â„)) âˆ˜ (X n) | tailSigma X])
    (m : â„•) :
    Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼
      = Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) := by
  classical
  -- Ï€-system of rectangles in (Fin m â†’ Î±)
  let Rectangles : Set (Set (Fin m â†’ Î±)) :=
    {S | âˆƒ (C : Fin m â†’ Set Î±), (âˆ€ i, MeasurableSet (C i)) âˆ§ S = Set.univ.pi C}

  -- Characterization: Rectangles = {S | âˆƒ B, ...} (used multiple times below)
  have Rectangles_def : Rectangles = {S : Set (Fin m â†’ Î±) | âˆƒ (B : Fin m â†’ Set Î±),
      (âˆ€ i, MeasurableSet (B i)) âˆ§ S = {x | âˆ€ i, x i âˆˆ B i}} := by
    ext S; simp only [Rectangles, Set.mem_setOf_eq]
    constructor <;> (intro âŸ¨B, hB, hSâŸ©; refine âŸ¨B, hB, ?_âŸ©; rw [hS]; ext x; simp)

  -- 1) Rectangles form a Ï€-system and generate the Î  Ïƒ-algebra
  have h_pi : IsPiSystem Rectangles := by
    rw [Rectangles_def]; exact rectangles_isPiSystem (m := m) (Î± := Î±)

  have h_gen : (inferInstance : MeasurableSpace (Fin m â†’ Î±))
      = MeasurableSpace.generateFrom Rectangles := by
    rw [Rectangles_def]; exact rectangles_generate_pi_sigma (m := m) (Î± := Î±)

  -- 2) Show both measures agree on rectangles
  have h_agree :
    âˆ€ s âˆˆ Rectangles,
      (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) s
        = (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) s := by
    rintro s âŸ¨C, hC, rflâŸ©

    -- LHS: map-measure on a rectangle = integral of the product indicator
    have hL :
      (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) (Set.univ.pi C)
        = ENNReal.ofReal (âˆ« Ï‰, indProd X m C Ï‰ âˆ‚Î¼) := by
      -- Preimage of rectangle equals firstRCylinder
      have hpre :
        ((fun Ï‰ => fun i : Fin m => X i Ï‰) â»Â¹' (Set.univ.pi C))
          = firstRCylinder X m C := by
        ext Ï‰; simp [firstRCylinder]
      -- indProd equals indicator of firstRCylinder
      have hind := indProd_eq_firstRCylinder_indicator X m C
      -- Measure equals integral via indicator
      have h_meas_eq : Î¼ (firstRCylinder X m C)
          = ENNReal.ofReal (âˆ« Ï‰, indProd X m C Ï‰ âˆ‚Î¼) := by
        rw [hind]
        -- For probability measure: Î¼ S = ENNReal.ofReal ((Î¼ S).toReal)
        rw [â† ENNReal.ofReal_toReal (measure_ne_top Î¼ _)]
        congr 1
        -- âˆ« indicator S 1 = Measure.real Î¼ S = (Î¼ S).toReal
        have h_int := @integral_indicator_one _ _ Î¼ (firstRCylinder X m C)
          (firstRCylinder_measurable_ambient X m C hX_meas hC)
        simp only [Measure.real] at h_int
        exact h_int.symm
      -- Apply to map measure
      calc (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) (Set.univ.pi C)
          = Î¼ ((fun Ï‰ => fun i : Fin m => X i Ï‰) â»Â¹' (Set.univ.pi C)) := by
              -- Standard: (map f Î¼) S = Î¼ (fâ»Â¹ S) for measurable f and S
              refine Measure.map_apply ?_ ?_
              Â· fun_prop (disch := measurability)
              Â· -- Set.univ.pi C is measurable in product Ïƒ-algebra
                classical
                apply MeasurableSet.univ_pi
                exact hC
        _ = Î¼ (firstRCylinder X m C) := by rw [hpre]
        _ = ENNReal.ofReal (âˆ« Ï‰, indProd X m C Ï‰ âˆ‚Î¼) := h_meas_eq

    -- Use factorization machinery
    have h_fact : âˆ€ M â‰¥ m,
        Î¼[indProd X m C | futureFiltration X M] =áµ[Î¼]
        (fun Ï‰ => âˆ i : Fin m,
          Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | futureFiltration X M] Ï‰) :=
      fun M hMm => finite_level_factorization X hX hX_meas m C hC M hMm

    -- Reverse martingale convergence for each coordinate
    have h_conv : âˆ€ i : Fin m,
        (âˆ€áµ Ï‰ âˆ‚Î¼, Tendsto (fun M =>
          Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | futureFiltration X M] Ï‰)
          atTop
          (ğ“ (Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | tailSigma X] Ï‰))) := by
      intro i
      have := Exchangeability.Probability.condExp_tendsto_iInf
        (Î¼ := Î¼) (ğ”½ := futureFiltration X)
        (h_filtration := futureFiltration_antitone X)
        (h_le := fun n => futureFiltration_le X n hX_meas)
        (f := (Set.indicator (C i) (fun _ => (1:â„))) âˆ˜ X 0)
        (h_f_int := by
          simpa using
            Exchangeability.Probability.integrable_indicator_comp
              (Î¼ := Î¼) (X := X 0) (hX := hX_meas 0) (hB := hC i))
      simpa [â† tailSigmaFuture_eq_iInf, tailSigmaFuture_eq_tailSigma] using this

    -- Tail factorization for the product indicator (a.e. equality)
    have h_tail : Î¼[indProd X m C | tailSigma X] =áµ[Î¼]
        (fun Ï‰ => âˆ i : Fin m,
          Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | tailSigma X] Ï‰) :=
      tail_factorization_from_future X hX_meas m C hC h_fact h_conv

    -- Integrate both sides; tower property: âˆ« Î¼[g|tail] = âˆ« g
    -- Tower property: âˆ« f = âˆ« E[f|Ï„] and use h_tail
    have h_int_tail : âˆ« Ï‰, indProd X m C Ï‰ âˆ‚Î¼
        = âˆ« Ï‰, (âˆ i : Fin m,
            Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | tailSigma X] Ï‰) âˆ‚Î¼ :=
      ((integral_congr_ae h_tail.symm).trans (integral_condExp (tailSigma_le X hX_meas))).symm

    -- Replace each conditional expectation by Î½ Ï‰ (C i).toReal using hÎ½_law
    have h_swap : (fun Ï‰ => âˆ i : Fin m,
          Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | tailSigma X] Ï‰)
        =áµ[Î¼] (fun Ï‰ => âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal) := by
      -- For each coordinate i, we have a.e. equality from hÎ½_law
      have h_each : âˆ€ i : Fin m,
          (Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | tailSigma X])
            =áµ[Î¼] (fun Ï‰ => (Î½ Ï‰ (C i)).toReal) :=
        fun i => (hÎ½_law 0 (C i) (hC i)).symm
      -- Combine using Finset.prod over a.e. equal functions
      -- The product of a.e. equal functions is a.e. equal
      have h_all := ae_all_iff.mpr h_each
      filter_upwards [h_all] with Ï‰ hÏ‰
      -- Both sides are products over Fin m, equal pointwise
      exact Finset.prod_congr rfl (fun i _ => hÏ‰ i)

    -- RHS (mixture) on rectangle:
    -- (â˜…) â€” bind on rectangles reduces to a lintegral of a finite product
    have h_bind :
      (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) (Set.univ.pi C)
        = âˆ«â» Ï‰, (âˆ i : Fin m, Î½ Ï‰ (C i)) âˆ‚Î¼ :=
      bind_apply_univ_pi Î½ hÎ½_meas C hC

    -- (â˜…â˜…) â€” turn lintegral of a product of ENNReal probabilities into `ofReal` of a real integral
    have h_toReal :
      âˆ«â» Ï‰, (âˆ i : Fin m, Î½ Ï‰ (C i)) âˆ‚Î¼
        = ENNReal.ofReal (âˆ« Ï‰, (âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal) âˆ‚Î¼) :=
      lintegral_prod_prob_eq_ofReal_integral Î½ hÎ½_meas C hC

    -- (â˜…â˜…â˜…) â€” compute mixture on rectangle as `ofReal âˆ« â€¦` to match the LHS computation chain
    have hR :
      (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) (Set.univ.pi C)
        = ENNReal.ofReal (âˆ« Ï‰, (âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal) âˆ‚Î¼) := by
      rw [h_bind, h_toReal]

    -- (â˜…â˜…â˜…â˜…) â€” assemble the chain and finish equality on rectangles
    calc (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) (Set.univ.pi C)
        = ENNReal.ofReal (âˆ« Ï‰, indProd X m C Ï‰ âˆ‚Î¼) := hL
      _ = ENNReal.ofReal (âˆ« Ï‰, (âˆ i : Fin m,
            Î¼[Set.indicator (C i) (fun _ => (1:â„)) âˆ˜ (X 0) | tailSigma X] Ï‰) âˆ‚Î¼) := by
            rw [h_int_tail]
      _ = ENNReal.ofReal (âˆ« Ï‰, (âˆ i : Fin m, (Î½ Ï‰ (C i)).toReal) âˆ‚Î¼) := by
            congr 1; exact integral_congr_ae h_swap
      _ = (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) (Set.univ.pi C) := hR.symm

  -- Ï€â€“Î» extension to all measurable sets (your standard pattern)
  -- Both measures are finite (indeed probability); you can either show `univ = 1` on both
  -- or reuse the general "iUnion = univ" cover with `IsFiniteMeasure`.
  have h_univ :
      (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) Set.univ
        = (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) Set.univ := by
    -- both are probabilities
    haveI : IsProbabilityMeasure (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) := by
      constructor
      have hme : Measurable (fun Ï‰ => fun i : Fin m => X i Ï‰) := by
        fun_prop (disch := measurability)
      rw [Measure.map_apply hme MeasurableSet.univ]
      have : (fun Ï‰ => fun i : Fin m => X i Ï‰) â»Â¹' Set.univ = Set.univ := by ext; simp
      rw [this]
      exact measure_univ
    haveI : IsProbabilityMeasure (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) := by
      constructor
      -- Need to show: (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) Set.univ = 1
      -- Strategy: bind of constant 1 over probability measure Î¼ equals 1
      -- First need AEMeasurability of the kernel (using MeasureKernels.aemeasurable_measure_pi)
      have h_aemeas : AEMeasurable (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) Î¼ :=
        aemeasurable_measure_pi Î½ hÎ½_prob hÎ½_meas
      rw [Measure.bind_apply MeasurableSet.univ h_aemeas]
      -- âˆ«â» Ï‰, (Measure.pi (fun _ : Fin m => Î½ Ï‰)) Set.univ âˆ‚Î¼
      -- For each Ï‰, Measure.pi is a product of probability measures, so it's a probability measure
      have h_pi_prob : âˆ€ Ï‰, (Measure.pi (fun _ : Fin m => Î½ Ï‰)) Set.univ = 1 := fun Ï‰ =>
        haveI := hÎ½_prob Ï‰; measure_univ
      -- Integrate constant 1: âˆ«â» Ï‰, 1 âˆ‚Î¼ = 1 * Î¼ Set.univ = 1
      simp only [h_pi_prob]
      rw [lintegral_const]
      simp [measure_univ]
    -- Now both are probability measures, so both equal 1 on univ
    calc (Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼) Set.univ
        = 1 := measure_univ
      _ = (Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰)) Set.univ := measure_univ.symm

  -- Ï€â€“Î» theorem: equality on the generating Ï€-system + equality on univ â‡’ equality of measures
  -- Since both are probability measures and agree on rectangles, they are equal

  -- Define covering family (constant sequence of Set.univ)
  let Bseq : â„• â†’ Set (Fin m â†’ Î±) := fun _ => Set.univ

  have h1B : â‹ƒ n, Bseq n = Set.univ := by
    simp only [Bseq, Set.iUnion_const]

  have h2B : âˆ€ n, Bseq n âˆˆ Rectangles := by
    intro n
    refine âŸ¨fun _ => Set.univ, fun _ => MeasurableSet.univ, ?_âŸ©
    ext f; simp only [Bseq, Set.mem_univ, Set.mem_univ_pi]; tauto

  have hÎ¼B : âˆ€ n, Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼ (Bseq n) â‰  âŠ¤ := by
    intro n
    simp only [Bseq]
    exact measure_ne_top _ Set.univ

  -- Apply Measure.ext_of_generateFrom_of_iUnion
  exact Measure.ext_of_generateFrom_of_iUnion
    Rectangles Bseq h_gen h_pi h1B h2B hÎ¼B h_agree

/-- **Finite product formula for strictly monotone subsequences**.

For any strictly increasing subsequence `k`, the joint law of `(X_{k(0)}, ..., X_{k(m-1)})`
equals the independent product under the directing measure Î½.

This reduces to the identity case via contractability. -/
lemma finite_product_formula_strictMono
    [StandardBorelSpace Î©]
    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼]
    {Î± : Type*} [MeasurableSpace Î±] [StandardBorelSpace Î±] [Nonempty Î±]
    (X : â„• â†’ Î© â†’ Î±)
    (hX : Contractable Î¼ X)
    (hX_meas : âˆ€ n, Measurable (X n))
    (Î½ : Î© â†’ Measure Î±)
    (hÎ½_prob : âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰))
    (hÎ½_meas : âˆ€ B : Set Î±, MeasurableSet B â†’ Measurable (fun Ï‰ => Î½ Ï‰ B))
    (hÎ½_law : âˆ€ n B, MeasurableSet B â†’
        (fun Ï‰ => (Î½ Ï‰ B).toReal) =áµ[Î¼] Î¼[Set.indicator B (fun _ => (1 : â„)) âˆ˜ (X n) | tailSigma X])
    (m : â„•) (k : Fin m â†’ â„•) (hk : StrictMono k) :
    Measure.map (fun Ï‰ => fun i : Fin m => X (k i) Ï‰) Î¼
      = Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) := by
  classical
  -- Contractability gives equality with the identity map
  calc
    Measure.map (fun Ï‰ => fun i : Fin m => X (k i) Ï‰) Î¼
        = Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼ := by simpa using hX m k hk
    _   = Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) :=
          finite_product_formula_id X hX hX_meas Î½ hÎ½_prob hÎ½_meas hÎ½_law m

/-- **Finite product formula** for strictly monotone subsequences.

For any strictly increasing subsequence `k`, the joint law of
`(X_{k(0)}, ..., X_{k(m-1)})` equals the independent product under the
directing measure `Î½`. This wraps `finite_product_formula_strictMono`. -/
lemma finite_product_formula
    [StandardBorelSpace Î©]
    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼]
    {Î± : Type*} [MeasurableSpace Î±] [StandardBorelSpace Î±] [Nonempty Î±]
    (X : â„• â†’ Î© â†’ Î±)
    (hX : Contractable Î¼ X)
    (hX_meas : âˆ€ n, Measurable (X n))
    (Î½ : Î© â†’ Measure Î±)
    (hÎ½_prob : âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰))
    (hÎ½_meas : âˆ€ B : Set Î±, MeasurableSet B â†’ Measurable (fun Ï‰ => Î½ Ï‰ B))
    (hÎ½_law : âˆ€ n B, MeasurableSet B â†’
        (fun Ï‰ => (Î½ Ï‰ B).toReal) =áµ[Î¼] Î¼[Set.indicator B (fun _ => (1 : â„)) âˆ˜ (X n) | tailSigma X])
    (m : â„•) (k : Fin m â†’ â„•) (hk : StrictMono k) :
  Measure.map (fun Ï‰ => fun i : Fin m => X (k i) Ï‰) Î¼
    = Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) :=
  finite_product_formula_strictMono X hX hX_meas Î½ hÎ½_prob hÎ½_meas hÎ½_law m k hk

/-- **Convenience identity case** (useful for tests and bridging). -/
lemma finite_product_formula_id'
    [StandardBorelSpace Î©]
    {Î¼ : Measure Î©} [IsProbabilityMeasure Î¼]
    {Î± : Type*} [MeasurableSpace Î±] [StandardBorelSpace Î±] [Nonempty Î±]
    (X : â„• â†’ Î© â†’ Î±)
    (hX : Contractable Î¼ X)
    (hX_meas : âˆ€ n, Measurable (X n))
    (Î½ : Î© â†’ Measure Î±)
    (hÎ½_prob : âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰))
    (hÎ½_meas : âˆ€ B : Set Î±, MeasurableSet B â†’ Measurable (fun Ï‰ => Î½ Ï‰ B))
    (hÎ½_law : âˆ€ n B, MeasurableSet B â†’
        (fun Ï‰ => (Î½ Ï‰ B).toReal) =áµ[Î¼] Î¼[Set.indicator B (fun _ => (1 : â„)) âˆ˜ (X n) | tailSigma X])
    (m : â„•) :
  Measure.map (fun Ï‰ => fun i : Fin m => X i Ï‰) Î¼
    = Î¼.bind (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) :=
  finite_product_formula X hX hX_meas Î½ hÎ½_prob hÎ½_meas hÎ½_law m (fun i => (i : â„•))
    fun _ _ => id

end Exchangeability.DeFinetti.ViaMartingale
