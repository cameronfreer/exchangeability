/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Exchangeability.Tail.TailSigma
import Exchangeability.DeFinetti.MartingaleHelpers
import Exchangeability.DeFinetti.ViaMartingale.ShiftOperations

/-!
# Reverse Filtration and Tail Ïƒ-Algebra

This file defines the reverse filtration (decreasing Ïƒ-algebras generated by shifts)
and the tail Ïƒ-algebra (their intersection).

## Main definitions

* `revFiltration X m` - Ïƒ(Î¸â‚˜ X) = Ïƒ(Ï‰ â†¦ (n â†¦ X (m+n) Ï‰))
* `tailSigma X` - â‹‚â‚™ Ïƒ(Xâ‚™, Xâ‚™â‚Šâ‚, ...), the tail Ïƒ-algebra

## Main results

* `revFiltration_le` - revFiltration is a sub-Ïƒ-algebra of the ambient
* `revFiltration_antitone` - revFiltration is decreasing in m
* `tailSigma_eq_canonical` - matches `Tail.tailProcess`

These are extracted from ViaMartingale.lean to enable modular imports.
-/

noncomputable section
open scoped MeasureTheory
open MeasureTheory

namespace Exchangeability.DeFinetti.ViaMartingale

variable {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]

open MartingaleHelpers

/-! ### Reverse Filtration -/

/-- ð”½â‚˜ := Ïƒ(Î¸â‚˜ X) = Ïƒ(Ï‰ â†¦ (n â†¦ X (m+n) Ï‰)). -/
abbrev revFiltration (X : â„• â†’ Î© â†’ Î±) (m : â„•) : MeasurableSpace Î© :=
  MeasurableSpace.comap (shiftRV X m) inferInstance

omit [MeasurableSpace Î©] in
@[simp]
lemma revFiltration_zero (X : â„• â†’ Î© â†’ Î±) :
    revFiltration X 0 = MeasurableSpace.comap (path X) inferInstance := by
  simp only [revFiltration, shiftRV_zero]

lemma revFiltration_le (X : â„• â†’ Î© â†’ Î±) (hX : âˆ€ n, Measurable (X n)) (m : â„•) :
    revFiltration X m â‰¤ (inferInstance : MeasurableSpace Î©) :=
  MeasurableSpace.comap_le_iff_le_map.mpr fun _ hs =>
    (measurable_pi_iff.mpr fun n => hX (m + n)) hs

/-! ### Tail Ïƒ-Algebra -/

/-- The tail Ïƒ-algebra for a process X: â‹‚â‚™ Ïƒ(Xâ‚™, Xâ‚™â‚Šâ‚, ...). -/
def tailSigma (X : â„• â†’ Î© â†’ Î±) : MeasurableSpace Î© :=
  â¨… m, revFiltration X m

omit [MeasurableSpace Î©] in
@[simp]
lemma tailSigma_eq_iInf_rev (X : â„• â†’ Î© â†’ Î±) :
    tailSigma X = â¨… m, revFiltration X m := rfl

omit [MeasurableSpace Î©] in
/-- Bridge to canonical tail definition: ViaMartingale's `revFiltration` matches the pattern
    required by `Tail.tailProcess_eq_iInf_revFiltration`. -/
lemma revFiltration_eq_tailFamily (X : â„• â†’ Î© â†’ Î±) (m : â„•) :
    revFiltration X m =
    â¨† k : â„•, MeasurableSpace.comap (fun Ï‰ => X (m + k) Ï‰) inferInstance := by
  -- Unfold revFiltration: Ïƒ(shiftRV X m) = Ïƒ(Ï‰ â†¦ (n â†¦ X(m+n) Ï‰))
  simp only [revFiltration]
  -- The product Ïƒ-algebra on (â„• â†’ Î±) equals â¨† k, Ïƒ(eval_k)
  conv_lhs => rw [show (inferInstance : MeasurableSpace (â„• â†’ Î±)) = MeasurableSpace.pi from rfl]
  -- Expand pi as supremum of coordinate comaps
  rw [show MeasurableSpace.pi = â¨† k, MeasurableSpace.comap (fun f : â„• â†’ Î± => f k) inferInstance from rfl]
  -- Push comap through supremum: comap f (â¨† Ïƒáµ¢) = â¨† comap f Ïƒáµ¢
  rw [MeasurableSpace.comap_iSup]
  -- Simplify: comap (shiftRV X m) (comap eval_k) = comap (eval_k âˆ˜ shiftRV X m)
  congr 1; funext k; rw [MeasurableSpace.comap_comp]; rfl

omit [MeasurableSpace Î©] in
/-- ViaMartingale's `tailSigma` equals the canonical `Tail.tailProcess`. -/
lemma tailSigma_eq_canonical (X : â„• â†’ Î© â†’ Î±) :
    tailSigma X = Exchangeability.Tail.tailProcess X := by
  unfold tailSigma
  exact (Exchangeability.Tail.tailProcess_eq_iInf_revFiltration X revFiltration (revFiltration_eq_tailFamily X)).symm

/-! ### Monotonicity -/

lemma revFiltration_antitone (X : â„• â†’ Î© â†’ Î±) :
    Antitone (revFiltration X) := by
  intro m n hmn
  -- Need to show: revFiltration X n â‰¤ revFiltration X m when m â‰¤ n
  -- Strategy: shiftRV X n = shiftSeq (n - m) âˆ˜ shiftRV X m
  simp only [revFiltration]
  let k := n - m
  -- Show shiftRV X n = shiftSeq k âˆ˜ shiftRV X m
  have h_comp : shiftRV X n = shiftSeq k âˆ˜ shiftRV X m := by
    funext Ï‰ i
    simp only [shiftRV, shiftSeq, Function.comp_apply]
    congr 1
    omega
  rw [h_comp]
  exact comap_comp_le (shiftRV X m) (shiftSeq k) measurable_shiftSeq

end Exchangeability.DeFinetti.ViaMartingale
