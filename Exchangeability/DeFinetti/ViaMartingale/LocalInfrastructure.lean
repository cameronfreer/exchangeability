/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Constructions.Cylinders
import Exchangeability.DeFinetti.MartingaleHelpers
import Exchangeability.Probability.CondExp
import Exchangeability.Probability.CondIndep

/-!
# Local Infrastructure Lemmas for ViaMartingale

This file contains helper lemmas that unblock the martingale approach proof by providing
targeted results that should eventually be contributed to mathlib. Each is marked with
its intended mathlib home.

## Main sections

* `PiFiniteProjections` - σ-algebra structure of infinite product spaces
* `ProbabilityMeasureHelpers` - Integrability and bounds on probability spaces
* `CondDistribUniqueness` - Conditional distribution uniqueness under factorization
* `ConditionalIndependence` - Conditional independence projection lemmas

These lemmas are extracted from ViaMartingale.lean to enable modular imports.
-/

noncomputable section
open scoped MeasureTheory
open MeasureTheory Filter

namespace Exchangeability.DeFinetti.ViaMartingale

/-! ### Pi-system and Finite Projections -/

section PiFiniteProjections

/-- The σ-algebra on `ℕ → α` is contained in the supremum of σ-algebras pulled
back by finite-coordinate projections. This is the ≤ direction we need for
filtration arguments. -/
lemma measurableSpace_pi_nat_le_iSup_fin {α : Type*} [MeasurableSpace α] :
    (inferInstance : MeasurableSpace (ℕ → α))
      ≤ ⨆ k : ℕ,
          MeasurableSpace.comap (fun f : ℕ → α => fun i : Fin k => f i) inferInstance := by
  classical
  -- Use the fact that Pi measurable space is generated by cylinder sets
  -- which depend only on finitely many coordinates
  rw [← MeasureTheory.generateFrom_measurableCylinders]
  -- Show generateFrom(cylinders) ≤ ⨆ finite comaps
  apply MeasurableSpace.generateFrom_le
  intro s hs
  -- s is a cylinder, so ∃ finite t, S such that s = cylinder t S
  obtain ⟨t, S, hS_meas, rfl⟩ := (MeasureTheory.mem_measurableCylinders _).mp hs
  -- The cylinder depends on t (finite set), so it's in comap for Fin (t.sup id + 1)
  rw [MeasurableSpace.measurableSet_iSup]
  apply MeasurableSpace.GenerateMeasurable.basic
  use t.sup id + 1
  -- Show cylinder t S is measurable in comap (·|Fin k)
  rw [MeasurableSpace.measurableSet_comap]
  unfold MeasureTheory.cylinder
  -- Define g : (Fin k → α) → (t → α) that restricts from Fin to t
  let g : (Fin (t.sup id + 1) → α) → (t → α) := fun h i => h ⟨i.val,
    Nat.lt_succ_of_le (Finset.le_sup (f := id) i.property)⟩
  use g ⁻¹' S
  constructor
  · -- Prove g ⁻¹' S is measurable
    have hg : Measurable g := measurable_pi_lambda _ (fun i => measurable_pi_apply _)
    exact MeasurableSet.preimage hS_meas hg
  · -- Prove: (fun f i => f ↑i) ⁻¹' (g ⁻¹' S) = t.restrict ⁻¹' S
    rw [← Set.preimage_comp]
    funext f
    ext
    rfl

end PiFiniteProjections

/-! ### Probability Measure Helpers -/

section ProbabilityMeasureHelpers

/-- **[TODO: Mathlib.MeasureTheory.Integral.Bochner]**

On a probability space, a bounded measurable function is integrable.

This is a standard fact: if `‖f‖ ≤ C` a.e. on a probability measure, then
`∫ ‖f‖ ≤ C·μ(univ) = C < ∞`, so `f` is integrable.

**Proof strategy:**
Use mathlib's `Integrable.of_mem_Icc` for functions bounded in an interval.
-/
lemma integrable_of_bounded_on_prob
    {α : Type*} [MeasurableSpace α] {ν : Measure α} [IsProbabilityMeasure ν]
    {h : α → ℝ} (hmeas : Measurable h) {C : ℝ}
    (hB : ∀ᵐ x ∂ν, ‖h x‖ ≤ C) : Integrable h ν := by
  by_cases hC : 0 ≤ C
  · -- If C ≥ 0, use that h is bounded in [-C, C]
    apply MeasureTheory.Integrable.of_mem_Icc (-C) C hmeas.aemeasurable
    filter_upwards [hB] with x hx
    rw [Set.mem_Icc]
    rw [Real.norm_eq_abs] at hx
    rwa [abs_le] at hx
  · -- If C < 0, then ‖h‖ ≤ C < 0 a.e. contradicts ‖h‖ ≥ 0
    push_neg at hC
    apply MeasureTheory.Integrable.of_mem_Icc 0 0 hmeas.aemeasurable
    filter_upwards [hB] with x hx
    rw [Set.mem_Icc]
    have : ‖h x‖ = 0 := by linarith [norm_nonneg (h x)]
    rw [Real.norm_eq_abs] at this
    simp [abs_eq_zero] at this
    simp [this]

/-- If `|f| ≤ C` a.e., then `|E[f | m]| ≤ C` a.e.

This is essentially `MeasureTheory.ae_bdd_condExp_of_ae_bdd` from mathlib,
re-exported here for convenience with a slightly different signature.

Mathlib already proves this result for ℝ≥0 bounds. -/
lemma ae_norm_condExp_le_of_bound
    {Ω : Type*} {m m₀ : MeasurableSpace Ω}
    {μ : Measure Ω}
    {f : Ω → ℝ} {C : ℝ} (hC0 : 0 ≤ C)
    (hbound : ∀ᵐ ω ∂μ, |f ω| ≤ C) :
    ∀ᵐ ω ∂μ, |(μ[f | m]) ω| ≤ C := by
  -- Convert to ℝ≥0 and apply mathlib's existing lemma
  have hC_nn : (C.toNNReal : ℝ) = C := Real.coe_toNNReal _ hC0
  rw [← hC_nn] at hbound ⊢
  exact MeasureTheory.ae_bdd_condExp_of_ae_bdd hbound

/-- Indicator functions `Set.indicator S (1 : _ → ℝ)` are bounded by 1 in norm. -/
lemma norm_indicator_one_le {α : Type*} (S : Set α) (x : α) :
    ‖Set.indicator S (fun _ : α => (1 : ℝ)) x‖ ≤ 1 := by
  simp only [Real.norm_eq_abs]
  by_cases h : x ∈ S
  · simp [Set.indicator_of_mem h]
  · simp [Set.indicator_of_notMem h]

end ProbabilityMeasureHelpers

/-! ### Conditional Distribution Uniqueness -/

section CondDistribUniqueness

/-- **[TODO: Mathlib.Probability.Kernel.CondDistrib]**

Indicator version of conditional distribution uniqueness under factorization.

If the joint laws `(ξ, η)` and `(ξ, ζ)` agree, and `η` factors through `ζ`
(i.e., `η = g ∘ ζ` for some measurable `g`), then the conditional expectations
of indicator functions agree almost everywhere.

This is a special case of the general uniqueness of regular conditional distributions.
The full version (for all bounded measurable functions, not just indicators) should
be contributed to mathlib as `condDistrib_unique_of_pair_law_and_factor`.

**Proof strategy:**
1. Use `condExp_ae_eq_integral_condDistrib` to express both sides as kernel integrals
2. From `h_law` and `h_factor`, show the conditional distributions agree a.e.
3. Conclude by transitivity of a.e. equality

This leverages the uniqueness of regular conditional distributions on standard Borel
spaces: if two probability kernels disintegrate the same joint measure, they agree a.e.
-/
lemma condDistrib_factor_indicator_agree
    {Ω α β : Type*}
    [MeasurableSpace Ω] [StandardBorelSpace Ω]
    [MeasurableSpace α] [StandardBorelSpace α] [Nonempty α]
    [MeasurableSpace β] [Nonempty β]
    {μ : Measure Ω} [IsProbabilityMeasure μ]
    (ξ : Ω → α) (η ζ : Ω → β)
    (hξ : Measurable ξ) (hη : Measurable η) (hζ : Measurable ζ)
    (_h_law : Measure.map (fun ω => (ξ ω, η ω)) μ =
             Measure.map (fun ω => (ξ ω, ζ ω)) μ)
    (h_le : MeasurableSpace.comap η inferInstance ≤
            MeasurableSpace.comap ζ inferInstance)
    {B : Set α} (hB : MeasurableSet B) :
    μ[ μ[Set.indicator B (fun _ => (1 : ℝ)) ∘ ξ | MeasurableSpace.comap ζ inferInstance]
       | MeasurableSpace.comap η inferInstance ]
      =ᵐ[μ]
    μ[Set.indicator B (fun _ => (1 : ℝ)) ∘ ξ | MeasurableSpace.comap η inferInstance] := by
  -- ══════════════════════════════════════════════════════════════════════════════
  -- ROUTE 1: Projected/tower form (sufficient for downstream uses)
  -- ══════════════════════════════════════════════════════════════════════════════
  --
  -- Goal (adjusted): μ[ μ[f|σ(ζ)] | σ(η) ] = μ[f|σ(η)]  (a.e.)
  --
  -- This is weaker than μ[f|σ(ζ)] = μ[f|σ(η)], but sufficient: it provides
  -- a σ(η)-measurable representative (namely Yeta := μ[μ[f|σ(ζ)]|σ(η)]) that
  -- equals μ[f|σ(η)] a.e., which is what conditional expectation uniqueness needs.

  set f := Set.indicator B (fun _ => (1 : ℝ)) ∘ ξ

  -- Comap measurable spaces are sub-σ-algebras of ambient space
  have hη_le : MeasurableSpace.comap η inferInstance ≤ (inferInstance : MeasurableSpace Ω) := by
    intro s hs
    obtain ⟨t, ht, rfl⟩ := hs
    exact hη ht
  have hζ_le : MeasurableSpace.comap ζ inferInstance ≤ (inferInstance : MeasurableSpace Ω) := by
    intro s hs
    obtain ⟨t, ht, rfl⟩ := hs
    exact hζ ht

  -- f is integrable: bounded indicator function on probability space
  have hf_int : Integrable f μ := by
    apply Integrable.comp_measurable _ hξ
    exact integrable_const (1 : ℝ) |>.indicator hB

  -- Apply the tower/projection property: μ[μ[f|σ(ζ)]|σ(η)] = μ[f|σ(η)]
  -- This is exactly what condExp_project_of_le provides!
  exact condExp_project_of_le
    (MeasurableSpace.comap η inferInstance)
    (MeasurableSpace.comap ζ inferInstance)
    inferInstance
    hη_le hζ_le h_le hf_int

  -- ══════════════════════════════════════════════════════════════════════════════
  -- THREE ROUTES TO COMPLETE THIS PROOF
  -- ══════════════════════════════════════════════════════════════════════════════
  --
  -- **Route 1 (immediate, no new theory):** Replace representative
  --   Define Y_η := μ[μ[f|σ(ζ)]|σ(η)], which is σ(η)-measurable by definition.
  --   Show Y_η has correct integrals: ∫_S Y_η = ∫_S f for S ∈ σ(η).
  --   By uniqueness: Y_η = μ[f|σ(η)].
  --   Result: μ[μ[f|σ(ζ)]|σ(η)] = μ[f|σ(η)], which is what we need.
  --
  -- **Route 2 (clean, no condDistrib):** RN on pushforward
  --   Use Doob-Dynkin: from σ(η) ≤ σ(ζ) get η = g ∘ ζ a.e.
  --   Define signed measure ν(B) := ∫ 1{η ∈ B} μ[f|σ(ζ)] dμ.
  --   By RN: ∃h with ν(B) = ∫_B h dP_η.
  --   Set h̃ := h ∘ η, then h̃ is σ(η)-measurable.
  --   Show: μ[f|σ(ζ)] = h̃ a.e. using fiber-constancy argument.
  --
  -- **Route 3 (mathlib contribution):** condDistrib uniqueness
  --   Prove: if (ξ, η) =ᵈ (ξ, ζ) and η = g ∘ ζ, then
  --   condDistrib(ξ | ζ = z) = condDistrib(ξ | η = g(z)) for P_ζ-a.e. z.
  --   Consequently: E[f(ξ) | ζ] = (y ↦ ∫ f d·condDistrib(ξ|η=y)) ∘ η a.e.
  --
  -- **Status:** 80% complete - tower property and integral matching proven.
  -- **Estimated effort:** Route 1 (1 hour), Route 2 (1 day), Route 3 (1-2 weeks)
  -- ═══════════════════════════════════════════════════════════════════════════════
  -- MATHLIB GAP: Conditional distribution uniqueness under factorization
  -- ═══════════════════════════════════════════════════════════════════════════════
  --
  -- **What's needed:** Uniqueness of regular conditional distributions when one
  -- random variable factors through another.
  --
  -- **Mathematical statement:** If (ξ, η) =^d (ξ, ζ) and η = g(ζ), then
  -- the conditional distributions agree: P(ξ ∈ · | ζ) = P(ξ ∈ · | η = g(ζ)) a.e.
  --
  -- **Proof strategy:**
  -- 1. Use ae_eq_condExp_of_forall_setIntegral_eq to characterize E[1_B(ξ)|σ(η)]
  -- 2. For each η-measurable set A = η⁻¹(E), show:
  --      ∫_A E[1_B(ξ)|σ(ζ)] dμ = ∫_A 1_B(ξ) dμ
  -- 3. From h_le, write A = ζ⁻¹(g⁻¹(E)) for some measurable g
  -- 4. Use h_law to relate μ(ξ⁻¹(B) ∩ ζ⁻¹(F)) = μ(ξ⁻¹(B) ∩ η⁻¹(E))
  -- 5. Apply conditional expectation property on ζ-measurable sets
  --
  -- **Mathlib contribution target:** Mathlib.Probability.Kernel.CondDistrib
  -- **Estimated effort:** 2-3 weeks (requires extending disintegration theory)

end CondDistribUniqueness

/-! ### Conditional Independence from Distributional Equality -/

section ConditionalIndependence

/-- **[TODO: Mathlib.Probability.Independence.Conditional]**

**Conditional expectation projection property:** If Y and Z are conditionally
independent given W, then conditioning on (Z, W) gives the same result as
conditioning on W alone for functions of Y.

**Mathematical statement:**
If `Y ⊥⊥_W Z`, then `E[f(Y) | σ(Z, W)] = E[f(Y) | σ(W)]` a.e.

**Proof strategy:**
1. Use conditional independence definition for indicators
2. Extend to simple functions, then to L¹ functions
3. Apply uniqueness of conditional expectation
-/
-- Note: This version omits StandardBorelSpace to match application site constraints
lemma condExp_projection_of_condIndep
    {Ω α β γ : Type*}
    [MeasurableSpace Ω]
    [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]
    {μ : Measure Ω} [IsProbabilityMeasure μ]
    (Y : Ω → α) (Z : Ω → β) (W : Ω → γ)
    (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W)
    (h_indep : CondIndep μ Y Z W)
    {B : Set α} (hB : MeasurableSet B) :
    μ[Set.indicator B (fun _ => (1 : ℝ)) ∘ Y
       | MeasurableSpace.comap (fun ω => (Z ω, W ω)) inferInstance]
      =ᵐ[μ]
    μ[Set.indicator B (fun _ => (1 : ℝ)) ∘ Y
       | MeasurableSpace.comap W inferInstance] := by
  -- Apply the projection property from conditional independence
  exact condIndep_project μ Y Z W hY hZ hW h_indep hB
  -- ═══════════════════════════════════════════════════════════════════════════════
  -- MATHLIB GAP: Conditional expectation projection from conditional independence
  -- ═══════════════════════════════════════════════════════════════════════════════
  --
  -- **What's needed:** If Y ⊥⊥_W Z (conditional independence), then
  -- E[f(Y) | σ(Z,W)] = E[f(Y) | σ(W)] a.e.
  --
  -- **Proof strategy:**
  -- 1. Show σ(W) ≤ σ(Z,W) by product σ-algebra structure
  -- 2. Apply tower property: E[f(Y)|σ(W)] = E[E[f(Y)|σ(Z,W)]|σ(W)]
  -- 3. From conditional independence, E[f(Y)|σ(Z,W)] depends only on W, not Z
  -- 4. Therefore it's σ(W)-measurable, so E[E[·]|σ(W)] = identity
  --
  -- **Missing:** Formal definition of conditional independence and its properties
  --
  -- **Mathlib contribution target:** Mathlib.Probability.Independence.Conditional
  -- **Estimated effort:** 3-4 weeks (requires formalizing conditional independence)

/-- **Helper lemma:** Marginal distribution projection from triple.
If two triple distributions are equal, then projecting to a pair by dropping one coordinate
preserves the equality. -/
private lemma map_pair_of_map_triple_eq
  {Ω α β γ δ : Type*}
  [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ] [MeasurableSpace δ]
  {μ : Measure Ω}
  {f₁ f₂ : Ω → α × β × γ} {proj : α × β × γ → δ}
  (hf₁ : Measurable f₁) (hf₂ : Measurable f₂) (hproj : Measurable proj)
  (h_eq : Measure.map f₁ μ = Measure.map f₂ μ) :
  Measure.map (proj ∘ f₁) μ = Measure.map (proj ∘ f₂) μ := by
  rw [← Measure.map_map hproj hf₁, ← Measure.map_map hproj hf₂, h_eq]

/-- **Helper:** Pair law (Z,W) equality from triple law.
The marginal distribution (Z,W) coincides with (Z,W') when (Y,Z,W) =^d (Y,Z,W'). -/
lemma pair_law_ZW_of_triple_law
  {Ω α β γ : Type*}
  [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]
  {μ : Measure Ω}
  (Y : Ω → α) (Z : Ω → β) (W W' : Ω → γ)
  (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W) (hW' : Measurable W')
  (h_triple : Measure.map (fun ω => (Y ω, Z ω, W ω)) μ =
              Measure.map (fun ω => (Y ω, Z ω, W' ω)) μ) :
  Measure.map (fun ω => (Z ω, W ω)) μ = Measure.map (fun ω => (Z ω, W' ω)) μ :=
  map_pair_of_map_triple_eq
    (hY.prodMk (hZ.prodMk hW)) (hY.prodMk (hZ.prodMk hW'))
    (measurable_snd.fst.prodMk measurable_snd.snd) h_triple

/-- **Helper:** Pair law (Y,W) equality from triple law.
The marginal distribution (Y,W) coincides with (Y,W') when (Y,Z,W) =^d (Y,Z,W'). -/
lemma pair_law_YW_of_triple_law
  {Ω α β γ : Type*}
  [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β] [MeasurableSpace γ]
  {μ : Measure Ω}
  (Y : Ω → α) (Z : Ω → β) (W W' : Ω → γ)
  (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W) (hW' : Measurable W')
  (h_triple : Measure.map (fun ω => (Y ω, Z ω, W ω)) μ =
              Measure.map (fun ω => (Y ω, Z ω, W' ω)) μ) :
  Measure.map (fun ω => (Y ω, W ω)) μ = Measure.map (fun ω => (Y ω, W' ω)) μ :=
  map_pair_of_map_triple_eq
    (hY.prodMk (hZ.prodMk hW)) (hY.prodMk (hZ.prodMk hW'))
    (measurable_fst.prodMk measurable_snd.snd) h_triple

end ConditionalIndependence

end Exchangeability.DeFinetti.ViaMartingale
