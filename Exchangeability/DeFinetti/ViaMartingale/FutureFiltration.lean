/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Exchangeability.Probability.CondExp
import Exchangeability.DeFinetti.ViaMartingale.ShiftOperations
import Exchangeability.DeFinetti.ViaMartingale.RevFiltration

/-!
# Future Filtration

The future filtration at level m is Ïƒ(Î¸_{m+1} X), i.e., Ïƒ(X_{m+1}, X_{m+2}, ...).
This is the Ïƒ-algebra generated by coordinates after position m.

## Main definitions

* `futureFiltration X m` - Ïƒ(Î¸_{m+1} X) = Ïƒ(X_{m+1}, X_{m+2}, ...)
* `tailSigmaFuture X` - â¨… m, futureFiltration X m (equals tailSigma X)

## Main results

* `futureFiltration_le` - futureFiltration is a sub-Ïƒ-algebra of the ambient
* `futureFiltration_antitone` - futureFiltration is decreasing in m
* `tailSigma_le_futureFiltration` - tail is coarser than any future filtration
* `tailSigmaFuture_eq_tailSigma` - the two tail definitions coincide

These are extracted from ViaMartingale.lean to enable modular imports.
-/

noncomputable section
open scoped MeasureTheory
open MeasureTheory

namespace Exchangeability.DeFinetti.ViaMartingale

variable {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]

/-! ### Future Filtration Definition -/

/-- Future reverse filtration: ğ”½á¶ áµ˜áµ—â‚˜ = Ïƒ(Î¸_{m+1} X). -/
abbrev futureFiltration (X : â„• â†’ Î© â†’ Î±) (m : â„•) : MeasurableSpace Î© :=
  MeasurableSpace.comap (shiftRV X (m + 1)) inferInstance

/-! ### Future Filtration Properties -/

section FutureFiltration

variable {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]

/-- The future filtration is decreasing (antitone). -/
lemma futureFiltration_antitone (X : â„• â†’ Î© â†’ Î±) :
    Antitone (futureFiltration X) := fun _ _ hmn =>
  revFiltration_antitone X (Nat.succ_le_succ hmn)

/-- Tail Ïƒ-algebra via the future filtration. (Additive alias.) -/
def tailSigmaFuture (X : â„• â†’ Î© â†’ Î±) : MeasurableSpace Î© :=
  â¨… m, futureFiltration X m

omit [MeasurableSpace Î©] in
@[simp] lemma tailSigmaFuture_eq_iInf (X : â„• â†’ Î© â†’ Î±) :
    tailSigmaFuture X = â¨… m, futureFiltration X m := rfl

omit [MeasurableSpace Î©] in
@[simp] lemma futureFiltration_eq_rev_succ (X : â„• â†’ Î© â†’ Î±) (m : â„•) :
    futureFiltration X m = revFiltration X (m + 1) := rfl

lemma tailSigmaFuture_eq_tailSigma (X : â„• â†’ Î© â†’ Î±) :
    tailSigmaFuture X = tailSigma X := by
  -- Both are infima of antitone sequences: â¨… n, revFiltration X (n+1) vs â¨… n, revFiltration X n
  -- These are equal because shifting by 1 doesn't change infimum of antitone sequence
  simp only [tailSigmaFuture, tailSigma, futureFiltration_eq_rev_succ]
  apply le_antisymm
  Â· exact iInf_mono fun n => revFiltration_antitone X (Nat.le_succ n)
  Â· exact le_iInf fun n => iInf_le _ (n + 1)

/-! ### Helper lemmas for tail Ïƒ-algebra -/

/-- The tail Ïƒ-algebra is a sub-Ïƒ-algebra of the ambient Ïƒ-algebra. -/
lemma tailSigma_le {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    (X : â„• â†’ Î© â†’ Î±) (hX : âˆ€ n, Measurable (X n)) :
    tailSigma X â‰¤ (inferInstance : MeasurableSpace Î©) := by
  refine iInf_le_of_le 0 ?_
  exact revFiltration_le X hX 0

/-- Tail Ïƒ-algebra is sub-Ïƒ-algebra of future filtration. -/
lemma tailSigma_le_futureFiltration {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    (X : â„• â†’ Î© â†’ Î±) (m : â„•) :
    tailSigma X â‰¤ futureFiltration X m :=
  iInf_le_of_le (m + 1) le_rfl

/-- Indicators of tail-measurable sets are tail-measurable functions. -/
lemma indicator_tailMeasurable {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    (X : â„• â†’ Î© â†’ Î±) (A : Set Î©) (hA : MeasurableSet[tailSigma X] A) :
    StronglyMeasurable[tailSigma X] (A.indicator (fun _ => (1 : â„))) := by
  refine StronglyMeasurable.indicator ?_ hA
  exact stronglyMeasurable_const

/-- If each coordinate is measurable, then the tail Ïƒ-algebra is sigma-finite
when the base measure is finite.

Note: While this could be stated for general sigma-finite measures, we only need the finite
case for de Finetti's theorem (which works with probability measures). The general sigma-finite
case requires manual construction of spanning sets and is a mathlib gap. -/
lemma sigmaFinite_trim_tailSigma {Î© Î± : Type*} {mâ‚€ : MeasurableSpace Î©} [MeasurableSpace Î±]
    {Î¼ : @Measure Î© mâ‚€} [IsFiniteMeasure Î¼]
    (X : â„• â†’ Î© â†’ Î±) (hX : âˆ€ n, Measurable (X n)) :
    SigmaFinite (Î¼.trim (tailSigma_le X hX)) := by
  classical
  -- Use the infrastructure from CondExp.lean
  exact Exchangeability.Probability.sigmaFinite_trim Î¼ (tailSigma_le X hX)

/-! ### Helper lemmas for futureFiltration properties -/

/-- Future filtration is sub-Ïƒ-algebra of ambient. -/
lemma futureFiltration_le {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    (X : â„• â†’ Î© â†’ Î±) (m : â„•) (hX : âˆ€ n, Measurable (X n)) :
    futureFiltration X m â‰¤ (inferInstance : MeasurableSpace Î©) :=
  revFiltration_le X hX (m + 1)

/-- The preimage of a measurable set under X_{m+k} is measurable in futureFiltration X m.
Note: This requires k â‰¥ 1 since futureFiltration X m = Ïƒ(X_{m+1}, X_{m+2}, ...). -/
lemma preimage_measurable_in_futureFiltration {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    (X : â„• â†’ Î© â†’ Î±) (m k : â„•) (hk : 1 â‰¤ k) {A : Set Î±} (hA : MeasurableSet A) :
    MeasurableSet[futureFiltration X m] (X (m + k) â»Â¹' A) := by
  -- futureFiltration X m = comap (shiftRV X (m+1))
  -- X (m + k) = X (m + 1 + (k-1)) = Ï€_{k-1} âˆ˜ shiftRV X (m+1)
  -- where Ï€_n projects to the n-th coordinate
  simp only [futureFiltration]
  have : X (m + k) = (fun f : â„• â†’ Î± => f (k - 1)) âˆ˜ shiftRV X (m + 1) := by
    funext Ï‰
    simp [shiftRV]
    congr 1
    omega
  rw [this, Set.preimage_comp]
  exact âŸ¨(fun f : â„• â†’ Î± => f (k - 1)) â»Â¹' A, (measurable_pi_apply (k - 1)) hA, rflâŸ©

/-- Events measurable in a future filtration remain measurable in earlier filtrations. -/
lemma measurableSet_of_futureFiltration {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    (X : â„• â†’ Î© â†’ Î±) {m n : â„•} (hmn : m â‰¤ n) {A : Set Î©}
    (hA : MeasurableSet[futureFiltration X n] A) :
    MeasurableSet[futureFiltration X m] A :=
  futureFiltration_antitone X hmn A hA

end FutureFiltration

end Exchangeability.DeFinetti.ViaMartingale
