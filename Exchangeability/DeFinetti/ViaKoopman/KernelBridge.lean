/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.Probability.Independence.Integration
import Exchangeability.DeFinetti.ViaKoopman.Infrastructure
import Exchangeability.DeFinetti.MartingaleHelpers

/-! # Kernel Bridge Lemmas

This file contains bridge lemmas connecting kernel-level and measure-level independence.

## Main results

- `Kernel.IndepFun.ae_measure_indepFun`: Kernel independence implies measure-level integral factorization
- `Kernel.IndepFun.comp`: Independence is preserved under composition with measurable functions
- `metProjection_eq_condExpL2_shiftInvariant`: MET projection equals conditional expectation

**Split from**: KernelIndependence.lean (lines 1-280)
-/

open Filter MeasureTheory

noncomputable section

namespace Exchangeability.DeFinetti.ViaKoopman

open MeasureTheory Filter Topology ProbabilityTheory
open Exchangeability.Ergodic
open Exchangeability.PathSpace
open Exchangeability.DeFinetti.MartingaleHelpers (comap_comp_le)
open scoped BigOperators

variable {α : Type*} [MeasurableSpace α]

local notation "mSI" => shiftInvariantSigma (α := α)

-- Alias needed for kernel integration
alias condExp_eq_kernel_integral := ProbabilityTheory.condExp_ae_eq_integral_condExpKernel

/-! ## Bridge lemmas for de Finetti's theorem

These lemmas bridge kernel-level and measure-level independence concepts.
They isolate the genuinely difficult parts (measurable selection, conditional independence)
and allow the rest of the proof to proceed mechanically.
-/

/-- Bridge from kernel independence to measure-level integral factorization.

Given `Kernel.IndepFun X Y κ μ`, for a.e. a we have `IndepFun X Y (κ a)` at the measure level,
which gives integral factorization via `IndepFun.integral_mul_eq_mul_integral`.

**Proof outline:**
1. `Kernel.IndepFun` gives: ∀ s t measurable, ∀ᵐ a, κ a (X⁻¹(s) ∩ Y⁻¹(t)) = κ a (X⁻¹(s)) * κ a (Y⁻¹(t))
2. Use countable generators {Iic q | q : ℚ} for Borel ℝ (borel_eq_generateFrom_Iic_rat)
3. Apply `ae_all_iff` to swap: (∀ q r : ℚ, ∀ᵐ a, ...) ↔ (∀ᵐ a, ∀ q r, ...)
4. For a.e. a, independence on π-system generators extends to full σ-algebra
5. Apply `IndepFun.integral_mul_eq_mul_integral` for each a
-/
lemma Kernel.IndepFun.ae_measure_indepFun
    {α₁ Ω : Type*} [MeasurableSpace α₁] [MeasurableSpace Ω]
    (κ : Kernel α₁ Ω) (μ : Measure α₁)
    [IsFiniteMeasure μ] [IsMarkovKernel κ]
    {X Y : Ω → ℝ} (hX : Measurable X) (hY : Measurable Y)
    (hXY : Kernel.IndepFun X Y κ μ) :
    ∀ᵐ a ∂μ, ∫ ω, X ω * Y ω ∂(κ a) = (∫ ω, X ω ∂(κ a)) * (∫ ω, Y ω ∂(κ a)) := by
  -- Step 1: Get the characterization of kernel independence
  rw [Kernel.indepFun_iff_measure_inter_preimage_eq_mul] at hXY

  -- Step 2: For countable family of generators, swap quantifiers using ae_all_iff
  -- The Borel σ-algebra on ℝ is generated by {Iic q | q : ℚ}

  -- Get independence on rational intervals (countable family)
  have h_rat : ∀ qr : ℚ × ℚ, ∀ᵐ a ∂μ,
      κ a (X ⁻¹' Set.Iic (qr.1 : ℝ) ∩ Y ⁻¹' Set.Iic (qr.2 : ℝ)) =
      κ a (X ⁻¹' Set.Iic (qr.1 : ℝ)) * κ a (Y ⁻¹' Set.Iic (qr.2 : ℝ)) := by
    intro ⟨q, r⟩
    exact hXY (Set.Iic (q : ℝ)) (Set.Iic (r : ℝ)) measurableSet_Iic measurableSet_Iic

  -- Swap quantifiers using ae_all_iff (ℚ × ℚ is countable)
  have h_swap : ∀ᵐ a ∂μ, ∀ qr : ℚ × ℚ,
      κ a (X ⁻¹' Set.Iic (qr.1 : ℝ) ∩ Y ⁻¹' Set.Iic (qr.2 : ℝ)) =
      κ a (X ⁻¹' Set.Iic (qr.1 : ℝ)) * κ a (Y ⁻¹' Set.Iic (qr.2 : ℝ)) :=
    ae_all_iff.mpr h_rat

  -- Step 3: For a.e. a, extend independence from generators to full σ-algebra
  filter_upwards [h_swap] with a h_gen

  -- h_gen : ∀ qr : ℚ × ℚ, independence holds on rational intervals
  -- Need to show: ∫ X * Y = (∫ X) * (∫ Y) under κ a

  -- Technical approach: Use that independence on the generating π-system {Iic q | q : ℚ}
  -- extends to the full Borel σ-algebra via π-λ theorem (MeasureTheory.induction_on_inter)
  -- Then IndepFun X Y (κ a) gives the integral factorization.

  -- π-λ extension: From independence on rational intervals to full σ-algebra
  have h_indep : ProbabilityTheory.IndepFun X Y (κ a) := by
    -- Define the generating π-systems (preimages of rational intervals)
    let p1 : Set (Set Ω) := Set.preimage X '' (⋃ q : ℚ, {Set.Iic (q : ℝ)})
    let p2 : Set (Set Ω) := Set.preimage Y '' (⋃ q : ℚ, {Set.Iic (q : ℝ)})

    -- Use IndepSets.indep' to extend from generators
    have h_indep_sets : ProbabilityTheory.IndepSets p1 p2 (κ a) := by
      rw [ProbabilityTheory.IndepSets_iff]
      intro s t hs ht
      -- Extract the rational indices from s and t
      rw [Set.mem_image] at hs ht
      obtain ⟨s', hs', rfl⟩ := hs
      obtain ⟨t', ht', rfl⟩ := ht
      rw [Set.mem_iUnion] at hs' ht'
      obtain ⟨q, hq⟩ := hs'
      obtain ⟨r, hr⟩ := ht'
      rw [Set.mem_singleton_iff] at hq hr
      subst hq hr
      exact h_gen ⟨q, r⟩

    -- Show measurability of generators
    have hp1m : ∀ s ∈ p1, MeasurableSet s := fun s hs => by
      rw [Set.mem_image] at hs
      obtain ⟨s', hs', rfl⟩ := hs
      rw [Set.mem_iUnion] at hs'
      obtain ⟨q, hq⟩ := hs'
      rw [Set.mem_singleton_iff] at hq
      subst hq
      exact hX measurableSet_Iic
    have hp2m : ∀ s ∈ p2, MeasurableSet s := fun s hs => by
      rw [Set.mem_image] at hs
      obtain ⟨s', hs', rfl⟩ := hs
      rw [Set.mem_iUnion] at hs'
      obtain ⟨q, hq⟩ := hs'
      rw [Set.mem_singleton_iff] at hq
      subst hq
      exact hY measurableSet_Iic

    -- Show p1, p2 are π-systems (intersection of Iic gives Iic with min)
    have hp1_pi : IsPiSystem p1 := by
      intro s hs t ht _
      rw [Set.mem_image] at hs ht ⊢
      obtain ⟨s', hs', rfl⟩ := hs
      obtain ⟨t', ht', rfl⟩ := ht
      rw [Set.mem_iUnion] at hs' ht'
      obtain ⟨q, hq⟩ := hs'
      obtain ⟨r, hr⟩ := ht'
      rw [Set.mem_singleton_iff] at hq hr
      subst hq hr
      refine ⟨Set.Iic ((min q r : ℚ) : ℝ), ?_, ?_⟩
      · rw [Set.mem_iUnion]; exact ⟨min q r, rfl⟩
      · rw [← Set.preimage_inter, Set.Iic_inter_Iic, Rat.cast_min]
    have hp2_pi : IsPiSystem p2 := by
      intro s hs t ht _
      rw [Set.mem_image] at hs ht ⊢
      obtain ⟨s', hs', rfl⟩ := hs
      obtain ⟨t', ht', rfl⟩ := ht
      rw [Set.mem_iUnion] at hs' ht'
      obtain ⟨q, hq⟩ := hs'
      obtain ⟨r, hr⟩ := ht'
      rw [Set.mem_singleton_iff] at hq hr
      subst hq hr
      refine ⟨Set.Iic ((min q r : ℚ) : ℝ), ?_, ?_⟩
      · rw [Set.mem_iUnion]; exact ⟨min q r, rfl⟩
      · rw [← Set.preimage_inter, Set.Iic_inter_Iic, Rat.cast_min]

    -- Apply IndepSets.indep' to get Indep on generated σ-algebras
    haveI : IsProbabilityMeasure (κ a) := IsMarkovKernel.isProbabilityMeasure a
    have h_indep' := ProbabilityTheory.IndepSets.indep' hp1m hp2m hp1_pi hp2_pi h_indep_sets

    -- Connect to IndepFun: show generateFrom p1 = comap X (borel ℝ), etc.
    have hgen1 : MeasurableSpace.generateFrom p1 = MeasurableSpace.comap X (borel ℝ) := by
      rw [Real.borel_eq_generateFrom_Iic_rat, MeasurableSpace.comap_generateFrom]
    have hgen2 : MeasurableSpace.generateFrom p2 = MeasurableSpace.comap Y (borel ℝ) := by
      rw [Real.borel_eq_generateFrom_Iic_rat, MeasurableSpace.comap_generateFrom]
    rw [hgen1, hgen2] at h_indep'
    exact h_indep'

  -- Step 4: Apply measure-level integral factorization
  haveI : IsProbabilityMeasure (κ a) := IsMarkovKernel.isProbabilityMeasure a
  exact h_indep.integral_fun_mul_eq_mul_integral
    hX.aestronglyMeasurable hY.aestronglyMeasurable

/-- **Composition lemma**: Independence is preserved under composition with measurable functions.

If X and Y are kernel-independent, then f ∘ X and g ∘ Y are also kernel-independent
for any measurable functions f and g.

**Proof strategy**:
- Kernel.IndepFun X Y κ μ means Kernel.Indep (comap X) (comap Y) κ μ
- For measurable f, comap (f ∘ X) ⊆ comap X (preimages under f∘X are preimages under X)
- Independence of larger σ-algebras implies independence of sub-σ-algebras
-/
lemma Kernel.IndepFun.comp
    {α Ω β γ : Type*} [MeasurableSpace α] [MeasurableSpace Ω]
    [MeasurableSpace β] [MeasurableSpace γ]
    {κ : Kernel α Ω} {μ : Measure α}
    {X : Ω → β} {Y : Ω → γ}
    (hXY : Kernel.IndepFun X Y κ μ)
    {f : β → ℝ} {g : γ → ℝ}
    (hf : Measurable f) (hg : Measurable g) :
    Kernel.IndepFun (f ∘ X) (g ∘ Y) κ μ := by
  -- The key insight: Kernel.IndepFun is defined as independence of the comap σ-algebras
  -- For sets s, t in the target σ-algebras, we need to show:
  -- ∀ s ∈ σ(f∘X), ∀ t ∈ σ(g∘Y), ∀ᵐ a, κ a (s ∩ t) = κ a s * κ a t

  intro s t hs ht
  -- s is measurable w.r.t. comap (f ∘ X), so s = (f ∘ X)⁻¹(S) for some measurable S ⊆ ℝ
  -- This means s = X⁻¹(f⁻¹(S)), so s is in comap X
  -- Similarly t is in comap Y

  -- We need to show s ∈ comap X and t ∈ comap Y
  -- Key fact: if s is measurable w.r.t. comap (f ∘ X), then s is measurable w.r.t. comap X
  -- because comap (f ∘ X) ≤ comap X

  have hs' : MeasurableSet[MeasurableSpace.comap X inferInstance] s :=
    comap_comp_le X f hf s hs

  have ht' : MeasurableSet[MeasurableSpace.comap Y inferInstance] t :=
    comap_comp_le Y g hg t ht

  exact hXY s t hs' ht'

/-- **Bridge lemma**: The Mean Ergodic Theorem projection equals conditional expectation
onto the shift-invariant σ-algebra.

**Statement**: For a measure-preserving shift on path space,
  `metProjection shift hσ = condexpL2`

**Proof strategy**:
1. Both are orthogonal projections onto the same subspace in L²(μ)
2. The fixed-point subspace `{f : f ∘ shift = f}` equals the subspace of
   shiftInvariantSigma-measurable functions
3. By uniqueness of orthogonal projections, they must be equal

**Key insight**: Functions invariant under the Koopman operator (f ∘ shift = f) are
precisely those measurable with respect to the shift-invariant σ-algebra. This
connects the ergodic-theoretic perspective (fixed points of dynamics) with the
probabilistic perspective (conditional expectation onto a sub-σ-algebra).
-/
lemma metProjection_eq_condExpL2_shiftInvariant
    {μ : Measure (Ω[α])} [IsProbabilityMeasure μ]
    (hσ : MeasurePreserving shift μ μ) :
    metProjection (shift (α := α)) hσ = condexpL2 (μ := μ) :=
  -- METProjection is now an alias for metProjection shift
  proj_eq_condexp hσ

end Exchangeability.DeFinetti.ViaKoopman
