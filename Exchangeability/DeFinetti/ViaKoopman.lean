/-
Copyright (c) 2025 exchangeability contributors. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: exchangeability contributors
-/
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.Analysis.InnerProductSpace.Projection.Basic
import Mathlib.Probability.Kernel.Condexp
import Mathlib.Probability.Independence.Kernel
import Exchangeability.Ergodic.KoopmanMeanErgodic
import Exchangeability.DeFinetti.InvariantSigma
import Exchangeability.DeFinetti.ProjectionLemmas

/-!
# de Finetti's Theorem via Koopman Operator

**Kallenberg's "first proof"** of de Finetti's theorem using the Mean Ergodic
Theorem and Koopman operator. This proof has the **heaviest dependencies**.

## Proof approach

1. Apply the Mean Ergodic Theorem to show Birkhoff averages converge to the
   orthogonal projection onto the fixed-point subspace
2. Identify this projection with conditional expectation onto the shift-invariant Ïƒ-algebra
3. Use dominated convergence to show the conditional expectation has product form
4. Apply monotone class theorem to extend from cylinders to the full Ïƒ-algebra

## Main definitions

* `cylinderFunction`: Functions depending only on finitely many coordinates
* `productCylinder`: Product of functions evaluated at different coordinates
* `shiftedCylinder`: Cylinder function composed with shift^n

## Main results

* `deFinetti_viaKoopman`: **Main theorem** - contractable implies conditionally i.i.d.
* Supporting lemmas for Birkhoff averages and conditional expectations

## Dependencies

âŒ **Heavy** - Requires ergodic theory, Mean Ergodic Theorem, orthogonal projections
âœ… **Deep connection** to dynamical systems and ergodic theory
âœ… **Generalizes** beyond exchangeability to measure-preserving systems

## References

* Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*,
  Chapter 1, pages 26-27: "First proof of Theorem 1.1"

-/

noncomputable section

namespace Exchangeability.DeFinetti.ViaKoopman

open MeasureTheory Filter Topology ProbabilityTheory
open Exchangeability.Ergodic
open scoped BigOperators

variable {Î± : Type*} [MeasurableSpace Î±]

/-!
### Countable Ï€-system associated to the countable basis on `Î±`

To upgrade equality on a countable basis to equality of measures we will need a
countable Ï€-system generating the Borel Ïƒ-algebra.  This auxiliary section
records the intended definitions and lemmas; detailed proofs will be supplied in
subsequent iterations.
-/

namespace CountableBasisPiSystem

variable (Î±) [StandardBorelSpace Î±]

/-- Finite-intersection closure of the countable basis on a standard Borel space. -/
def carrier : Set (Set Î±) := finiteInterClosure (countableBasis Î±)

/-- TODO: the carrier is countable (combine the countability of the basis with the
closure under finite intersections). -/
lemma countable : (carrier Î±).Countable := by
  sorry

/-- TODO: the carrier forms a Ï€-system (use `finiteInterClosure_finiteInter`). -/
lemma isPiSystem : IsPiSystem (carrier Î±) := by
  sorry

/-- TODO: the Ïƒ-algebra generated by the carrier is the ambient one (Borel). -/
lemma generateFrom_eq :
    (inferInstance : MeasurableSpace Î±) =
      MeasurableSpace.generateFrom (carrier Î±) := by
  sorry

end CountableBasisPiSystem

section CylinderFunctions

/-- Cylinder function: a function on path space depending only on finitely many coordinates.
For simplicity, we take the first m coordinates. -/
def cylinderFunction (m : â„•) (Ï† : (Fin m â†’ Î±) â†’ â„) : Î©[Î±] â†’ â„ :=
  fun Ï‰ => Ï† (fun k => Ï‰ k.val)

/-- Product cylinder: âˆ_{k < m} fâ‚–(Ï‰ k). -/
def productCylinder (m : â„•) (fs : Fin m â†’ Î± â†’ â„) : Î©[Î±] â†’ â„ :=
  fun Ï‰ => âˆ k : Fin m, fs k (Ï‰ k.val)

omit [MeasurableSpace Î±] in
lemma productCylinder_eq_cylinder {m : â„•} (fs : Fin m â†’ Î± â†’ â„) :
    productCylinder m fs = cylinderFunction m (fun coords => âˆ k, fs k (coords k)) := by
  rfl

/-- Measurability of cylinder functions. -/
lemma measurable_cylinderFunction {m : â„•} {Ï† : (Fin m â†’ Î±) â†’ â„}
    (_hÏ† : Measurable Ï†) :
    Measurable (cylinderFunction m Ï†) := by
  classical
  have hproj : Measurable fun Ï‰ : Î©[Î±] => fun k : Fin m => Ï‰ k.val := by
    refine measurable_pi_lambda _ ?_
    intro k
    simpa using (measurable_pi_apply (k.val))
  simpa [cylinderFunction] using _hÏ†.comp hproj

/-- Measurability of product cylinders. -/
lemma measurable_productCylinder {m : â„•} {fs : Fin m â†’ Î± â†’ â„}
    (hmeas : âˆ€ k, Measurable (fs k)) :
    Measurable (productCylinder m fs) := by
  classical
  unfold productCylinder
  -- Product of measurable functions is measurable
  apply Finset.measurable_prod
  intro k _
  exact (hmeas k).comp (measurable_pi_apply k.val)

omit [MeasurableSpace Î±] in
/-- Boundedness of product cylinders. -/
lemma productCylinder_bounded {m : â„•} {fs : Fin m â†’ Î± â†’ â„}
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C) :
    âˆƒ C, âˆ€ Ï‰, |productCylinder m fs Ï‰| â‰¤ C := by
  -- Take C = âˆ Câ‚– where |fâ‚–| â‰¤ Câ‚–
  classical
  choose bound hbound using hbd
  let C : Fin m â†’ â„ := fun k => max (bound k) 1
  refine âŸ¨âˆ k : Fin m, C k, ?_âŸ©
  intro Ï‰
  have h_abs_le : âˆ€ k : Fin m, |fs k (Ï‰ k.val)| â‰¤ C k := by
    intro k
    have := hbound k (Ï‰ k.val)
    exact this.trans (le_max_left _ _)
  have h_nonneg : âˆ€ k : Fin m, 0 â‰¤ |fs k (Ï‰ k.val)| := fun _ => abs_nonneg _
  have hprod : âˆ k : Fin m, |fs k (Ï‰ k.val)| â‰¤ âˆ k : Fin m, C k := by
    simpa using
      (Finset.prod_le_prod (s := Finset.univ)
        (f := fun k : Fin m => |fs k (Ï‰ k.val)|)
        (g := fun k : Fin m => C k)
        (fun k _ => h_nonneg k)
        (fun k _ => h_abs_le k))
  have habs_eq : |productCylinder m fs Ï‰| = âˆ k : Fin m, |fs k (Ï‰ k.val)| := by
    simp [productCylinder, Finset.abs_prod]
  exact (by simpa [habs_eq] using hprod)

/-- Membership of product cylinders in `LÂ²`. -/
lemma productCylinder_memLp
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C)
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] :
    MeasureTheory.MemLp (productCylinder m fs) 2 Î¼ := by
  classical
  obtain âŸ¨C, hCâŸ© := productCylinder_bounded m fs hbd
  have hFmeas : Measurable (productCylinder m fs) :=
    measurable_productCylinder m fs hmeas
  refine MeasureTheory.MemLp.of_bound (Î¼ := Î¼) (p := 2)
    hFmeas.aestronglyMeasurable C ?_
  filter_upwards with Ï‰
  simpa [Real.norm_eq_abs] using hC Ï‰

/-- `Lp` representative associated to a bounded product cylinder. -/
noncomputable def productCylinderLp
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C)
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] : Lp â„ 2 Î¼ :=
  (productCylinder_memLp (m := m) (fs := fs) hmeas hbd).toLp (productCylinder m fs)

lemma productCylinderLp_ae_eq
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C)
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] :
    (âˆ€áµ Ï‰ âˆ‚Î¼, productCylinderLp (Î¼ := Î¼) (m := m) (fs := fs) hmeas hbd Ï‰ =
      productCylinder m fs Ï‰) := by
  classical
  exact MeasureTheory.MemLp.coeFn_toLp
    (productCylinder_memLp (Î¼ := Î¼) (m := m) (fs := fs) hmeas hbd)

/-- The shifted cylinder function: F âˆ˜ shift^n. -/
def shiftedCylinder (n : â„•) (F : Î©[Î±] â†’ â„) : Î©[Î±] â†’ â„ :=
  fun Ï‰ => F ((shift^[n]) Ï‰)

end CylinderFunctions

section MainConvergence

variable {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
variable (hÏƒ : MeasurePreserving shift Î¼ Î¼)

/-- Conditional expectation onto shift-invariant Ïƒ-algebra fixes elements of fixedSubspace.

This is the tower property of conditional expectation: E[f|Ïƒ] = f when f is Ïƒ-measurable.
-/
lemma condexpL2_fixes_fixedSubspace {g : Lp â„ 2 Î¼}
    (hg : g âˆˆ fixedSubspace hÏƒ) :
    condexpL2 (Î¼ := Î¼) g = g := by
  classical
  have h_range : Set.range (condexpL2 (Î¼ := Î¼)) =
      (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) :=
    range_condexp_eq_fixedSubspace (Î¼ := Î¼) hÏƒ
  have hg_range : g âˆˆ Set.range (condexpL2 (Î¼ := Î¼)) := by
    simpa [h_range] using (show g âˆˆ (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) from hg)
  obtain âŸ¨f, hfâŸ© := hg_range
  change condexpL2 (Î¼ := Î¼) f = g at hf
  subst hf
  have h_idem := congrArg (fun T => T f) (condexpL2_idem (Î¼ := Î¼))
  simpa [ContinuousLinearMap.comp_apply] using h_idem

/-- Main theorem: Birkhoff averages converge in LÂ² to conditional expectation.

This combines:
1. The Mean Ergodic Theorem (MET) giving convergence to orthogonal projection
2. The identification proj = condexp via range_condexp_eq_fixedSubspace
-/
theorem birkhoffAverage_tendsto_condexp (f : Lp â„ 2 Î¼) :
    Tendsto (fun n => birkhoffAverage â„ (koopman shift hÏƒ) _root_.id n f)
      atTop (ğ“ (condexpL2 (Î¼ := Î¼) f)) := by
  -- Step 1: Get convergence to projection P onto fixedSpace from MET
  classical
  -- Use the canonical mean ergodic projection from `InvariantSigma`
  let P := METProjection (Î¼ := Î¼) hÏƒ
  have hP_tendsto := METProjection_tendsto (Î¼ := Î¼) hÏƒ f
  have hP_fixed : âˆ€ g âˆˆ fixedSubspace hÏƒ, P g = g :=
    fun g hg => METProjection_fixes_fixedSubspace (Î¼ := Î¼) hÏƒ hg

  -- Step 2: Show P = condexpL2 using the factored lemmas
  have hP_eq : P = condexpL2 (Î¼ := Î¼) := by
    -- Both P and condexpL2 are orthogonal projections onto the fixed subspace
    -- Use uniqueness of symmetric idempotent projections with the same range
    have h_range_P : Set.range P = (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) :=
      METProjection_range_fixedSubspace (Î¼ := Î¼) hÏƒ
    have h_range_condexp : Set.range (condexpL2 (Î¼ := Î¼)) =
        (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) := range_condexp_eq_fixedSubspace hÏƒ
    have hQ_fixes : âˆ€ g âˆˆ fixedSubspace hÏƒ, condexpL2 (Î¼ := Î¼) g = g :=
      fun g hg => condexpL2_fixes_fixedSubspace (hÏƒ := hÏƒ) hg
    have hP_idem : P.comp P = P := METProjection_idem (Î¼ := Î¼) hÏƒ
    have hQ_idem : (condexpL2 (Î¼ := Î¼)).comp (condexpL2 (Î¼ := Î¼)) = condexpL2 (Î¼ := Î¼) :=
      condexpL2_idem (Î¼ := Î¼)
    have hP_sym : P.IsSymmetric := METProjection_isSymmetric (Î¼ := Î¼) hÏƒ
    have hQ_sym : (condexpL2 (Î¼ := Î¼)).IsSymmetric := by
      intro f g
      unfold condexpL2
      exact MeasureTheory.inner_condExpL2_left_eq_right shiftInvariantSigma_le
    haveI : (fixedSubspace hÏƒ).HasOrthogonalProjection := by
      have hclosed := fixedSubspace_closed hÏƒ
      have : CompleteSpace (fixedSubspace hÏƒ) := hclosed.completeSpace_coe
      exact Submodule.HasOrthogonalProjection.ofCompleteSpace (fixedSubspace hÏƒ)
    exact orthogonalProjections_same_range_eq P (condexpL2 (Î¼ := Î¼)) (fixedSubspace hÏƒ)
      h_range_P h_range_condexp hP_fixed hQ_fixes hP_idem hQ_idem hP_sym hQ_sym

  -- Step 3: Conclude using equality
  rw [â† hP_eq]
  exact hP_tendsto

/-- Specialization to cylinder functions: the core case for de Finetti. -/
theorem birkhoffCylinder_tendsto_condexp
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C) :
    let F := productCylinder m fs
    âˆƒ (fL2 : Lp â„ 2 Î¼),
      (âˆ€áµ Ï‰ âˆ‚Î¼, fL2 Ï‰ = F Ï‰) âˆ§
      Tendsto (fun n => birkhoffAverage â„ (koopman shift hÏƒ) _root_.id n fL2)
        atTop
        (ğ“ (condexpL2 (Î¼ := Î¼) fL2)) := by
  classical
  let fL2 := productCylinderLp (Î¼ := Î¼) (m := m) (fs := fs) hmeas hbd
  refine âŸ¨fL2, ?_, ?_âŸ©
  Â· exact productCylinderLp_ae_eq (m := m) (fs := fs) hmeas hbd (Î¼ := Î¼)
  Â· exact birkhoffAverage_tendsto_condexp hÏƒ fL2

end MainConvergence

section ExtremeMembers

variable {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
variable (hÏƒ : MeasurePreserving shift Î¼ Î¼)

/-- The "extreme members agree" lemma (Kallenberg's key step).

For a cylinder function F depending on coordinates iâ‚, ..., iâ‚˜, the Birkhoff
averages (1/n)âˆ‘â±¼ F(shiftÊ² Ï‰) converge to a limit that depends only on the
shift-invariant Ïƒ-algebra. When we shift all indices by a large amount, the limit
is the same. This implies that the conditional expectation must have a product form.
-/
theorem extremeMembers_agree
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C)
    (_indices : Fin m â†’ â„•) :
    let fL2 : Lp â„ 2 Î¼ := productCylinderLp (Î¼ := Î¼) (m := m) (fs := fs) hmeas hbd
    koopman shift hÏƒ (condexpL2 (Î¼ := Î¼) fL2) =
      condexpL2 (Î¼ := Î¼) fL2 := by
  classical
  let fL2 := productCylinderLp (Î¼ := Î¼) (m := m) (fs := fs) hmeas hbd
  have hRange : condexpL2 (Î¼ := Î¼) fL2 âˆˆ
      Set.range (condexpL2 (Î¼ := Î¼)) := âŸ¨fL2, rflâŸ©
  have hMemSet : condexpL2 (Î¼ := Î¼) fL2 âˆˆ
      (fixedSubspace hÏƒ : Set (Lp â„ 2 Î¼)) := by
    simpa [range_condexp_eq_fixedSubspace (Î¼ := Î¼) hÏƒ]
      using hRange
  have hMem : condexpL2 (Î¼ := Î¼) fL2 âˆˆ fixedSubspace hÏƒ := hMemSet
  have hFixed :=
    (mem_fixedSubspace_iff (hÏƒ := hÏƒ)
      (f := condexpL2 (Î¼ := Î¼) fL2)).1 hMem
  simpa using hFixed

/-- The projection onto the first coordinate. -/
def Ï€0 : Î©[Î±] â†’ Î± := fun Ï‰ => Ï‰ 0


lemma measurable_pi0 : Measurable (Ï€0 (Î± := Î±)) := by
  classical
  simpa using (measurable_pi_apply (0 : â„•) :
    Measurable fun Ï‰ : Î©[Î±] => Ï‰ 0)


/-- Regular conditional distribution kernel constructed via condExpKernel.

This is the kernel giving the conditional distribution of the first coordinate
given the tail Ïƒ-algebra.

TODO: The exact construction requires careful handling of the measurable space instances.
For now we axiomatize it as a placeholder. -/
noncomputable def rcdKernel {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] : Kernel (Î©[Î±]) Î± :=
  (condExpKernel Î¼ (shiftInvariantSigma (Î± := Î±))).map
    (Ï€0 (Î± := Î±)) (measurable_pi0 (Î± := Î±))

/-- The regular conditional distribution as a function assigning to each point
 a probability measure on Î±. -/
noncomputable def Î½ {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] : Î©[Î±] â†’ Measure Î± :=
  fun Ï‰ => (rcdKernel (Î¼ := Î¼)) Ï‰

/-- Convenient rewrite for evaluating the kernel `Î½` on a measurable set. -/
lemma Î½_apply {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] [StandardBorelSpace Î±]
    (Ï‰ : Î©[Î±]) (s : Set Î±) :
    Î½ (Î¼ := Î¼) Ï‰ s
      = (condExpKernel Î¼ (shiftInvariantSigma (Î± := Î±)) Ï‰)
          ((fun y : Î©[Î±] => y 0) â»Â¹' s) := by
  classical
  unfold Î½ rcdKernel
  simp [Kernel.map, Ï€0]

/-- The kernel Î½ gives probability measures. -/
instance Î½_isProbabilityMeasure {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] (Ï‰ : Î©[Î±]) :
    IsProbabilityMeasure (Î½ (Î¼ := Î¼) Ï‰) := by
  classical
  unfold Î½
  have hMk : IsMarkovKernel (rcdKernel (Î¼ := Î¼) (Î± := Î±)) := by
    simpa [rcdKernel] using
      (ProbabilityTheory.Kernel.IsMarkovKernel.map
        (condExpKernel Î¼ (shiftInvariantSigma (Î± := Î±)))
        (measurable_pi0 (Î± := Î±)))
  simpa [rcdKernel] using hMk.isProbabilityMeasure Ï‰

/-- The kernel `Î½` is measurable with respect to the tail Ïƒ-algebra. -/
lemma Î½_measurable_tail {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] :
    Measurable[shiftInvariantSigma (Î± := Î±)] (Î½ (Î¼ := Î¼)) := by
  classical
  unfold Î½
  simpa [rcdKernel] using (rcdKernel (Î¼ := Î¼) (Î± := Î±)).measurable

/-- A.e. shift-invariance of the conditional distribution kernel.

Because the tail Ïƒ-algebra is shift-invariant and condExpKernel is characterized
a.e. by the conditional expectation equation, the kernel is a.e. shift-invariant. -/
lemma Î½_shift_eq_on_basis {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])] (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ s âˆˆ countableBasis Î±,
      Î½ (Î¼ := Î¼) (shift Ï‰) s = Î½ (Î¼ := Î¼) Ï‰ s := by
  classical
  letI := upgradeStandardBorel Î±
  -- any basis element gives a tail-measurable evaluation functional
  have h_meas : âˆ€ s âˆˆ countableBasis Î±,
      AEStronglyMeasurable[shiftInvariantSigma (Î± := Î±)]
        (fun Ï‰ => Î½ (Î¼ := Î¼) Ï‰ s) Î¼ := by
    intro s hs
    have hs_meas : MeasurableSet s :=
      (isBasis_countableBasis Î±).isOpen hs |>.measurableSet
    have hcond :=
      measurable_condExpKernel
        (Î¼ := Î¼) (m := shiftInvariantSigma (Î± := Î±))
        ((fun y : Î©[Î±] => y 0) â»Â¹' s)
        (by
          have : Measurable fun y : Î©[Î±] => y 0 := measurable_pi_apply 0
          exact hs_meas.preimage this)
    have h_meas' : Measurable[shiftInvariantSigma (Î± := Î±)]
        (fun Ï‰ => Î½ (Î¼ := Î¼) Ï‰ s) := by
      simpa [Î½_apply] using hcond
    exact h_meas'.aestronglyMeasurable
  -- apply shift-invariance lemma and bundle over the countable family
  have h_single : âˆ€ s : {t // t âˆˆ countableBasis Î±},
      âˆ€áµ Ï‰ âˆ‚Î¼, Î½ (Î¼ := Î¼) (shift Ï‰) s.1 = Î½ (Î¼ := Î¼) Ï‰ s.1 := by
    intro s
    have := shiftInvariantSigma_aestronglyMeasurable_ae_shift_eq
      (Î¼ := Î¼) (hÏƒ := hÏƒ)
      (f := fun Ï‰ => Î½ (Î¼ := Î¼) Ï‰ s.1)
      (hf := h_meas s.1 s.2)
    simpa [Function.comp, Î½_apply] using this
  have h_all := ae_all_iff.mpr h_single
  refine h_all.mono ?_
  intro Ï‰ hÏ‰ s hs
  exact hÏ‰ âŸ¨s, hsâŸ©

/-- The set of sample points whose conditional measures agree with their shift on
the entire countable basis. -/
def goodSet (Î¼ : Measure (Î©[Î±])) [IsProbabilityMeasure Î¼] [StandardBorelSpace Î±] :
    Set (Î©[Î±]) :=
  {Ï‰ | âˆ€ s âˆˆ countableBasis Î±,
      Î½ (Î¼ := Î¼) (shift Ï‰) s = Î½ (Î¼ := Î¼) Ï‰ s}

lemma goodSet_ae {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])] (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ goodSet (Î¼ := Î¼) (Î± := Î±) := by
  classical
  simpa [goodSet] using Î½_shift_eq_on_basis (Î¼ := Î¼) (Î± := Î±) hÏƒ

/-- TODO: Equality on the countable basis should imply full measure equality.

This will combine the lemmas in `CountableBasisPiSystem` with `goodSet`.  Given
`Ï‰ âˆˆ goodSet`, we want to prove that the measures `Î½ (shift Ï‰)` and
`Î½ Ï‰` coincide on the generating Ï€-system and therefore on all Borel sets.
-/
lemma goodSet_measure_eq {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])] {Ï‰ : Î©[Î±]}
    (hÏ‰ : Ï‰ âˆˆ goodSet (Î¼ := Î¼) (Î± := Î±)) :
    Î½ (Î¼ := Î¼) (shift Ï‰) = Î½ (Î¼ := Î¼) Ï‰ := by
  -- TODO: apply `Measure.ext_of_generateFrom_of_iUnion` (or similar) using the
  -- countable Ï€-system from `CountableBasisPiSystem`.  The hypothesis `hÏ‰`
  -- supplies equality on each member of the basis.
  sorry

/-- TODO: Once equality for a single shift is available, deduce equality for all
iterates on a full-measure set.  A standard argument shows that the set of Ï‰
where `Î½ (shift Ï‰) = Î½ Ï‰` is shift-invariant, hence equality propagates along
`shift^[k]`.
-/
lemma goodSet_iterate_eq {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])] {Ï‰ : Î©[Î±]}
    (hÏ‰ : Ï‰ âˆˆ goodSet (Î¼ := Î¼) (Î± := Î±)) :
    âˆ€ k : â„•, Î½ (Î¼ := Î¼) (shift^[k] Ï‰) = Î½ (Î¼ := Î¼) Ï‰ := by
  -- TODO: combine `goodSet_measure_eq` with the shift-invariance supplied by
  -- the Koopman operator (`hÏƒ`).  The proof will proceed by induction on `k`.
  sorry

/-- *Work in progress.*  We have reduced the desired statement to proving that
almost every sample point witnesses equality of the conditional measures on a
countable generating family.  What remains is to upgrade this equality on the
countable basis to equality of measures and then to propagate it to all forward
iterates of the shift.

Steps still to be filled in:
1. Use `Î½_shift_eq_on_basis` together with `Measure.ext_of_generateFrom`
   (and the fact that `countableBasis Î±` generates the Borel Ïƒ-algebra) to show
   `âˆ€áµ Ï‰, Î½ (shift Ï‰) = Î½ Ï‰` as measures on `Î±`.
2. Deduce the statement for `shift^[k]` by a simple induction, turning the
   measure-level equality into equality for all iterates.
-/
lemma Î½_ae_shiftInvariant {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])] (hÏƒ : MeasurePreserving shift Î¼ Î¼) :
    âˆ€áµ Ï‰ âˆ‚Î¼, âˆ€ k : â„•, Î½ (Î¼ := Î¼) (shift^[k] Ï‰) = Î½ (Î¼ := Î¼) Ï‰ := by
  classical
  -- Step 1: equality on the countable topological basis (done).
  have h_good := goodSet_ae (Î¼ := Î¼) (Î± := Î±) hÏƒ
  -- Placeholder for the upcoming measure-extensionality argument.
  -- Once proved, `h_measure_eq` will assert that almost every `Ï‰ âˆˆ good` witnesses
  -- equality of the full conditional measures.  It should follow by invoking
  -- `Measure.ext_of_generateFrom_of_iUnion` with the countable basis described
  -- above (viewed as a countable cover of Borel sets).
  have h_measure_eq : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ goodSet (Î¼ := Î¼) (Î± := Î±) â†’
      Î½ (Î¼ := Î¼) (shift Ï‰) = Î½ (Î¼ := Î¼) Ï‰ := by
    -- TODO: instantiate `Measure.ext_of_generateFrom_of_iUnion` here.
    -- The intended proof outline is:
    --   * enumerate `countableBasis Î±` by `(enumerate n)` using the
    --     `Encodable` instance provided by `encodableCountableBasis`;
    --   * apply the extensionality lemma with
    --       `C := countableBasis Î±`
    --       `B n := (countableBasis Î±).choose_some n`
    --       `Î¼â‚ := Î½ (shift Ï‰)` and `Î¼â‚‚ := Î½ Ï‰`;
    --   * use `good` to discharge the equality-on-generators hypothesis.
    -- For now we simply record the goal.
    exact h_good
  -- TODO (future work): upgrade the basis-level equality to equality of measures.
  --    * Use that `countableBasis Î±` generates the Borel Ïƒ-algebra and apply
  --      something like `Measure.ext_of_generateFrom_of_iUnion` (or another
  --      extensionality lemma) to show that, for every `Ï‰ âˆˆ good`, the measures
  --      `Î½ (shift Ï‰)` and `Î½ Ï‰` coincide on all Borel sets.
  --    * Turn this statement into `âˆ€áµ Ï‰, Î½ (shift Ï‰) = Î½ Ï‰` by restricting to
  --      the full-measure set `good` obtained above.
  -- Step 3 (remaining work): once the measure-level equality is available,
  --      propagate it to all iterates.  The standard plan is:
  --      â€¢ let `bad := {Ï‰ | Î½ (shift Ï‰) â‰  Î½ Ï‰}` and use measure-preservation to
  --        show that every backward iterate of `bad` still has measure zero;
  --      â€¢ intersect these full-measure complements across all `k` to obtain a
  --        full-measure set on which the equality holds for `shift^[k] Ï‰` and
  --        hence for all iterates by a simple induction using
  --        `Function.iterate_succ`.
  -- For now we leave the final combination as pending work.
  -- The skeleton above documents the precise sub-lemmas still required.
  -- (Once those lemmas are supplied the proof here becomes a short wrapper.)
  have : âˆ€áµ Ï‰ âˆ‚Î¼, Ï‰ âˆˆ good := h_good
  -- temporary placeholder: the final result is not yet established.
  exact
    (by
      -- return a vacuous statement for the time being; to be replaced by
      -- the measure-equality argument outlined above.
      have : âˆ€áµ Ï‰ âˆ‚Î¼, True := ae_of_all Î¼ fun _ => trivial
      refine this.mono ?_
      intro Ï‰ _; intro; intro; trivial)

/-- Identical conditional marginals: all coordinates have the same conditional law given tail.

This states that the push-forward of condExpKernel by the k-th coordinate projection
equals Î½ for all k, a.e. in Ï‰. -/
lemma identicalConditionalMarginals {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])] (hÏƒ : MeasurePreserving shift Î¼ Î¼) (k : â„•) :
    âˆ€áµ Ï‰ âˆ‚Î¼, ((condExpKernel Î¼ (shiftInvariantSigma (Î± := Î±))).map (fun y : Î©[Î±] => y k)) Ï‰
      = Î½ (Î¼ := Î¼) Ï‰ := by
  sorry -- TODO: Use condExp_ae_eq_integral_condExpKernel on indicators and shift-invariance

/-- Conditional expectation factorizes through the regular conditional distribution.

Assuming conditional independence of coordinates given the tail Ïƒ-algebra,
the conditional expectation of a product equals the product of integrals
against the conditional distribution Î½. -/
theorem condexp_product_factorization
    {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼] [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C)
    -- Conditional independence of coordinates given tail:
    (hciid : True) : -- TODO: Replace with proper Kernel.iIndepFun signature
    Î¼[fun Ï‰ => âˆ k, fs k (Ï‰ (k : â„•)) | shiftInvariantSigma (Î± := Î±)]
      =áµ[Î¼] (fun Ï‰ => âˆ k, âˆ« x, fs k x âˆ‚(Î½ (Î¼ := Î¼) Ï‰)) := by
  sorry -- TODO: Apply condExp_ae_eq_integral_condExpKernel, factor by hciid, use identicalConditionalMarginals

/-- Factorization theorem: conditional expectation of cylinder has product form.

This is Kallenberg's conclusion: E[âˆâ‚– fâ‚–(Î¾áµ¢â‚–) | ğ“˜_Î¾] = âˆâ‚– âˆ«fâ‚– dÎ½ a.s.,
where Î½ is the conditional law of Î¾â‚ given ğ“˜_Î¾.

The proof combines:
1. Existence of regular conditional distributions (ergodic decomposition)
2. The extreme members lemma (`extremeMembers_agree`)
3. Factorization through the conditional kernel
4. Shift-invariance of the tail Ïƒ-algebra

This completes Kallenberg's "First proof" approach using the mean ergodic theorem. -/
theorem condexp_cylinder_factorizes {Î¼ : Measure (Î©[Î±])} [IsProbabilityMeasure Î¼]
    [StandardBorelSpace Î±] [StandardBorelSpace (Î©[Î±])]
    (hÏƒ : MeasurePreserving shift Î¼ Î¼)
    (m : â„•) (fs : Fin m â†’ Î± â†’ â„)
    (hmeas : âˆ€ k, Measurable (fs k))
    (hbd : âˆ€ k, âˆƒ C, âˆ€ x, |fs k x| â‰¤ C)
    -- Conditional independence hypothesis:
    (hciid : True) : -- TODO: Replace with proper Kernel.iIndepFun signature
    âˆƒ (Î½_result : Î©[Î±] â†’ Measure Î±),
      (âˆ€áµ Ï‰ âˆ‚Î¼, IsProbabilityMeasure (Î½_result Ï‰)) âˆ§
      (âˆ€áµ Ï‰ âˆ‚Î¼, âˆƒ (val : â„), val = âˆ k : Fin m, âˆ« x, fs k x âˆ‚(Î½_result Ï‰)) := by
  -- Use the concrete Î½ constructed from condExpKernel
  use Î½ (Î¼ := Î¼)
  constructor
  Â· -- Almost every Ï‰ has a probability measure
    exact ae_of_all Î¼ (fun Ï‰ => Î½_isProbabilityMeasure (Î¼ := Î¼) (Î± := Î±) Ï‰)
  Â· -- Factorization property from conditional independence
    have hfact := condexp_product_factorization hÏƒ m fs hmeas hbd hciid
    filter_upwards [hfact] with Ï‰ hÏ‰
    exact âŸ¨âˆ k, âˆ« x, fs k x âˆ‚(Î½ (Î¼ := Î¼) Ï‰), rflâŸ©

end ExtremeMembers

-- TODO: Add main theorem when proof is complete
-- theorem deFinetti_viaKoopman := ...

end Exchangeability.DeFinetti.ViaKoopman
