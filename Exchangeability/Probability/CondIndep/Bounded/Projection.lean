/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Exchangeability.Probability.CondIndep.Bounded.Extension

/-!
# Conditional Independence - Projection Theorems

This file proves that conditional independence allows projecting conditional
expectations from Ïƒ(Z,W) to Ïƒ(W).

## Main results

* `condExp_project_of_condIndep`: When Y âŠ¥âŠ¥_W Z, conditioning on (Z,W) gives the
  same result as conditioning on W alone for indicator functions of Y.
* `condIndep_project`: Wrapper theorem using the projection property.

## Key insight

Conditional independence means that knowing Z provides no additional information
about Y beyond what W already provides. Therefore E[f(Y)|Ïƒ(Z,W)] = E[f(Y)|Ïƒ(W)].

## References

* Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*, Section 6.1
-/

open scoped Classical

noncomputable section
open scoped MeasureTheory ENNReal
open MeasureTheory ProbabilityTheory Set Exchangeability.Probability

variable {Î© Î± Î² Î³ : Type*}
variable [MeasurableSpace Î©] [MeasurableSpace Î±] [MeasurableSpace Î²] [MeasurableSpace Î³]

set_option maxHeartbeats 500000 in
/-- **Conditional expectation projection from conditional independence (helper).**

When Y âŠ¥âŠ¥_W Z, conditioning on (Z,W) gives the same result as conditioning on W alone
for indicator functions of Y.

This is a key technical lemma used to prove the main projection theorem.
-/
lemma condExp_project_of_condIndep (Î¼ : Measure Î©) [IsProbabilityMeasure Î¼]
    (Y : Î© â†’ Î±) (Z : Î© â†’ Î²) (W : Î© â†’ Î³)
    (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W)
    (h_indep : CondIndep Î¼ Y Z W)
    {A : Set Î±} (hA : MeasurableSet A) :
    Î¼[ Set.indicator (Y â»Â¹' A) (fun _ => (1 : â„))
       | MeasurableSpace.comap (fun Ï‰ => (Z Ï‰, W Ï‰)) (by infer_instance) ]
      =áµ[Î¼]
    Î¼[ Set.indicator (Y â»Â¹' A) (fun _ => (1 : â„))
       | MeasurableSpace.comap W (by infer_instance) ] := by
  -- Strategy: Use uniqueness characterization of conditional expectation
  -- Show that both CEs have the same integrals on all Ïƒ(W)-measurable sets

  -- 0) Name the ambient instance (no abbrev in tactic mode - use let but pin explicitly everywhere)
  let m0 : MeasurableSpace Î© := â€¹MeasurableSpace Î©â€º

  -- Sub-Ïƒ-algebras as plain values (never instances)
  let mW := MeasurableSpace.comap W (by infer_instance)
  let mZW := MeasurableSpace.comap (fun Ï‰ => (Z Ï‰, W Ï‰)) (by infer_instance)
  let f := Set.indicator (Y â»Â¹' A) (fun _ => (1 : â„))

  -- Ïƒ-algebra ordering: Ïƒ(W) âŠ† Ïƒ(Z,W)
  have hle : mW â‰¤ mZW := by
    intro s hs
    obtain âŸ¨T, hT_meas, rflâŸ© := hs
    use Set.univ Ã—Ë¢ T
    constructor
    Â· exact MeasurableSet.univ.prod hT_meas
    Â· ext Ï‰; simp [Set.mem_preimage, Set.mem_prod]

  -- Integrability
  have hf_int : Integrable f Î¼ := by
    apply Integrable.indicator
    Â· exact integrable_const (1 : â„)
    Â· exact hY hA

  -- Key insight: Use tower property and apply uniqueness on Ïƒ(Z,W)
  -- We show Î¼[f|mW] has the same set integrals as f on all Ïƒ(Z,W)-sets

  -- Ïƒ-algebra orderings
  have hmZW_le : mZW â‰¤ _ := (hZ.prodMk hW).comap_le  -- Ïƒ(Z,W) â‰¤ ğ“œ(Î©)

  -- Î¼[f|mW] is Ïƒ(W)-measurable, hence also Ïƒ(Z,W)-measurable (since mW â‰¤ mZW)
  have hgm : AEStronglyMeasurable[mZW] (Î¼[f | mW]) Î¼ :=
    stronglyMeasurable_condExp.aestronglyMeasurable.mono hle

  -- For any S âˆˆ Ïƒ(Z,W): âˆ«_S Î¼[f|mW] = âˆ«_S f
  -- Use Dynkin Ï€-Î» theorem: define C(s) := "integrals match on s"
  have hg_eq : âˆ€ s : Set Î©, MeasurableSet[mZW] s â†’ Î¼ s < âˆ â†’
      âˆ« x in s, (Î¼[f | mW]) x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by
    -- First show: Ïƒ(Z,W) is generated by rectangles Zâ»Â¹(B) âˆ© Wâ»Â¹(C)
    have mZW_gen : mZW = MeasurableSpace.generateFrom
        {s | âˆƒ (B : Set Î²) (C : Set Î³), MeasurableSet B âˆ§ MeasurableSet C âˆ§
             s = Z â»Â¹' B âˆ© W â»Â¹' C} := by
      -- Ïƒ(Z,W) = comap (Z,W) (Ïƒ(Î²Ã—Î³))
      -- Ïƒ(Î²Ã—Î³) = generateFrom {B Ã—Ë¢ C | ...} by generateFrom_prod
      -- comap commutes with generateFrom
      unfold mZW
      conv_lhs => arg 2; rw [â† generateFrom_prod (Î± := Î²) (Î² := Î³)]
      rw [MeasurableSpace.comap_generateFrom]
      congr 1
      ext s
      constructor
      Â· intro âŸ¨t, ht_mem, ht_eqâŸ©
        -- t âˆˆ image2 (Â· Ã—Ë¢ Â·) ... means âˆƒ B C, t = B Ã—Ë¢ C
        -- ht_mem : t âˆˆ image2 (Â·Ã—Ë¢Â·) {B | MeasurableSet B} {C | MeasurableSet C}
        simp only [Set.mem_image2, Set.mem_setOf_eq] at ht_mem
        obtain âŸ¨B, hB, C, hC, rflâŸ© := ht_mem
        use B, C, hB, hC
        -- Need: (Z,W)â»Â¹(B Ã—Ë¢ C) = Zâ»Â¹B âˆ© Wâ»Â¹C
        rw [â† ht_eq]
        ext Ï‰
        simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_prod]
      Â· intro âŸ¨B, C, hB, hC, hs_eqâŸ©
        -- s = Zâ»Â¹B âˆ© Wâ»Â¹C, need to show it's in the preimage image
        simp only [Set.mem_image, Set.mem_image2, Set.mem_setOf_eq]
        use B Ã—Ë¢ C
        refine âŸ¨âŸ¨B, hB, C, hC, rflâŸ©, ?_âŸ©
        rw [hs_eq]
        ext Ï‰
        simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_prod]

    -- Rectangles form a Ï€-system
    have h_pi : IsPiSystem {s | âˆƒ (B : Set Î²) (C : Set Î³), MeasurableSet B âˆ§ MeasurableSet C âˆ§
                                   s = Z â»Â¹' B âˆ© W â»Â¹' C} := by
      -- Need to show: intersection of two rectangles is a rectangle
      intro sâ‚ hsâ‚ sâ‚‚ hsâ‚‚ _
      obtain âŸ¨Bâ‚, Câ‚, hBâ‚, hCâ‚, rflâŸ© := hsâ‚
      obtain âŸ¨Bâ‚‚, Câ‚‚, hBâ‚‚, hCâ‚‚, rflâŸ© := hsâ‚‚
      -- (Zâ»Â¹Bâ‚ âˆ© Wâ»Â¹Câ‚) âˆ© (Zâ»Â¹Bâ‚‚ âˆ© Wâ»Â¹Câ‚‚) = Zâ»Â¹(Bâ‚ âˆ© Bâ‚‚) âˆ© Wâ»Â¹(Câ‚ âˆ© Câ‚‚)
      use Bâ‚ âˆ© Bâ‚‚, Câ‚ âˆ© Câ‚‚
      refine âŸ¨hBâ‚.inter hBâ‚‚, hCâ‚.inter hCâ‚‚, ?_âŸ©
      ext Ï‰
      simp only [Set.mem_inter_iff, Set.mem_preimage]
      tauto

    -- Apply Ï€-Î» induction
    intro s hs hÎ¼s
    apply MeasurableSpace.induction_on_inter (C := fun s _ => âˆ« x in s, (Î¼[f | mW]) x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼)
      mZW_gen h_pi

    Â· -- Empty set
      simp

    Â· -- Basic case: rectangles Zâ»Â¹(B) âˆ© Wâ»Â¹(C)
      intro t ht
      obtain âŸ¨B, C, hB, hC, rflâŸ© := ht
      -- Strategy: Use that Zâ»Â¹B âˆ© Wâ»Â¹C is in mZW, so by tower property and setIntegral_condExp
      -- Key: Zâ»Â¹B âˆ© Wâ»Â¹C âˆˆ Ïƒ(Z,W), so âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} Î¼[f|mZW] = âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} f
      -- And we'll show âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} Î¼[f|mW] = âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} Î¼[f|mZW]

      classical

      -- 1) Ambient measurability, explicitly pinned to m0
      have hZ_m0 : @Measurable Î© Î² m0 _ Z := by simpa [m0] using hZ
      have hW_m0 : @Measurable Î© Î³ m0 _ W := by simpa [m0] using hW

      have hBpre_m0 : @MeasurableSet Î© m0 (Z â»Â¹' B) := hB.preimage hZ_m0
      have hCpre_m0 : @MeasurableSet Î© m0 (W â»Â¹' C) := hC.preimage hW_m0

      -- Sub-Ïƒ-algebra ordering
      have hmW_le : mW â‰¤ m0 := hW_m0.comap_le

      -- mZW-measurable versions of Z and W (by construction of comap)
      have hZ_mZW : @Measurable Î© Î² mZW _ Z := measurable_fst.comp (Measurable.of_comap_le le_rfl)
      have hW_mZW : @Measurable Î© Î³ mZW _ W := measurable_snd.comp (Measurable.of_comap_le le_rfl)

      -- mW-measurable version of W (by construction of mW := comap W)
      have hW_mW : @Measurable Î© Î³ mW _ W := Measurable.of_comap_le le_rfl

      have hBpre : @MeasurableSet Î© mZW (Z â»Â¹' B) := hB.preimage hZ_mZW
      have hCpre_mZW : @MeasurableSet Î© mZW (W â»Â¹' C) := hC.preimage hW_mZW
      have hCpre : @MeasurableSet Î© mW (W â»Â¹' C) := hC.preimage hW_mW

      -- Convenience name for indicator on Zâ»Â¹B (f is already defined in outer scope)
      set gB : Î© â†’ â„ := (Z â»Â¹' B).indicator (fun _ => (1 : â„)) with hgB_def

      -- gB measurability
      have hsm_gB : @StronglyMeasurable Î© â„ _ m0 gB :=
        stronglyMeasurable_const.indicator hBpre_m0

      -- CE basic facts
      have hsm_ce_mW : @StronglyMeasurable Î© â„ _ mW (Î¼[f | mW]) :=
        stronglyMeasurable_condExp
      have hInt_ce : Integrable (Î¼[f | mW]) Î¼ :=
        integrable_condExp

      -- AE version (for use later, keep mW-measurable)
      have haesm_ce : @AEStronglyMeasurable Î© â„ _ mW _ (Î¼[f | mW]) Î¼ :=
        hsm_ce_mW.aestronglyMeasurable

      -- Canonical product â†” indicator identity (use often)
      have h_mul_eq_indicator :
          (fun Ï‰ => Î¼[f|mW] Ï‰ * gB Ï‰) = (Z â»Â¹' B).indicator (Î¼[f|mW]) := by
        funext Ï‰; by_cases hÏ‰ : Ï‰ âˆˆ Z â»Â¹' B
        Â· simp [hgB_def, hÏ‰, Set.indicator_of_mem hÏ‰, mul_one]
        Â· simp [hgB_def, hÏ‰, Set.indicator_of_notMem hÏ‰, mul_zero]

      -- Product integrability: rewrite to indicator, then use Integrable.indicator
      have hint_prod : Integrable (fun Ï‰ => Î¼[f | mW] Ï‰ * gB Ï‰) Î¼ := by
        simpa [h_mul_eq_indicator] using hInt_ce.indicator hBpre_m0

      -- Rectangle is in mZW
      have hrect : MeasurableSet[mZW] (Z â»Â¹' B âˆ© W â»Â¹' C) := by
        -- Zâ»Â¹B âˆ© Wâ»Â¹C = (Z,W)â»Â¹(B Ã—Ë¢ C)
        have : Z â»Â¹' B âˆ© W â»Â¹' C = (fun Ï‰ => (Z Ï‰, W Ï‰)) â»Â¹' (B Ã—Ë¢ C) := by
          ext Ï‰
          simp only [Set.mem_inter_iff, Set.mem_preimage, Set.mem_prod]
        rw [this]
        exact measurableSet_preimage (Measurable.of_comap_le le_rfl) (hB.prod hC)

      -- By setIntegral_condExp on mZW
      have h1 : âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[f | mZW]) x âˆ‚Î¼ = âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, f x âˆ‚Î¼ := by
        exact setIntegral_condExp hmZW_le hf_int hrect

      -- By tower property: E[E[f|mZW]|mW] = E[f|mW] (since mW â‰¤ mZW)
      have h2 : Î¼[Î¼[f | mZW] | mW] =áµ[Î¼] Î¼[f | mW] := by
        exact condExp_condExp_of_le hle hmZW_le

      -- So âˆ«_{rectangle} E[f|mW] = âˆ«_{rectangle} E[E[f|mZW]|mW]
      have h3 : âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[f | mW]) x âˆ‚Î¼ =
                âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[Î¼[f | mZW] | mW]) x âˆ‚Î¼ := by
        apply setIntegral_congr_ae (hmZW_le _ hrect)
        filter_upwards [h2] with x hx _
        exact hx.symm

      -- Now combine: âˆ« Î¼[f|mW] = âˆ« Î¼[Î¼[f|mZW]|mW] (by h3), and we want âˆ« Î¼[f|mW] = âˆ« f
      calc âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[f | mW]) x âˆ‚Î¼
          = âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[Î¼[f | mZW] | mW]) x âˆ‚Î¼ := h3
        _ = âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, f x âˆ‚Î¼ := by
          -- Key: Use CondIndep to show âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} Î¼[Î¼[f|mZW]|mW] = âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} f
          -- By tower property h2, Î¼[Î¼[f|mZW]|mW] =áµ Î¼[f|mW], so enough to show âˆ«_{rect} Î¼[f|mW] = âˆ«_{rect} f

          -- Rewrite LHS using h2
          have : âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[Î¼[f | mZW] | mW]) x âˆ‚Î¼ =
                 âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[f | mW]) x âˆ‚Î¼ := by
            apply setIntegral_congr_ae (hmZW_le _ hrect)
            filter_upwards [h2] with x hx _
            exact hx
          rw [this]

          -- Now show: âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} Î¼[f|mW] = âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} f
          -- Strategy: Use CondIndep to factor through Wâ»Â¹C

          -- Apply CondIndep to sets A and B
          have hCI := h_indep A B hA hB
          -- Gives: E[1_A(Y) Â· 1_B(Z) | Ïƒ(W)] =áµ E[1_A(Y) | Ïƒ(W)] Â· E[1_B(Z) | Ïƒ(W)]

          -- Wâ»Â¹C is Ïƒ(W)-measurable
          have hC_meas : MeasurableSet[mW] (W â»Â¹' C) := by
            exact measurableSet_preimage (Measurable.of_comap_le le_rfl) hC

          -- Integrability of gB (already defined at top of rectangle case)
          have hint_B : Integrable gB Î¼ := by
            apply Integrable.indicator
            Â· exact integrable_const 1
            Â· exact hBpre_m0

          -- Integrability of f * gB: f Â· gB = f Â· 1_{Zâ»Â¹B} = f restricted to Zâ»Â¹B
          have hprod_int : Integrable (f * gB) Î¼ := by
            -- f * gB = (Yâ»Â¹A).indicator(1) * (Zâ»Â¹B).indicator(1)
            -- This is bounded by 1, so integrable
            have : (f * gB) = (Y â»Â¹' A âˆ© Z â»Â¹' B).indicator (fun _ => (1 : â„)) := by
              funext Ï‰
              simp only [Pi.mul_apply, f, gB, Set.indicator_apply]
              by_cases hY : Ï‰ âˆˆ Y â»Â¹' A <;> by_cases hZ : Ï‰ âˆˆ Z â»Â¹' B
              Â· simp [hY, hZ, Set.mem_inter_iff]
              Â· simp [hY, hZ, Set.mem_inter_iff]
              Â· simp [hY, hZ, Set.mem_inter_iff]
              Â· simp [hY, hZ, Set.mem_inter_iff]
            rw [this]
            apply Integrable.indicator
            Â· exact integrable_const 1
            Â· exact (hY hA).inter (hZ hB)

          -- Chain of equalities: âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} Î¼[f|mW] = âˆ«_{Zâ»Â¹B âˆ© Wâ»Â¹C} f

          -- Helper: Wâ»Â¹C is measurable in m0 (already defined above, but re-proving for clarity)
          -- (Actually, use the one from the prelude - this line is redundant)

          calc âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, (Î¼[f | mW]) x âˆ‚Î¼
              = âˆ« x in W â»Â¹' C, (Î¼[f | mW] * gB) x âˆ‚Î¼ := by
                -- Rewrite using indicator: âˆ«_{Wâ»Â¹C âˆ© Zâ»Â¹B} Î¼[f|mW] = âˆ«_{Wâ»Â¹C} (Î¼[f|mW] * gB)
                -- First: LHS = âˆ«_{Wâ»Â¹C} (Zâ»Â¹B).indicator(Î¼[f|mW])
                have h1 : âˆ« Ï‰ in W â»Â¹' C âˆ© Z â»Â¹' B, Î¼[f|mW] Ï‰ âˆ‚Î¼
                        = âˆ« Ï‰ in W â»Â¹' C, (Z â»Â¹' B).indicator (Î¼[f|mW]) Ï‰ âˆ‚Î¼ := by
                  rw [setIntegral_indicator hBpre_m0]
                -- Second: RHS uses h_mul_eq_indicator
                have h2 : âˆ« Ï‰ in W â»Â¹' C, (Z â»Â¹' B).indicator (Î¼[f|mW]) Ï‰ âˆ‚Î¼
                        = âˆ« Ï‰ in W â»Â¹' C, (Î¼[f|mW] Ï‰ * gB Ï‰) âˆ‚Î¼ := by
                  congr 1
                  exact h_mul_eq_indicator.symm
                -- Combine
                rw [Set.inter_comm]
                exact h1.trans h2
            _ = âˆ« x in W â»Â¹' C, (Î¼[f | mW] * Î¼[gB | mW]) x âˆ‚Î¼ := by
                -- Key: For Ïƒ(W)-measurable h: Î¼[h Â· g|Ïƒ(W)] =áµ h Â· Î¼[g|Ïƒ(W)]
                -- Since Î¼[f|mW] is mW-measurable, integrating over Wâ»Â¹C âˆˆ mW gives equality
                have h_pull : Î¼[(Î¼[f | mW]) * gB | mW] =áµ[Î¼] (Î¼[f | mW]) * Î¼[gB | mW] := by
                  refine condExp_mul_of_aestronglyMeasurable_left ?_ ?_ hint_B
                  Â· exact haesm_ce
                  Â· -- Product: bounded measurable * integrable = integrable
                    -- Use hint_prod from prelude
                    exact hint_prod
                -- Apply setIntegral_condExp and the pull-out property
                calc âˆ« x in W â»Â¹' C, (Î¼[f | mW] * gB) x âˆ‚Î¼
                    = âˆ« x in W â»Â¹' C, (Î¼[(Î¼[f | mW]) * gB | mW]) x âˆ‚Î¼ := by
                      -- Use setIntegral_condExp: âˆ«_{Wâ»Â¹C} Î¼[h|mW] = âˆ«_{Wâ»Â¹C} h for Wâ»Â¹C âˆˆ mW
                      -- Avoids needing to prove (Î¼[f|mW]) * gB is mW-measurable
                      have h_set_eq :
                          âˆ« x in W â»Â¹' C, Î¼[(Î¼[f | mW]) * gB | mW] x âˆ‚Î¼
                        = âˆ« x in W â»Â¹' C, ((Î¼[f | mW]) * gB) x âˆ‚Î¼ := by
                        simpa using
                          (setIntegral_condExp (Î¼ := Î¼) (m := mW)
                            (hm := hmW_le) (hs := hCpre) (hf := hint_prod))
                      exact h_set_eq.symm
                  _ = âˆ« x in W â»Â¹' C, ((Î¼[f | mW]) * Î¼[gB | mW]) x âˆ‚Î¼ := by
                      exact setIntegral_congr_ae (hmW_le _ hC_meas) (by filter_upwards [h_pull] with x hx _; exact hx)
            _ = âˆ« x in W â»Â¹' C, (Î¼[f * gB | mW]) x âˆ‚Î¼ := by
                -- Reverse CondIndep factorization: E[f|mW] Â· E[gB|mW] =áµ E[f Â· gB|mW]
                -- Use hCI which states: Î¼[f Â· gB | mW] =áµ Î¼[f | mW] Â· Î¼[gB | mW]
                exact setIntegral_congr_ae (hmW_le _ hC_meas) (by filter_upwards [hCI] with x hx _; exact hx.symm)
            _ = âˆ« x in W â»Â¹' C, (f * gB) x âˆ‚Î¼ := by
                -- Apply setIntegral_condExp
                exact setIntegral_condExp hmW_le hprod_int hC_meas
            _ = âˆ« x in Z â»Â¹' B âˆ© W â»Â¹' C, f x âˆ‚Î¼ := by
                -- Reverse the indicator rewrite: âˆ«_{Wâ»Â¹C} fÂ·gB = âˆ«_{Wâ»Â¹C âˆ© Zâ»Â¹B} f
                -- First: prove pointwise equality f * gB = (Zâ»Â¹B).indicator f
                have h_fg_indicator : (fun Ï‰ => f Ï‰ * gB Ï‰) = (Z â»Â¹' B).indicator f := by
                  funext Ï‰; by_cases hÏ‰ : Ï‰ âˆˆ Z â»Â¹' B
                  Â· simp [hgB_def, hÏ‰, Set.indicator_of_mem hÏ‰, mul_one]
                  Â· simp [hgB_def, hÏ‰, Set.indicator_of_notMem hÏ‰, mul_zero]
                -- Second: rewrite integral
                calc âˆ« Ï‰ in W â»Â¹' C, (f Ï‰ * gB Ï‰) âˆ‚Î¼
                    = âˆ« Ï‰ in W â»Â¹' C, (Z â»Â¹' B).indicator f Ï‰ âˆ‚Î¼ := by
                      congr 1
                  _ = âˆ« Ï‰ in W â»Â¹' C âˆ© Z â»Â¹' B, f Ï‰ âˆ‚Î¼ := by
                      rw [setIntegral_indicator hBpre_m0]
                  _ = âˆ« Ï‰ in Z â»Â¹' B âˆ© W â»Â¹' C, f Ï‰ âˆ‚Î¼ := by
                      rw [Set.inter_comm]

    Â· -- Complement
      intro t htm ht_ind
      -- For complement: âˆ«_{t} g + âˆ«_{tá¶œ} g = âˆ«_Î© g, so âˆ«_{tá¶œ} g = âˆ«_Î© g - âˆ«_t g
      have h_add : âˆ« x in t, (Î¼[f | mW]) x âˆ‚Î¼ + âˆ« x in tá¶œ, (Î¼[f | mW]) x âˆ‚Î¼ = âˆ« x, (Î¼[f | mW]) x âˆ‚Î¼ := by
        exact integral_add_complâ‚€ (hmZW_le _ htm).nullMeasurableSet integrable_condExp
      have h_add' : âˆ« x in t, f x âˆ‚Î¼ + âˆ« x in tá¶œ, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by
        exact integral_add_complâ‚€ (hmZW_le _ htm).nullMeasurableSet hf_int
      -- ht_ind is the equality for t, use it to substitute in h_add
      rw [ht_ind] at h_add
      -- Now we have: âˆ«_t f + âˆ«_{tá¶œ} E[f|mW] = âˆ« E[f|mW]
      -- And we know: âˆ«_t f + âˆ«_{tá¶œ} f = âˆ« f
      -- Also: âˆ« E[f|mW] = âˆ« f (by conditional expectation property)
      have h_total : âˆ« x, (Î¼[f | mW]) x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by
        -- Use integral_condExp: âˆ« Î¼[f|m] = âˆ« f
        -- Requires SigmaFinite (Î¼.trim hle_amb), which follows from IsProbabilityMeasure
        -- Chain: IsProbabilityMeasure â†’ IsFiniteMeasure â†’ IsFiniteMeasure.trim â†’ SigmaFinite.trim
        have hle_amb : mW â‰¤ _ := le_trans hle hmZW_le
        exact integral_condExp hle_amb
      linarith

    Â· -- Countable disjoint union
      intro t_seq hdisjoint htm_seq ht_ind_seq
      -- For disjoint union: âˆ«_{â‹ƒáµ¢ táµ¢} g = Î£áµ¢ âˆ«_{táµ¢} g
      -- Use HasSum for both sides and show they're equal term by term
      -- Convert Disjoint to proper form for hasSum_integral_iUnion
      have hd : Pairwise (Function.onFun Disjoint t_seq) := hdisjoint
      -- Each t_seq i is measurable in ambient space since mZW â‰¤ ambient
      have h1 := hasSum_integral_iUnion (fun i => hmZW_le _ (htm_seq i)) hd
        (integrable_condExp : Integrable (Î¼[f | mW]) Î¼).integrableOn
      have h2 := hasSum_integral_iUnion (fun i => hmZW_le _ (htm_seq i)) hd hf_int.integrableOn
      -- Show the terms are equal using ht_ind_seq, so the sums are equal by uniqueness
      have h_eq : (fun i => âˆ« x in t_seq i, (Î¼[f | mW]) x âˆ‚Î¼) = (fun i => âˆ« x in t_seq i, f x âˆ‚Î¼) :=
        funext ht_ind_seq
      exact h1.unique (h_eq â–¸ h2)

    Â· exact hs

  -- Apply uniqueness: Î¼[f|mW] =áµ Î¼[f|mZW]
  exact (ae_eq_condExp_of_forall_setIntegral_eq hmZW_le hf_int
    (fun _ _ _ => integrable_condExp.integrableOn) hg_eq hgm).symm

/-- **Conditional expectation projection from conditional independence.**

When Y âŠ¥âŠ¥_W Z, conditioning on (Z,W) gives the same result as conditioning on W alone
for functions of Y.

**Key insight:** Conditional independence means that knowing Z provides no additional
information about Y beyond what W already provides. Therefore E[f(Y)|Ïƒ(Z,W)] = E[f(Y)|Ïƒ(W)].

**Proof strategy:**
1. By uniqueness, suffices to show integrals match on Ïƒ(W)-sets
2. For S âˆˆ Ïƒ(W), we have S âˆˆ Ïƒ(Z,W) since Ïƒ(W) â‰¤ Ïƒ(Z,W)
3. So âˆ«_S E[f(Y)|Ïƒ(Z,W)] = âˆ«_S f(Y) by conditional expectation property
4. And âˆ«_S E[f(Y)|Ïƒ(W)] = âˆ«_S f(Y) by conditional expectation property
5. Therefore the integrals match, giving the result

**Alternative via conditional independence definition:**
- Can show E[f(Y)|Ïƒ(Z,W)] is Ïƒ(W)-measurable by using the factorization from CondIndep
- Then apply that conditional expectation of a Ïƒ(W)-measurable function w.r.t. Ïƒ(W) is identity
-/
theorem condIndep_project (Î¼ : Measure Î©) [IsProbabilityMeasure Î¼]
    (Y : Î© â†’ Î±) (Z : Î© â†’ Î²) (W : Î© â†’ Î³)
    (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W)
    (h_indep : CondIndep Î¼ Y Z W)
    {A : Set Î±} (hA : MeasurableSet A) :
    Î¼[ Set.indicator (Y â»Â¹' A) (fun _ => (1 : â„))
       | MeasurableSpace.comap (fun Ï‰ => (Z Ï‰, W Ï‰)) (by infer_instance) ]
      =áµ[Î¼]
    Î¼[ Set.indicator (Y â»Â¹' A) (fun _ => (1 : â„))
       | MeasurableSpace.comap W (by infer_instance) ] := by
  -- This follows directly from the helper lemma
  exact condExp_project_of_condIndep Î¼ Y Z W hY hZ hW h_indep hA

/-!
### Kallenberg 1.3: Indicator Conditional Independence from Drop-Info

Infrastructure for deriving conditional independence from distributional equality
via the "drop information" property for Y.

Note: Helper lemmas `integrable_mul_of_bound_one` and `condExp_indicator_ae_bound_one`
are available from `CondExpHelpers.lean`.
-/
