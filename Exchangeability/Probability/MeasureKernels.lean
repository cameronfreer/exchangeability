/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Constructions.Pi
import Mathlib.MeasureTheory.PiSystem
import Mathlib.Probability.Kernel.Basic

/-!
# Measurability of Product Measure Kernels

This file contains technical lemmas about measurability of product measure kernels.
These lemmas support the de Finetti theorem proof machinery but are general-purpose
results about measure theory on product spaces.

## Main results

* `measurable_prod_ennreal`: Products of measurable ENNReal functions are measurable
* `rectangles_isPiSystem`: Measurable rectangles form a Ï€-system
* `rectangles_generate_pi_sigma`: The product Ïƒ-algebra equals the Ïƒ-algebra generated by rectangles
* `measurable_measure_pi`: Measurability of product measure kernels Ï‰ â†¦ âˆáµ¢ Î½ Ï‰
* `aemeasurable_measure_pi`: AE-measurability version (implies measurable version)

## Implementation notes

These lemmas were extracted from `CommonEnding.lean` to break circular dependencies
between `ConditionallyIID.lean` and `CommonEnding.lean`.

The key technique is Ï€-system induction: proving measurability on rectangles (a Ï€-system)
and extending to all measurable sets via the Ï€-Î» theorem.

## References

* Kallenberg (2005), *Probabilistic Symmetries and Invariance Principles*
-/

noncomputable section
open scoped BigOperators MeasureTheory
open MeasureTheory ProbabilityTheory Set

variable {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]

/-!
## Preliminary lemmas
-/

/-- The product of finitely many measurable ENNReal-valued functions is measurable.

This is a wrapper around `Finset.measurable_prod` specialized to ENNReal.
-/
lemma measurable_prod_ennreal {Î¹ : Type*} [Fintype Î¹] {Î© : Type*} [MeasurableSpace Î©]
    (f : Î¹ â†’ Î© â†’ ENNReal) (hf : âˆ€ i, Measurable (f i)) :
    Measurable fun Ï‰ => âˆ i, f i Ï‰ := by
  apply Finset.measurable_prod
  intro i _
  exact hf i

/-- Rewrite `Set.univ.pi B` as a setOf comprehension.

This is a convenience lemma for working with measurable rectangles in product spaces.
The two forms are definitionally equal but different proof strategies prefer different forms:
- `Set.univ.pi B` is convenient for applying `Measure.pi_pi`
- `{x | âˆ€ i, x i âˆˆ B i}` is convenient for membership reasoning
-/
lemma univ_pi_eq_setOf_forall {Î¹ : Type*} {Î± : Type*} (B : Î¹ â†’ Set Î±) :
    Set.univ.pi B = {x | âˆ€ i, x i âˆˆ B i} := by
  ext x; simp [Set.pi]

/-!
## Ï€-system structure of rectangles
-/

/-- Measurable rectangles form a Ï€-system for the product Ïƒ-algebra.

A rectangle in (Fin m â†’ Î±) is a set of the form {x | âˆ€ i, x i âˆˆ B i} where each B i
is measurable. The collection of such rectangles is closed under finite intersections.
-/
lemma rectangles_isPiSystem {m : â„•} {Î± : Type*} [MeasurableSpace Î±] :
    IsPiSystem {S : Set (Fin m â†’ Î±) | âˆƒ (B : Fin m â†’ Set Î±),
      (âˆ€ i, MeasurableSet (B i)) âˆ§ S = {x | âˆ€ i, x i âˆˆ B i}} := by
  intro Sâ‚ hSâ‚ Sâ‚‚ hSâ‚‚ _hne
  -- Sâ‚ and Sâ‚‚ are rectangles
  obtain âŸ¨Bâ‚, hBâ‚_meas, rflâŸ© := hSâ‚
  obtain âŸ¨Bâ‚‚, hBâ‚‚_meas, rflâŸ© := hSâ‚‚
  -- Their intersection is also a rectangle
  use fun i => Bâ‚ i âˆ© Bâ‚‚ i
  constructor
  Â· intro i
    exact (hBâ‚_meas i).inter (hBâ‚‚_meas i)
  Â· ext x
    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]
    constructor
    Â· intro âŸ¨hâ‚, hâ‚‚âŸ© i
      exact âŸ¨hâ‚ i, hâ‚‚ iâŸ©
    Â· intro h
      exact âŸ¨fun i => (h i).1, fun i => (h i).2âŸ©

/-- The product Ïƒ-algebra on (Fin m â†’ Î±) is generated by measurable rectangles.

This is a fundamental result in product measure theory: the Ïƒ-algebra on a finite
product equals the Ïƒ-algebra generated by measurable rectangles.

Proof strategy:
- The product Ïƒ-algebra is the smallest Ïƒ-algebra making all projections measurable
- A set is in this Ïƒ-algebra iff it's in the Ïƒ-algebra generated by cylinder sets
- Cylinder sets are finite intersections of preimages of projections
- These are exactly the rectangles

In mathlib, this follows from `generateFrom_pi` which establishes the equivalence
between the product Ïƒ-algebra and the Ïƒ-algebra generated by rectangles.
-/
lemma rectangles_generate_pi_sigma {m : â„•} {Î± : Type*} [MeasurableSpace Î±] :
    (inferInstance : MeasurableSpace (Fin m â†’ Î±)) =
    MeasurableSpace.generateFrom {S : Set (Fin m â†’ Î±) | âˆƒ (B : Fin m â†’ Set Î±),
      (âˆ€ i, MeasurableSet (B i)) âˆ§ S = {x | âˆ€ i, x i âˆˆ B i}} := by
  -- The key insight: mathlib's generateFrom_pi shows that for finite index sets,
  -- the product Ïƒ-algebra equals the Ïƒ-algebra generated by measurable rectangles

  -- First establish the set equality: our rectangles match mathlib's rectangle format
  have set_eq : {S : Set (Fin m â†’ Î±) | âˆƒ (B : Fin m â†’ Set Î±),
      (âˆ€ i, MeasurableSet (B i)) âˆ§ S = {x | âˆ€ i, x i âˆˆ B i}} =
      Set.pi univ '' Set.pi univ fun i : Fin m => {s : Set Î± | MeasurableSet s} := by
    ext S
    constructor
    Â· intro âŸ¨B, hB_meas, hSâŸ©
      use fun i => B i
      simp only [Set.mem_pi]
      constructor
      Â· intro i _; exact hB_meas i
      Â· have : univ.pi (fun i => B i) = {x | âˆ€ i, x i âˆˆ B i} := by
          ext x; simp [Set.pi]
        rw [this]; exact hS.symm
    Â· intro âŸ¨B, hB_mem, hSâŸ©
      simp only [Set.mem_pi, Set.mem_univ, Set.mem_setOf_eq] at hB_mem hS
      use B
      constructor
      Â· exact fun i => hB_mem i (Set.mem_univ i)
      Â· have : univ.pi (fun i => B i) = {x | âˆ€ i, x i âˆˆ B i} := by
          ext x; simp [Set.pi]
        rw [â† this]; exact hS.symm

  rw [set_eq]
  exact generateFrom_pi.symm

/-!
## Measurability of product measure kernels
-/

/-- The product measure kernel Ï‰ â†¦ Measure.pi (fun _ => Î½ Ï‰) is measurable.

Given a measurable family of probability measures Î½ : Î© â†’ Measure Î±, the product
kernel Ï‰ â†¦ âˆáµ¢ Î½ Ï‰ (where i ranges over Fin m) is measurable as a measure-valued map.

**Proof strategy**: Use Ï€-system induction on rectangles:
1. Rectangles generate the product Ïƒ-algebra (`rectangles_generate_pi_sigma`)
2. Rectangles form a Ï€-system (`rectangles_isPiSystem`)
3. On rectangles, the product measure of {x | âˆ€ i, x i âˆˆ B i} equals âˆáµ¢ Î½ Ï‰ (B i),
   which is measurable in Ï‰ by `measurable_prod_ennreal`
4. By the Ï€-Î» theorem (`Measurable.measure_of_isPiSystem_of_isProbabilityMeasure`),
   measurability on the generating Ï€-system extends to all measurable sets

This is a key lemma for proving the ConditionallyIID property in de Finetti's theorem.

**Mathematical content**: This shows that finite products of probability kernels
yield measurable kernels, which is essential for disintegration theory and
conditional independence.
-/
lemma measurable_measure_pi {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    {m : â„•}
    (Î½ : Î© â†’ Measure Î±) (hÎ½_prob : âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰))
    (hÎ½_meas : âˆ€ s, MeasurableSet s â†’ Measurable (fun Ï‰ => Î½ Ï‰ s)) :
    Measurable fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰ := by
  classical
  -- Abbreviation for the product kernel
  let Îº : Î© â†’ Measure (Fin m â†’ Î±) := fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰
  -- Rectangular generator and Ï€-system for the product Ïƒ-algebra
  let ğ’ : Set (Set (Fin m â†’ Î±)) :=
    {S | âˆƒ (B : Fin m â†’ Set Î±), (âˆ€ i, MeasurableSet (B i)) âˆ§
        S = {x | âˆ€ i, x i âˆˆ B i}}

  have h_gen : (inferInstance : MeasurableSpace (Fin m â†’ Î±))
      = MeasurableSpace.generateFrom ğ’ :=
    rectangles_generate_pi_sigma (m := m) (Î± := Î±)
  have h_pi : IsPiSystem ğ’ := rectangles_isPiSystem (m := m) (Î± := Î±)

  -- Values on rectangles are measurable
  have h_basic : âˆ€ t âˆˆ ğ’, Measurable fun Ï‰ => Îº Ï‰ t := by
    intro t ht
    rcases ht with âŸ¨B, hB, rflâŸ©
    have rect : (fun Ï‰ => Îº Ï‰ {x : Fin m â†’ Î± | âˆ€ i, x i âˆˆ B i})
        = fun Ï‰ => âˆ i : Fin m, Î½ Ï‰ (B i) := by
      funext Ï‰
      have : {x : Fin m â†’ Î± | âˆ€ i, x i âˆˆ B i}
          = Set.univ.pi fun i => B i := by
        ext x; simp [Set.pi]
      simp [Îº, this, Measure.pi_pi]
    have hfac : âˆ€ i, Measurable fun Ï‰ => Î½ Ï‰ (B i) := by
      intro i; exact hÎ½_meas (B i) (hB i)
    have hmeas : Measurable fun Ï‰ => âˆ i : Fin m, Î½ Ï‰ (B i) :=
      measurable_prod_ennreal (fun i Ï‰ => Î½ Ï‰ (B i)) hfac
    simpa [Îº, rect]

  -- Each product measure is a probability measure
  have hÎº_prob : âˆ€ Ï‰, IsProbabilityMeasure (Îº Ï‰) := by
    intro Ï‰
    classical
    haveI : âˆ€ _ : Fin m, IsProbabilityMeasure (Î½ Ï‰) := fun _ => hÎ½_prob Ï‰
    simp only [Îº]
    infer_instance

  -- Apply Ï€-Î» theorem to extend measurability from rectangles to all measurable sets
  exact Measurable.measure_of_isPiSystem_of_isProbabilityMeasure
    (Î¼ := Îº) (S := ğ’) h_gen h_pi h_basic

/-- AE-measurable version of `measurable_measure_pi`.

This is the version originally proved in `CommonEnding.lean`. The measurable version
`measurable_measure_pi` is stronger and generally more useful, but this AE version
is kept for compatibility.

Note: The hypothesis only requires measurability for **measurable** sets, matching
what `Kernel.measurable_coe` provides. This is the standard requirement in measure theory.
-/
lemma aemeasurable_measure_pi {Î© Î± : Type*} [MeasurableSpace Î©] [MeasurableSpace Î±]
    {Î¼ : Measure Î©} {m : â„•}
    (Î½ : Î© â†’ Measure Î±) (hÎ½_prob : âˆ€ Ï‰, IsProbabilityMeasure (Î½ Ï‰))
    (hÎ½_meas : âˆ€ s, MeasurableSet s â†’ Measurable (fun Ï‰ => Î½ Ï‰ s)) :
    AEMeasurable (fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰) Î¼ := by
  -- The measurable version immediately implies AE-measurability
  have h_meas : Measurable fun Ï‰ => Measure.pi fun _ : Fin m => Î½ Ï‰ := by
    apply measurable_measure_pi Î½ hÎ½_prob
    exact hÎ½_meas
  exact h_meas.aemeasurable

/-!
## Triple product rectangles

These lemmas support Ïƒ-algebra arguments on triple products of the form
`(Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±)`, which arise in the contractable triple pushforward lemma.
-/

/-- Definition of triple rectangles: sets of the form (pi A) Ã— B Ã— (pi C). -/
def TripleRectangles (r k : â„•) (Î± : Type*) [MeasurableSpace Î±] :
    Set (Set ((Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±))) :=
  {S | âˆƒ (A : Fin r â†’ Set Î±) (_ : âˆ€ i, MeasurableSet (A i))
        (B : Set Î±) (_ : MeasurableSet B)
        (C : Fin k â†’ Set Î±) (_ : âˆ€ j, MeasurableSet (C j)),
      S = (Set.univ.pi A) Ã—Ë¢ B Ã—Ë¢ (Set.univ.pi C)}

/-- Triple rectangles form a Ï€-system.

The intersection of two triple rectangles is another triple rectangle, obtained
by intersecting each component. -/
lemma tripleRectangles_isPiSystem {r k : â„•} {Î± : Type*} [MeasurableSpace Î±] :
    IsPiSystem (TripleRectangles r k Î±) := by
  intro Sâ‚ hSâ‚ Sâ‚‚ hSâ‚‚ _
  rcases hSâ‚ with âŸ¨Aâ‚, hAâ‚, Bâ‚, hBâ‚, Câ‚, hCâ‚, rflâŸ©
  rcases hSâ‚‚ with âŸ¨Aâ‚‚, hAâ‚‚, Bâ‚‚, hBâ‚‚, Câ‚‚, hCâ‚‚, rflâŸ©
  refine âŸ¨fun i => Aâ‚ i âˆ© Aâ‚‚ i, ?_, Bâ‚ âˆ© Bâ‚‚, hBâ‚.inter hBâ‚‚,
          fun j => Câ‚ j âˆ© Câ‚‚ j, ?_, ?_âŸ©
  Â· intro i; exact (hAâ‚ i).inter (hAâ‚‚ i)
  Â· intro j; exact (hCâ‚ j).inter (hCâ‚‚ j)
  Â· ext âŸ¨z, y, câŸ©
    simp only [Set.mem_inter_iff, Set.mem_prod, Set.mem_univ_pi]
    constructor
    Â· intro âŸ¨âŸ¨hz1, hy1, hc1âŸ©, hz2, hy2, hc2âŸ©
      exact âŸ¨fun i => âŸ¨hz1 i, hz2 iâŸ©, âŸ¨hy1, hy2âŸ©, fun j => âŸ¨hc1 j, hc2 jâŸ©âŸ©
    Â· intro âŸ¨hz, hy, hcâŸ©
      exact âŸ¨âŸ¨fun i => (hz i).1, hy.1, fun j => (hc j).1âŸ©,
             fun i => (hz i).2, hy.2, fun j => (hc j).2âŸ©

/-- The product Ïƒ-algebra on (Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±) is generated by triple rectangles.

This is a key structural lemma for Ï€-Î» induction on triple products. It shows that
to prove equality of measures on the triple product, it suffices to prove equality
on triple rectangles (provided one shows they form a Ï€-system). -/
lemma tripleRectangles_generate {r k : â„•} {Î± : Type*} [MeasurableSpace Î±] :
    (inferInstance : MeasurableSpace ((Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±)))
      = MeasurableSpace.generateFrom (TripleRectangles r k Î±) := by
  apply le_antisymm
  Â· -- (âŠ†) Product Ïƒ-algebra â‰¤ generateFrom TripleRectangles
    -- Show each projection is measurable w.r.t. generateFrom TripleRectangles

    -- First projection: (Fin r â†’ Î±)
    have h_fst : âˆ€ (A : Fin r â†’ Set Î±), (âˆ€ i, MeasurableSet (A i)) â†’
        MeasurableSet[MeasurableSpace.generateFrom (TripleRectangles r k Î±)]
          (Prod.fst â»Â¹' (Set.univ.pi A)) := by
      intro A hA
      have : (Prod.fst : (Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±) â†’ (Fin r â†’ Î±)) â»Â¹' (Set.univ.pi A) =
          (Set.univ.pi A) Ã—Ë¢ (Set.univ : Set Î±) Ã—Ë¢ (Set.univ.pi (fun (_ : Fin k) => Set.univ)) := by
        ext âŸ¨z, y, câŸ©
        simp only [Set.mem_preimage, Set.mem_prod, Set.mem_univ_pi, Set.mem_univ, true_and]
        tauto
      rw [this]
      apply MeasurableSpace.measurableSet_generateFrom
      exact âŸ¨A, hA, Set.univ, MeasurableSet.univ,
              fun _ => Set.univ, fun _ => MeasurableSet.univ, rflâŸ©

    -- Second projection (middle component): Î±
    have h_fst_snd : âˆ€ (B : Set Î±), MeasurableSet B â†’
        MeasurableSet[MeasurableSpace.generateFrom (TripleRectangles r k Î±)]
          ((Prod.fst âˆ˜ Prod.snd) â»Â¹' B) := by
      intro B hB
      have : (Prod.fst âˆ˜ Prod.snd : (Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±) â†’ Î±) â»Â¹' B =
          (Set.univ.pi (fun (_ : Fin r) => Set.univ)) Ã—Ë¢ B Ã—Ë¢
          (Set.univ.pi (fun (_ : Fin k) => Set.univ)) := by
        ext âŸ¨z, y, câŸ©
        simp only [Set.mem_preimage, Function.comp_apply, Set.mem_prod,
                   Set.mem_univ_pi, Set.mem_univ]
        tauto
      rw [this]
      apply MeasurableSpace.measurableSet_generateFrom
      exact âŸ¨fun _ => Set.univ, fun _ => MeasurableSet.univ,
              B, hB, fun _ => Set.univ, fun _ => MeasurableSet.univ, rflâŸ©

    -- Third projection: (Fin k â†’ Î±)
    have h_snd_snd : âˆ€ (C : Fin k â†’ Set Î±), (âˆ€ j, MeasurableSet (C j)) â†’
        MeasurableSet[MeasurableSpace.generateFrom (TripleRectangles r k Î±)]
          ((Prod.snd âˆ˜ Prod.snd) â»Â¹' (Set.univ.pi C)) := by
      intro C hC
      have : (Prod.snd âˆ˜ Prod.snd : (Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±) â†’ Fin k â†’ Î±) â»Â¹'
          (Set.univ.pi C) =
          (Set.univ.pi (fun (_ : Fin r) => Set.univ)) Ã—Ë¢ Set.univ Ã—Ë¢ (Set.univ.pi C) := by
        ext âŸ¨z, y, câŸ©
        simp only [Set.mem_preimage, Function.comp_apply, Set.mem_prod,
                   Set.mem_univ_pi, Set.mem_univ]
        tauto
      rw [this]
      apply MeasurableSpace.measurableSet_generateFrom
      exact âŸ¨fun _ => Set.univ, fun _ => MeasurableSet.univ,
              Set.univ, MeasurableSet.univ, C, hC, rflâŸ©

    -- Comap of first projection â‰¤ generateFrom
    have h_fst_comap : MeasurableSpace.comap Prod.fst inferInstance
        â‰¤ MeasurableSpace.generateFrom (TripleRectangles r k Î±) := by
      rw [â† measurable_iff_comap_le]
      rw [MeasurableSpace.pi_eq_generateFrom_projections (Î¹ := Fin r) (Î± := fun _ => Î±)]
      apply @measurable_generateFrom _ _ (MeasurableSpace.generateFrom (TripleRectangles r k Î±)) _ _
      intro s hs
      obtain âŸ¨i, A, hA, rflâŸ© := hs
      let D : Fin r â†’ Set Î± := fun j => if j = i then A else Set.univ
      have hD : âˆ€ j, MeasurableSet (D j) := by
        intro j; simp only [D]; split_ifs; exact hA; exact MeasurableSet.univ
      have : (fun f : Fin r â†’ Î± => f i) â»Â¹' A = Set.univ.pi D := by
        ext f; simp only [D, Set.mem_preimage, Set.mem_univ_pi]
        constructor
        Â· intro hf j; by_cases h : j = i <;> simp [h, hf]
        Â· intro hf; simpa using hf i
      rw [this]
      exact h_fst D hD

    -- Comap of middle projection â‰¤ generateFrom
    have h_fst_snd_comap : MeasurableSpace.comap (Prod.fst âˆ˜ Prod.snd) inferInstance
        â‰¤ MeasurableSpace.generateFrom (TripleRectangles r k Î±) := by
      intro s hs
      obtain âŸ¨B, hB, rflâŸ© := hs
      exact h_fst_snd B hB

    -- Comap of third projection â‰¤ generateFrom
    have h_snd_snd_comap : MeasurableSpace.comap (Prod.snd âˆ˜ Prod.snd) inferInstance
        â‰¤ MeasurableSpace.generateFrom (TripleRectangles r k Î±) := by
      rw [â† measurable_iff_comap_le]
      rw [MeasurableSpace.pi_eq_generateFrom_projections (Î¹ := Fin k) (Î± := fun _ => Î±)]
      apply @measurable_generateFrom _ _ (MeasurableSpace.generateFrom (TripleRectangles r k Î±)) _ _
      intro s hs
      obtain âŸ¨j, C, hC, rflâŸ© := hs
      let D : Fin k â†’ Set Î± := fun i => if i = j then C else Set.univ
      have hD : âˆ€ i, MeasurableSet (D i) := by
        intro i; simp only [D]; split_ifs; exact hC; exact MeasurableSet.univ
      have : (fun f : Fin k â†’ Î± => f j) â»Â¹' C = Set.univ.pi D := by
        ext f; simp only [D, Set.mem_preimage, Set.mem_univ_pi]
        constructor
        Â· intro hf i; by_cases h : i = j <;> simp [h, hf]
        Â· intro hf; simpa using hf j
      rw [this]
      exact h_snd_snd D hD

    -- The product Ïƒ-algebra is comap fst âŠ” comap snd
    have : (inferInstance : MeasurableSpace ((Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±))) =
        MeasurableSpace.comap Prod.fst inferInstance âŠ”
        MeasurableSpace.comap Prod.snd inferInstance := rfl
    rw [this]

    -- Comap snd decomposes into comap (fst âˆ˜ snd) âŠ” comap (snd âˆ˜ snd)
    have h_snd_le : MeasurableSpace.comap
        (Prod.snd : (Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±) â†’ Î± Ã— (Fin k â†’ Î±)) inferInstance
        â‰¤ MeasurableSpace.generateFrom (TripleRectangles r k Î±) := by
      calc MeasurableSpace.comap
            (Prod.snd : (Fin r â†’ Î±) Ã— Î± Ã— (Fin k â†’ Î±) â†’ Î± Ã— (Fin k â†’ Î±)) inferInstance
          = MeasurableSpace.comap Prod.snd
              (MeasurableSpace.comap Prod.fst inferInstance âŠ”
               MeasurableSpace.comap Prod.snd inferInstance) := rfl
        _ = MeasurableSpace.comap Prod.snd (MeasurableSpace.comap Prod.fst inferInstance)
            âŠ” MeasurableSpace.comap Prod.snd (MeasurableSpace.comap Prod.snd inferInstance) := by
              rw [MeasurableSpace.comap_sup]
        _ = MeasurableSpace.comap (Prod.fst âˆ˜ Prod.snd) inferInstance
            âŠ” MeasurableSpace.comap (Prod.snd âˆ˜ Prod.snd) inferInstance := by
              rw [MeasurableSpace.comap_comp, MeasurableSpace.comap_comp]
        _ â‰¤ MeasurableSpace.generateFrom (TripleRectangles r k Î±) :=
              sup_le h_fst_snd_comap h_snd_snd_comap
    exact sup_le h_fst_comap h_snd_le

  Â· -- (âŠ‡) generateFrom TripleRectangles â‰¤ Product Ïƒ-algebra
    apply MeasurableSpace.generateFrom_le
    intro t ht
    obtain âŸ¨A, hA, B, hB, C, hC, rflâŸ© := ht
    exact (MeasurableSet.univ_pi hA).prod (hB.prod (MeasurableSet.univ_pi hC))
