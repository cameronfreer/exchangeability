/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique
import Mathlib.MeasureTheory.Function.AEEqOfIntegral
import Mathlib.Probability.ConditionalExpectation
import Mathlib.Probability.Independence.Conditional

/-!
# Helper lemmas for conditional expectation

This file contains helper lemmas for working with conditional expectations,
particularly for uniqueness arguments via set integrals and σ-algebra factorizations.

These lemmas support the proof of de Finetti's theorem via martingales, specifically
the three key lemmas about conditional independence and factorization.

## Main results

* `sigma_factor_le`: Pullback σ-algebra inequality for factorizations
* `condExp_eq_of_setIntegral_eq`: Conditional expectation uniqueness via set integrals
* `condExp_project_of_le`: Tower/projection property μ[μ[f|m']|m] = μ[f|m] for m ≤ m'

## Implementation notes

These are minimal "workaround" lemmas that wrap or slightly extend mathlib's
conditional expectation API for the specific needs of the de Finetti proof.

-/

noncomputable section
open scoped MeasureTheory ENNReal
open MeasureTheory ProbabilityTheory Set

/-!
## σ-algebra factorization
-/

/-- **Pullback σ-algebra inequality for factorizations.**

If `η = g ∘ ζ` with `g` measurable, then the σ-algebra generated by `η`
is contained in the σ-algebra generated by `ζ`.

This is the fundamental fact about σ-algebra factorization: knowing `ζ` gives
you at least as much information as knowing `η = g(ζ)`.

**Mathematical statement:** σ(η) ≤ σ(ζ) when η = g ∘ ζ.
-/
lemma sigma_factor_le {Ω α β : Type*}
    [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β]
    {η : Ω → α} {ζ : Ω → β} {g : β → α}
    (hη : η = g ∘ ζ) (hg : Measurable g) :
    MeasurableSpace.comap η inferInstance ≤ MeasurableSpace.comap ζ inferInstance := by
  -- Key idea: η = g ∘ ζ with g measurable implies σ(η) ≤ σ(ζ)
  -- Every η-measurable set has form η⁻¹(t) = (g∘ζ)⁻¹(t) = ζ⁻¹(g⁻¹(t))
  intro s hs
  -- hs : s ∈ σ(η) means s = η⁻¹(t) for some measurable t
  obtain ⟨t, ht, rfl⟩ := hs
  -- Rewrite using hη: η⁻¹(t) = ζ⁻¹(g⁻¹(t))
  rw [hη, Set.preimage_comp]
  -- Goal: ζ⁻¹(g⁻¹(t)) ∈ σ(ζ)
  exact ⟨g ⁻¹' t, hg ht, rfl⟩

/-!
## Convenience lemmas for set integrals
-/

namespace MeasureTheory

/-- **Conditional expectation uniqueness for functions with matching integrals on sub-σ-algebra.**

If g is m-measurable and has the same integral as f on all m-measurable sets,
then g equals the conditional expectation μ[f|m] almost everywhere.

This is the fundamental uniqueness property of conditional expectation: it is
uniquely determined (up to a.e. equality) by being m-measurable and having the
correct set-integral property on m-measurable sets.

The proof uses the uniqueness lemma from mathlib, requiring us to verify the
integral property holds on all ambient measurable sets (not just m-measurable ones).
For this, we use the fact that both g and μ[f|m] are m-measurable, so their
integrals on ambient sets are determined by their values on m-measurable components.
-/
lemma condExp_eq_of_setIntegral_eq {α : Type*} (m m₀ : MeasurableSpace α) {μ : Measure α}
    (hm : m ≤ m₀) [SigmaFinite (Measure.trim μ hm)]
    {f g : α → ℝ}
    (hg_meas : Measurable[m] g)
    (hf_int : Integrable f μ)
    (hg_int : Integrable g μ)
    (h : ∀ s, MeasurableSet[m] s → μ s < ∞ → ∫ x in s, g x ∂μ = ∫ x in s, f x ∂μ) :
    μ[f | m] =ᵐ[μ] g := by
  -- Strategy: Show condExp and g have equal integrals on all m-measurable sets,
  -- then use uniqueness

  -- Step 1: Show condExp m μ f and g have matching integrals on m-measurable sets
  have hint_eq : ∀ s, MeasurableSet[m] s → μ s < ∞ →
      ∫ x in s, (μ[f | m]) x ∂μ = ∫ x in s, g x ∂μ := by
    intro s hs hμs
    rw [setIntegral_condExp hm hf_int hs]
    exact (h s hs hμs).symm

  -- Step 2: Both functions are integrable
  have hcond_int : Integrable (μ[f | m]) μ := integrable_condExp

  -- Step 3: Key insight - work on the trimmed measure μ.trim hm
  -- On the trimmed measure, ALL measurable sets are exactly the m-measurable sets

  -- Both functions are m-measurable
  have hcond_meas : StronglyMeasurable[m] (μ[f | m]) := stronglyMeasurable_condExp
  have hg_smeas : StronglyMeasurable[m] g := hg_meas.stronglyMeasurable

  -- Convert integrability to trimmed measure
  have hcond_int_trim : Integrable (μ[f | m]) (μ.trim hm) :=
    hcond_int.trim hm hcond_meas
  have hg_int_trim : Integrable g (μ.trim hm) :=
    hg_int.trim hm hg_smeas

  -- On the trimmed measure, show integrals agree on all measurable sets
  -- Key: set integrals on trim equal set integrals on original when functions are m-measurable
  have hint_eq_trim : ∀ s, MeasurableSet[m] s → (μ.trim hm) s < ∞ →
      ∫ x in s, (μ[f | m]) x ∂(μ.trim hm) = ∫ x in s, g x ∂(μ.trim hm) := by
    intro s hs hμs
    -- Convert set integrals from trim to original measure
    rw [← setIntegral_trim hm hcond_meas hs, ← setIntegral_trim hm hg_smeas hs]
    -- Measure values agree on m-measurable sets
    rw [trim_measurableSet_eq hm hs] at hμs
    exact hint_eq s hs hμs

  -- Apply uniqueness on the trimmed measure
  -- Note: on μ.trim hm, MeasurableSet s means MeasurableSet[m] s
  have heq_trim : (μ[f | m]) =ᵐ[μ.trim hm] g := by
    refine Integrable.ae_eq_of_forall_setIntegral_eq (μ[f | m]) g hcond_int_trim hg_int_trim ?_
    intro s hs hμs
    -- hs : MeasurableSet s in the context of μ.trim hm, which uses measurable space m
    -- So this is automatically MeasurableSet[m] s
    exact hint_eq_trim s hs hμs

  -- Lift equality from trimmed measure to original measure
  exact ae_eq_of_ae_eq_trim heq_trim

/-- **Conditional expectation projection property.**

If m ≤ m' are sub-σ-algebras, then projecting from m' down to m via conditional
expectation is idempotent: μ[μ[f|m']|m] = μ[f|m] almost everywhere.

**Mathematical content:** This is the "tower property" or "projection property" for
conditional expectations. It says that conditioning twice (first on the finer σ-algebra m',
then on the coarser σ-algebra m) gives the same result as conditioning once on m.

**Intuition:** If you know less information (m ⊆ m'), then averaging over the additional
information in m' brings you back to what you'd get by conditioning on m directly.

**Application:** This is the key lemma for de Finetti's theorem Route 1, where we have
σ(η) ≤ σ(ζ) and need to show that μ[μ[f|σ(ζ)]|σ(η)] = μ[f|σ(η)].

**Proof strategy:** Use the uniqueness characterization (`condExp_eq_of_setIntegral_eq`):
1. Define Yproj := μ[μ[f|m']|m], which is automatically m-measurable
2. Show that for every m-measurable set S, ∫_S Yproj = ∫_S f via two-step projection:
   - First: ∫_S Yproj = ∫_S μ[f|m'] (by CE property on m-sets)
   - Second: ∫_S μ[f|m'] = ∫_S f (by CE property, using m ≤ m' so S is also m'-measurable)
3. By uniqueness, Yproj = μ[f|m] a.e.
-/
lemma condExp_project_of_le {α : Type*} (m m' m₀ : MeasurableSpace α) {μ : Measure α}
    (hm : m ≤ m₀) (hm' : m' ≤ m₀) (h_le : m ≤ m')
    [SigmaFinite (Measure.trim μ hm)] [SigmaFinite (Measure.trim μ hm')]
    {f : α → ℝ} (hf_int : Integrable f μ) :
    μ[ μ[f | m'] | m ] =ᵐ[μ] μ[f | m] := by
  -- Define the projected representative
  set Yproj := μ[ μ[f | m'] | m ]

  -- Show integrals match on m-measurable sets via two-step projection
  have hYproj_integrals : ∀ s, MeasurableSet[m] s → μ s < ∞ →
      ∫ x in s, Yproj x ∂μ = ∫ x in s, f x ∂μ := by
    intro s hs hμs
    -- First projection step: use CE property on m-sets
    have step1 : ∫ x in s, Yproj x ∂μ = ∫ x in s, μ[f | m'] x ∂μ := by
      have : SigmaFinite (μ.trim hm) := inferInstance
      simpa [Yproj] using setIntegral_condExp hm integrable_condExp hs
    -- Second step: s is also m'-measurable since m ≤ m'
    calc
      ∫ x in s, Yproj x ∂μ
          = ∫ x in s, μ[f | m'] x ∂μ := step1
      _   = ∫ x in s, f x ∂μ := by
        have hs' : MeasurableSet[m'] s := h_le s hs
        have : SigmaFinite (μ.trim hm') := inferInstance
        simpa using setIntegral_condExp hm' hf_int hs'

  -- Apply uniqueness
  have hYproj : Yproj =ᵐ[μ] μ[f | m] := by
    refine ae_eq_condExp_of_forall_setIntegral_eq hm hf_int ?integrableOn hYproj_integrals ?sm
    · intro s hs hμs
      exact integrable_condExp.integrableOn
    · exact stronglyMeasurable_condExp.aestronglyMeasurable

  exact hYproj

/-!
## Conditional expectation projection under conditional independence
-/

/-- **Helper: set integral equals integral of indicator product.** -/
private lemma setIntegral_eq_integral_indicator {α : Type*} [MeasurableSpace α] {μ : Measure α}
    {s : Set α} (hs : MeasurableSet s) {f : α → ℝ} :
    ∫ x in s, f x ∂μ = ∫ x, f x * (s.indicator (1 : α → ℝ)) x ∂μ := by
  sorry  -- TODO: Standard rewriting with indicator - mechanical

/-- **Projection under conditional independence (rectangle + π-λ approach).**

If Y ⊥⊥_W Z (conditional independence), then for any integrable f:
  E[f(Y) | σ(Z,W)] = E[f(Y) | σ(W)] a.e.

**Key insight:** We prove equality by showing both sides have matching integrals on all
σ(Z,W)-measurable sets, using:
1. Rectangle identity on S ∩ Z^{-1}(B) for S ∈ σ(W), B ∈ B_Z
2. π-λ theorem to extend to all of σ(Z,W)
3. Uniqueness of conditional expectation

**This bypasses the disintegration bottleneck:** We never prove E[f(Y)|σ(Z,W)] is σ(W)-measurable
directly. Instead, we show it equals E[f(Y)|σ(W)] (which is already σ(W)-measurable), so
measurability comes for free from uniqueness.
-/
theorem condExp_project_of_condIndepFun
    {Ω βY βZ βW : Type*}
    {mΩ : MeasurableSpace Ω} {μ : Measure Ω} [IsProbabilityMeasure μ]
    [MeasurableSpace βY] [MeasurableSpace βZ] [MeasurableSpace βW]
    [StandardBorelSpace Ω] [StandardBorelSpace βY] [StandardBorelSpace βZ] [StandardBorelSpace βW]
    [Nonempty βY] [Nonempty βZ] [Nonempty βW]
    {Y : Ω → βY} {Z : Ω → βZ} {W : Ω → βW}
    (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W)
    (hCI : ProbabilityTheory.CondIndepFun (MeasurableSpace.comap W inferInstance)
                                           (by intro s hs; obtain ⟨t, ht, rfl⟩ := hs; exact hW ht)
                                           Y Z μ)
    {f : βY → ℝ} (hf_int : Integrable (f ∘ Y) μ) :
    μ[ f ∘ Y | MeasurableSpace.comap (fun ω => (Z ω, W ω)) inferInstance ]
      =ᵐ[μ]
    μ[ f ∘ Y | MeasurableSpace.comap W inferInstance ] := by
  -- Shorthand
  set mW  := MeasurableSpace.comap W inferInstance
  set mZ  := MeasurableSpace.comap Z inferInstance
  set mZW := mZ ⊔ mW with hmZW_def

  have hmW_le : mW ≤ mΩ := by intro s hs; obtain ⟨t, ht, rfl⟩ := hs; exact hW ht
  have hmZ_le : mZ ≤ mΩ := by intro s hs; obtain ⟨t, ht, rfl⟩ := hs; exact hZ ht
  have hmZW_le : mZW ≤ mΩ := sup_le hmZ_le hmW_le
  have hmW_le_mZW : mW ≤ mZW := le_sup_right
  have hmZ_le_mZW : mZ ≤ mZW := le_sup_left

  -- Define g := E[f(Y)|σ(W)]
  set g := μ[ f ∘ Y | mW ] with hg_def

  sorry  -- Full implementation to follow

end MeasureTheory

end
