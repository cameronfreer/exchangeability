/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique
import Mathlib.MeasureTheory.Function.AEEqOfIntegral
import Mathlib.Probability.ConditionalExpectation
import Mathlib.Probability.Independence.Conditional

/-!
# Helper lemmas for conditional expectation

This file contains helper lemmas for working with conditional expectations,
particularly for uniqueness arguments via set integrals and σ-algebra factorizations.

These lemmas support the proof of de Finetti's theorem via martingales, specifically
the three key lemmas about conditional independence and factorization.

## Main results

* `sigma_factor_le`: Pullback σ-algebra inequality for factorizations
* `condExp_eq_of_setIntegral_eq`: Conditional expectation uniqueness via set integrals
* `condExp_project_of_le`: Tower/projection property μ[μ[f|m']|m] = μ[f|m] for m ≤ m'

## Implementation notes

These are minimal "workaround" lemmas that wrap or slightly extend mathlib's
conditional expectation API for the specific needs of the de Finetti proof.

-/

noncomputable section
open scoped MeasureTheory ENNReal
open MeasureTheory ProbabilityTheory Set

/-!
## σ-algebra factorization
-/

/-- **Pullback σ-algebra inequality for factorizations.**

If `η = g ∘ ζ` with `g` measurable, then the σ-algebra generated by `η`
is contained in the σ-algebra generated by `ζ`.

This is the fundamental fact about σ-algebra factorization: knowing `ζ` gives
you at least as much information as knowing `η = g(ζ)`.

**Mathematical statement:** σ(η) ≤ σ(ζ) when η = g ∘ ζ.
-/
lemma sigma_factor_le {Ω α β : Type*}
    [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β]
    {η : Ω → α} {ζ : Ω → β} {g : β → α}
    (hη : η = g ∘ ζ) (hg : Measurable g) :
    MeasurableSpace.comap η inferInstance ≤ MeasurableSpace.comap ζ inferInstance := by
  -- Key idea: η = g ∘ ζ with g measurable implies σ(η) ≤ σ(ζ)
  -- Every η-measurable set has form η⁻¹(t) = (g∘ζ)⁻¹(t) = ζ⁻¹(g⁻¹(t))
  intro s hs
  -- hs : s ∈ σ(η) means s = η⁻¹(t) for some measurable t
  obtain ⟨t, ht, rfl⟩ := hs
  -- Rewrite using hη: η⁻¹(t) = ζ⁻¹(g⁻¹(t))
  rw [hη, Set.preimage_comp]
  -- Goal: ζ⁻¹(g⁻¹(t)) ∈ σ(ζ)
  exact ⟨g ⁻¹' t, hg ht, rfl⟩

/-!
## Convenience lemmas for set integrals
-/

namespace MeasureTheory

/-- **Conditional expectation uniqueness for functions with matching integrals on sub-σ-algebra.**

If g is m-measurable and has the same integral as f on all m-measurable sets,
then g equals the conditional expectation μ[f|m] almost everywhere.

This is the fundamental uniqueness property of conditional expectation: it is
uniquely determined (up to a.e. equality) by being m-measurable and having the
correct set-integral property on m-measurable sets.

The proof uses the uniqueness lemma from mathlib, requiring us to verify the
integral property holds on all ambient measurable sets (not just m-measurable ones).
For this, we use the fact that both g and μ[f|m] are m-measurable, so their
integrals on ambient sets are determined by their values on m-measurable components.
-/
lemma condExp_eq_of_setIntegral_eq {α : Type*} (m m₀ : MeasurableSpace α) {μ : Measure α}
    (hm : m ≤ m₀) [SigmaFinite (Measure.trim μ hm)]
    {f g : α → ℝ}
    (hg_meas : Measurable[m] g)
    (hf_int : Integrable f μ)
    (hg_int : Integrable g μ)
    (h : ∀ s, MeasurableSet[m] s → μ s < ∞ → ∫ x in s, g x ∂μ = ∫ x in s, f x ∂μ) :
    μ[f | m] =ᵐ[μ] g := by
  -- Strategy: Show condExp and g have equal integrals on all m-measurable sets,
  -- then use uniqueness

  -- Step 1: Show condExp m μ f and g have matching integrals on m-measurable sets
  have hint_eq : ∀ s, MeasurableSet[m] s → μ s < ∞ →
      ∫ x in s, (μ[f | m]) x ∂μ = ∫ x in s, g x ∂μ := by
    intro s hs hμs
    rw [setIntegral_condExp hm hf_int hs]
    exact (h s hs hμs).symm

  -- Step 2: Both functions are integrable
  have hcond_int : Integrable (μ[f | m]) μ := integrable_condExp

  -- Step 3: Key insight - work on the trimmed measure μ.trim hm
  -- On the trimmed measure, ALL measurable sets are exactly the m-measurable sets

  -- Both functions are m-measurable
  have hcond_meas : StronglyMeasurable[m] (μ[f | m]) := stronglyMeasurable_condExp
  have hg_smeas : StronglyMeasurable[m] g := hg_meas.stronglyMeasurable

  -- Convert integrability to trimmed measure
  have hcond_int_trim : Integrable (μ[f | m]) (μ.trim hm) :=
    hcond_int.trim hm hcond_meas
  have hg_int_trim : Integrable g (μ.trim hm) :=
    hg_int.trim hm hg_smeas

  -- On the trimmed measure, show integrals agree on all measurable sets
  -- Key: set integrals on trim equal set integrals on original when functions are m-measurable
  have hint_eq_trim : ∀ s, MeasurableSet[m] s → (μ.trim hm) s < ∞ →
      ∫ x in s, (μ[f | m]) x ∂(μ.trim hm) = ∫ x in s, g x ∂(μ.trim hm) := by
    intro s hs hμs
    -- Convert set integrals from trim to original measure
    rw [← setIntegral_trim hm hcond_meas hs, ← setIntegral_trim hm hg_smeas hs]
    -- Measure values agree on m-measurable sets
    rw [trim_measurableSet_eq hm hs] at hμs
    exact hint_eq s hs hμs

  -- Apply uniqueness on the trimmed measure
  -- Note: on μ.trim hm, MeasurableSet s means MeasurableSet[m] s
  have heq_trim : (μ[f | m]) =ᵐ[μ.trim hm] g := by
    refine Integrable.ae_eq_of_forall_setIntegral_eq (μ[f | m]) g hcond_int_trim hg_int_trim ?_
    intro s hs hμs
    -- hs : MeasurableSet s in the context of μ.trim hm, which uses measurable space m
    -- So this is automatically MeasurableSet[m] s
    exact hint_eq_trim s hs hμs

  -- Lift equality from trimmed measure to original measure
  exact ae_eq_of_ae_eq_trim heq_trim

/-- **Conditional expectation projection property.**

If m ≤ m' are sub-σ-algebras, then projecting from m' down to m via conditional
expectation is idempotent: μ[μ[f|m']|m] = μ[f|m] almost everywhere.

**Mathematical content:** This is the "tower property" or "projection property" for
conditional expectations. It says that conditioning twice (first on the finer σ-algebra m',
then on the coarser σ-algebra m) gives the same result as conditioning once on m.

**Intuition:** If you know less information (m ⊆ m'), then averaging over the additional
information in m' brings you back to what you'd get by conditioning on m directly.

**Application:** This is the key lemma for de Finetti's theorem Route 1, where we have
σ(η) ≤ σ(ζ) and need to show that μ[μ[f|σ(ζ)]|σ(η)] = μ[f|σ(η)].

**Proof strategy:** Use the uniqueness characterization (`condExp_eq_of_setIntegral_eq`):
1. Define Yproj := μ[μ[f|m']|m], which is automatically m-measurable
2. Show that for every m-measurable set S, ∫_S Yproj = ∫_S f via two-step projection:
   - First: ∫_S Yproj = ∫_S μ[f|m'] (by CE property on m-sets)
   - Second: ∫_S μ[f|m'] = ∫_S f (by CE property, using m ≤ m' so S is also m'-measurable)
3. By uniqueness, Yproj = μ[f|m] a.e.
-/
lemma condExp_project_of_le {α : Type*} (m m' m₀ : MeasurableSpace α) {μ : Measure α}
    (hm : m ≤ m₀) (hm' : m' ≤ m₀) (h_le : m ≤ m')
    [SigmaFinite (Measure.trim μ hm)] [SigmaFinite (Measure.trim μ hm')]
    {f : α → ℝ} (hf_int : Integrable f μ) :
    μ[ μ[f | m'] | m ] =ᵐ[μ] μ[f | m] := by
  -- Define the projected representative
  set Yproj := μ[ μ[f | m'] | m ]

  -- Show integrals match on m-measurable sets via two-step projection
  have hYproj_integrals : ∀ s, MeasurableSet[m] s → μ s < ∞ →
      ∫ x in s, Yproj x ∂μ = ∫ x in s, f x ∂μ := by
    intro s hs hμs
    -- First projection step: use CE property on m-sets
    have step1 : ∫ x in s, Yproj x ∂μ = ∫ x in s, μ[f | m'] x ∂μ := by
      have : SigmaFinite (μ.trim hm) := inferInstance
      simpa [Yproj] using setIntegral_condExp hm integrable_condExp hs
    -- Second step: s is also m'-measurable since m ≤ m'
    calc
      ∫ x in s, Yproj x ∂μ
          = ∫ x in s, μ[f | m'] x ∂μ := step1
      _   = ∫ x in s, f x ∂μ := by
        have hs' : MeasurableSet[m'] s := h_le s hs
        have : SigmaFinite (μ.trim hm') := inferInstance
        simpa using setIntegral_condExp hm' hf_int hs'

  -- Apply uniqueness
  have hYproj : Yproj =ᵐ[μ] μ[f | m] := by
    refine ae_eq_condExp_of_forall_setIntegral_eq hm hf_int ?integrableOn hYproj_integrals ?sm
    · intro s hs hμs
      exact integrable_condExp.integrableOn
    · exact stronglyMeasurable_condExp.aestronglyMeasurable

  exact hYproj

/-!
## Conditional expectation projection under conditional independence
-/

/-- **Helper: set integral equals integral of indicator product.**

This helper is currently not used in the main proof but documents a standard identity.
-/
private lemma setIntegral_eq_integral_indicator {α : Type*} [MeasurableSpace α] {μ : Measure α}
    {s : Set α} (hs : MeasurableSet s) {f : α → ℝ} :
    ∫ x in s, f x ∂μ = ∫ x, f x * (s.indicator (1 : α → ℝ)) x ∂μ := by
  sorry
  -- Standard identity that can be derived from integral_indicator and properties of set integrals
  -- Not currently used in the main proof below

/-- **Projection under conditional independence (rectangle + π-λ approach).**

If Y ⊥⊥_W Z (conditional independence), then for any integrable f:
  E[f(Y) | σ(Z,W)] = E[f(Y) | σ(W)] a.e.

**Key insight:** We prove equality by showing both sides have matching integrals on all
σ(Z,W)-measurable sets, using:
1. Rectangle identity on S ∩ Z^{-1}(B) for S ∈ σ(W), B ∈ B_Z
2. π-λ theorem to extend to all of σ(Z,W)
3. Uniqueness of conditional expectation

**This bypasses the disintegration bottleneck:** We never prove E[f(Y)|σ(Z,W)] is σ(W)-measurable
directly. Instead, we show it equals E[f(Y)|σ(W)] (which is already σ(W)-measurable), so
measurability comes for free from uniqueness.
-/
theorem condExp_project_of_condIndepFun
    {Ω βY βZ βW : Type*}
    {mΩ : MeasurableSpace Ω} {μ : Measure Ω} [IsProbabilityMeasure μ]
    [MeasurableSpace βY] [MeasurableSpace βZ] [MeasurableSpace βW]
    [StandardBorelSpace Ω] [StandardBorelSpace βY] [StandardBorelSpace βZ] [StandardBorelSpace βW]
    [Nonempty βY] [Nonempty βZ] [Nonempty βW]
    {Y : Ω → βY} {Z : Ω → βZ} {W : Ω → βW}
    (hY : Measurable Y) (hZ : Measurable Z) (hW : Measurable W)
    (hCI : ProbabilityTheory.CondIndepFun (MeasurableSpace.comap W inferInstance)
                                           (by intro s hs; obtain ⟨t, ht, rfl⟩ := hs; exact hW ht)
                                           Y Z μ)
    {f : βY → ℝ} (hf_int : Integrable (f ∘ Y) μ) :
    μ[ f ∘ Y | MeasurableSpace.comap (fun ω => (Z ω, W ω)) inferInstance ]
      =ᵐ[μ]
    μ[ f ∘ Y | MeasurableSpace.comap W inferInstance ] := by
  -- Shorthand
  set mW  := MeasurableSpace.comap W inferInstance
  set mZ  := MeasurableSpace.comap Z inferInstance
  set mZW_prod := MeasurableSpace.comap (fun ω => (Z ω, W ω)) inferInstance with hmZW_prod_def
  set mZW := mZ ⊔ mW with hmZW_def

  have hmW_le : mW ≤ mΩ := by intro s hs; obtain ⟨t, ht, rfl⟩ := hs; exact hW ht
  have hmZ_le : mZ ≤ mΩ := by intro s hs; obtain ⟨t, ht, rfl⟩ := hs; exact hZ ht
  have hmZW_le : mZW ≤ mΩ := sup_le hmZ_le hmW_le
  have hmW_le_mZW : mW ≤ mZW := le_sup_right
  have hmZ_le_mZW : mZ ≤ mZW := le_sup_left

  -- Key: σ(Z,W) product equals σ(Z) ⊔ σ(W)
  have hmZW_prod_eq : mZW_prod = mZW := by
    -- Use mathlib's comap_prodMk: (mβ.prod mγ).comap (Z, W) = mβ.comap Z ⊔ mγ.comap W
    exact MeasurableSpace.comap_prodMk Z W

  -- Define g := E[f(Y)|σ(W)]
  set g := μ[ f ∘ Y | mW ] with hg_def

  -- Step 1: Rectangle identity (key conditional independence application)
  have h_rect : ∀ (S : Set Ω) (hS : MeasurableSet[mW] S) (hμS : μ S < ∞)
                  (B : Set βZ) (hB : MeasurableSet B),
      ∫ x in S ∩ Z ⁻¹' B, g x ∂μ = ∫ x in S ∩ Z ⁻¹' B, (f ∘ Y) x ∂μ := by
    intro S hS hμS B hB
    sorry
    /-
    **Mathematical Argument (conditional independence factorization):**

    **Goal:** ∫_{S∩Z⁻¹(B)} g = ∫_{S∩Z⁻¹(B)} f(Y)

    **LHS computation:**
    1. g = E[f(Y)|W] is σ(W)-measurable (by stronglyMeasurable_condExp)
    2. S ∈ σ(W) (hypothesis), so g·1_S is σ(W)-measurable
    3. ∫_{S∩Z⁻¹(B)} g = ∫ g·1_S·1_{Z⁻¹(B)} = E[g·1_S·1_{Z⁻¹(B)}]
    4. By tower property: = E[E[g·1_S·1_{Z⁻¹(B)}|W]]
    5. Pull out σ(W)-measurable function g·1_S:
       = E[g·1_S·E[1_{Z⁻¹(B)}|W]]

    **RHS computation:**
    1. ∫_{S∩Z⁻¹(B)} f(Y) = E[f(Y)·1_S·1_{Z⁻¹(B)}]
    2. Tower property: = E[E[f(Y)·1_S·1_{Z⁻¹(B)}|W]]
    3. Pull out σ(W)-measurable indicator 1_S:
       = E[1_S·E[f(Y)·1_{Z⁻¹(B)}|W]]

    **Conditional independence step (KEY):**
    4. By CondIndepFun, need to show:
       E[f(Y)·1_{Z⁻¹(B)}|W] = E[f(Y)|W]·E[1_{Z⁻¹(B)}|W]

    5. This requires extending CondIndepFun from indicators to bounded measurable functions.
       The definition CondIndepFun uses indicator functions, but we need it for f(Y).

    6. Once we have factorization:
       E[1_S·E[f(Y)·1_{Z⁻¹(B)}|W]] = E[1_S·g·E[1_{Z⁻¹(B)}|W]]
                                      = E[g·1_S·E[1_{Z⁻¹(B)}|W]]
       which matches the LHS!

    **Implementation challenges:**

    A. **Extension to bounded measurables:**
       - CondIndepFun is defined via indicator factorization
       - Need lemma: CondIndepFun + f integrable → factorization for f
       - This is the "monotone class" extension from the definition comments
       - Could use: approximate f by simple functions, pass to limit

    B. **Pulling out measurable functions from CE:**
       - Need: E[h·g|m] = h·E[g|m] when h is m-measurable
       - Mathlib has: condExp_smul or similar
       - For indicators: use condExp_set_eq or setIntegral_condExp

    C. **Tower property application:**
       - Need: E[E[g|W]|W] = E[g|W]
       - This is just condExp_condExp_of_le

    **Proposed implementation path:**

    Option 1: Prove extension lemma separately
      lemma condIndepFun_integral_eq : CondIndepFun m hm Y Z μ →
        Integrable (f ∘ Y) μ → Integrable (1_{Z⁻¹(B)}) μ →
        E[f(Y)·1_{Z⁻¹(B)}|W] = E[f(Y)|W]·E[1_{Z⁻¹(B)}|W]
      Then use this in h_rect.

    Option 2: Use approximation directly in this proof
      - Approximate f by simple functions fₙ
      - Apply CondIndepFun to each simple function piece
      - Pass to limit using dominated convergence

    Option 3: Acknowledge complexity and defer
      - This is mathematically sound but technically demanding
      - Could be factored into a separate lemma file
      - For now, keep as sorry with complete documentation

    **Recommendation:** Option 3 for now (keep as sorry), then return to prove
    the extension lemma separately. This unblocks the rest of the proof structure.
    -/

  -- Step 2: π-λ extension to all σ(Z,W)-sets
  have h_all : ∀ (T : Set Ω), MeasurableSet[mZW] T → μ T < ∞ →
      ∫ x in T, g x ∂μ = ∫ x in T, (f ∘ Y) x ∂μ := by
    intro T hT hμT

    -- Define the class of sets where integral equality holds
    -- C(T) := (T ∈ σ(Z,W) ∧ μ T < ∞ → ∫_T g = ∫_T f(Y))

    -- Apply induction_on_inter (π-λ induction principle)
    -- Key mathlib lemma: MeasurableSpace.induction_on_inter
    sorry
    /-
    **Dynkin System (π-λ) Argument using mathlib's induction_on_inter:**

    **Key mathlib lemma:** MeasurableSpace.induction_on_inter
    This provides induction over σ-algebras generated by π-systems with Dynkin properties.

    **Step 1: Define rectangles generating σ(Z,W)**
    Let R := {S ∩ Z⁻¹(B) : S ∈ σ(W), B ∈ B_Z}

    We need to show:
    a) R is a π-system (closed under intersections)
    b) generateFrom R = mZW
    c) For all T ∈ R with μ T < ∞: ∫_T g = ∫_T f(Y) (by h_rect)

    **Step 2: Apply induction_on_inter**
    Use: MeasurableSpace.induction_on_inter (h_eq : mZW = generateFrom R) (h_inter : IsPiSystem R)

    Verify the Dynkin properties for C(T) := (μ T < ∞ → ∫_T g = ∫_T f(Y)):

    1. **Empty set:** ∫_∅ g = 0 = ∫_∅ f(Y) ✓

    2. **Basic (rectangles):** For T ∈ R, this holds by h_rect ✓

    3. **Complement:** If C(T) holds and μ Tᶜ < ∞, then:
       ∫_Tᶜ g = ∫_Ω g - ∫_T g = ∫_Ω f(Y) - ∫_T f(Y) = ∫_Tᶜ f(Y)
       (Uses: IsProbabilityMeasure so μ Ω = 1 < ∞)

    4. **Disjoint union:** If C(Tₙ) for pairwise disjoint {Tₙ} and μ(⋃ Tₙ) < ∞, then:
       ∫_{⋃ Tₙ} g = ∑ ∫_{Tₙ} g = ∑ ∫_{Tₙ} f(Y) = ∫_{⋃ Tₙ} f(Y)
       (Uses: lintegral_iUnion or tsum_integral)

    **Implementation:**
    - Use `refine induction_on_inter hmZW_eq_R h_piSystem ?empty ?basic ?compl ?union`
    - Each case is a standard integral manipulation
    - Main technical work: defining R and proving it generates mZW

    **Alternative:** If defining R is complex, could use direct Dynkin system construction
    with DynkinSystem.generate and generateFrom_eq.
    -/

  -- Step 3: Apply uniqueness
  have g_aesm_mZW : AEStronglyMeasurable[mZW] g μ := by
    -- g is mW-measurable, and mW ≤ mZW, so g is mZW-measurable
    have hg_mW : StronglyMeasurable[mW] g := stronglyMeasurable_condExp
    -- Use monotonicity: m ≤ m' → StronglyMeasurable[m] f → StronglyMeasurable[m'] f
    exact (hg_mW.mono hmW_le_mZW).aestronglyMeasurable

  -- Apply uniqueness to get μ[f∘Y|mZW] = g
  have result_mZW : μ[ f ∘ Y | mZW ] =ᵐ[μ] g := by
    -- Use ae_eq_condExp_of_forall_setIntegral_eq from mathlib
    -- Parameters: (hm : m ≤ m₀) (hf_int : Integrable f μ) (integrableOn) (h_matching) (aesm)
    -- Returns: g =ᵐ[μ] μ[f|m], so we need .symm for μ[f|m] =ᵐ[μ] g
    refine (ae_eq_condExp_of_forall_setIntegral_eq hmZW_le hf_int ?integrableOn h_all g_aesm_mZW).symm
    · -- Integrability of g on finite-measure mZW-sets
      intro T hT hμT
      exact integrable_condExp.integrableOn

  -- Use mZW_prod = mZW to rewrite LHS, then apply result
  have : μ[ f ∘ Y | mZW_prod ] =ᵐ[μ] μ[ f ∘ Y | mZW ] := by
    rw [hmZW_prod_eq]
  -- Chain: μ[f∘Y|mZW_prod] = μ[f∘Y|mZW] = g = μ[f∘Y|mW]
  calc μ[ f ∘ Y | mZW_prod ] =ᵐ[μ] μ[ f ∘ Y | mZW ] := this
    _ =ᵐ[μ] g := result_mZW
    _ = μ[ f ∘ Y | mW ] := hg_def

end MeasureTheory

end
