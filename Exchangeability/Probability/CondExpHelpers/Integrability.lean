/-
Copyright (c) 2025 Cameron Freer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Cameron Freer
-/
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Basic
import Mathlib.MeasureTheory.Function.ConditionalExpectation.Unique
import Mathlib.MeasureTheory.Function.AEEqOfIntegral
import Mathlib.Probability.ConditionalExpectation
import Mathlib.Probability.Independence.Conditional

/-!
# Integrability and σ-algebra Factorization for Conditional Expectation

This file provides integrability lemmas, uniqueness arguments, and σ-algebra factorization
lemmas for conditional expectations.

## Main results

* `integrable_mul_of_bound_one`: Product with bounded factor is integrable
* `abs_condExp_le_condExp_abs`: Jensen's inequality for conditional expectation
* `condExp_indicator_ae_bound_one`: CE of indicator is a.e. in [0,1]
* `sigma_factor_le`: Pullback σ-algebra inequality for factorizations
-/

noncomputable section
open scoped MeasureTheory ENNReal BigOperators
open MeasureTheory ProbabilityTheory Set

/-!
## Integrability of products with bounded factors
-/

/-- If `f ∈ L¹(μ)` and `g` is a.e. bounded by `1`, then `g⋅f ∈ L¹(μ)`. -/
lemma integrable_mul_of_bound_one
  {Ω : Type*} [MeasurableSpace Ω] {μ : Measure Ω}
  {f g : Ω → ℝ}
  (hf : Integrable f μ)
  (hg_meas : AEStronglyMeasurable g μ)
  (hbound : ∀ᵐ ω ∂μ, ‖g ω‖ ≤ (1 : ℝ)) :
  Integrable (fun ω => g ω * f ω) μ := hf.bdd_mul hg_meas hbound

/-- **Jensen's inequality for conditional expectation**: the absolute value of a conditional
expectation is a.e. bounded by the conditional expectation of the absolute value.

For integrable `f`: `|μ[f|m]| ≤ μ[|f||m]` almost everywhere.
-/
@[nolint unusedArguments]
lemma abs_condExp_le_condExp_abs
    {Ω : Type*} {m m₀ : MeasurableSpace Ω} {μ : Measure Ω}
    (hm : m ≤ m₀) [SigmaFinite (μ.trim hm)]
    {f : Ω → ℝ}
    (hf : Integrable f μ) :
    ∀ᵐ ω ∂μ, |(μ[f|m]) ω| ≤ (μ[(fun ω => |f ω|)|m]) ω := by
  -- Upper bound: μ[f|m] ≤ μ[|f||m]
  have h_up : μ[f|m] ≤ᵐ[μ] μ[(fun ω => |f ω|)|m] := by
    refine condExp_mono hf ?_ ?_
    · exact hf.abs
    · apply Filter.Eventually.of_forall
      intro ω; exact le_abs_self _
  -- Lower bound: -μ[|f||m] ≤ μ[f|m]
  -- Proof: f ≥ -|f| pointwise, so μ[f|m] ≥ μ[-|f||m] = -μ[|f||m]
  have h_low : (fun ω => -(μ[(fun ω => |f ω|)|m]) ω) ≤ᵐ[μ] μ[f|m] := by
    have neg_abs_bound : (fun ω => -(|f ω|)) ≤ᵐ[μ] f := by
      apply Filter.Eventually.of_forall
      intro ω; exact neg_abs_le _
    have ce_ineq : μ[(fun ω => -(|f ω|))|m] ≤ᵐ[μ] μ[f|m] :=
      condExp_mono hf.abs.neg hf neg_abs_bound
    have neg_eq : (fun ω => -(μ[(fun ω => |f ω|)|m]) ω) =ᵐ[μ] μ[(fun ω => -(|f ω|))|m] :=
      (condExp_neg (fun ω => |f ω|) m).symm
    exact neg_eq.le.trans ce_ineq
  -- Combine: |x| ≤ y iff -y ≤ x ≤ y
  filter_upwards [h_up, h_low] with ω hup hlow
  rw [abs_le]
  exact ⟨hlow, hup⟩

/-- The conditional expectation of an indicator (ℝ-valued) is a.e. in `[0,1]`. -/
lemma condExp_indicator_ae_bound_one
  {Ω β : Type*} {m0 : MeasurableSpace Ω} {μ : Measure Ω} [IsFiniteMeasure μ]
  {mW : MeasurableSpace Ω} (hm : mW ≤ m0)
  {Z : Ω → β} [MeasurableSpace β] {B : Set β}
  (hZ : @Measurable Ω β m0 _ Z) (hB : MeasurableSet B) :
  ∀ᵐ ω ∂μ,
    0 ≤ MeasureTheory.condExp mW μ
          (fun ω => (Set.indicator (Z ⁻¹' B) (fun _ => (1 : ℝ)) ω)) ω
    ∧
    MeasureTheory.condExp mW μ
          (fun ω => (Set.indicator (Z ⁻¹' B) (fun _ => (1 : ℝ)) ω)) ω ≤ 1 := by
  have h_int : Integrable (Set.indicator (Z ⁻¹' B) (fun _ => (1 : ℝ))) μ :=
    (integrable_const 1).indicator (hZ hB)
  have h0 : ∀ᵐ ω ∂μ, (0 : ℝ) ≤ Set.indicator (Z ⁻¹' B) (fun _ => (1 : ℝ)) ω :=
    .of_forall fun ω => Set.indicator_nonneg (fun _ _ => zero_le_one) ω
  have h1 : ∀ᵐ ω ∂μ, Set.indicator (Z ⁻¹' B) (fun _ => (1 : ℝ)) ω ≤ 1 :=
    .of_forall fun ω => Set.indicator_le_self' (fun _ _ => zero_le_one) ω
  have hCE1 : μ[Set.indicator (Z ⁻¹' B) (fun _ => (1 : ℝ)) | mW] ≤ᵐ[μ] μ[fun _ => (1 : ℝ) | mW] :=
    condExp_mono h_int (integrable_const _) h1
  filter_upwards [condExp_nonneg h0, hCE1] with ω h0' h1'
  simp only [condExp_const hm (1 : ℝ)] at h1'
  exact ⟨h0', h1'⟩

/-!
## σ-algebra factorization
-/

/-- **Pullback σ-algebra inequality for factorizations.**

If `η = g ∘ ζ` with `g` measurable, then the σ-algebra generated by `η`
is contained in the σ-algebra generated by `ζ`.

This is the fundamental fact about σ-algebra factorization: knowing `ζ` gives
you at least as much information as knowing `η = g(ζ)`.

**Mathematical statement:** σ(η) ≤ σ(ζ) when η = g ∘ ζ.
-/
@[nolint unusedArguments]
lemma sigma_factor_le {Ω α β : Type*}
    [MeasurableSpace Ω] [MeasurableSpace α] [MeasurableSpace β]
    {η : Ω → α} {ζ : Ω → β} {g : β → α}
    (hη : η = g ∘ ζ) (hg : Measurable g) :
    MeasurableSpace.comap η inferInstance ≤ MeasurableSpace.comap ζ inferInstance := by
  rw [hη, MeasurableSpace.comap_comp.symm]
  exact MeasurableSpace.comap_mono hg.comap_le

namespace MeasureTheory

/-!
## Wrappers for dominated convergence and L¹ continuity
-/

/-- **Restricted dominated convergence: L¹ convergence implies set integral convergence.**

If fn → f in L¹(μ), then ∫_s fn → ∫_s f for any measurable set s.

This requires integrability hypotheses to ensure the integrals are well-defined. -/
lemma tendsto_set_integral_of_L1 {α : Type*} [MeasurableSpace α] {μ : Measure α}
    {s : Set α}
    {fn : ℕ → α → ℝ} {f : α → ℝ}
    (hf_int : Integrable f μ)
    (hfn_int : ∀ n, Integrable (fn n) μ)
    (hL1 : Filter.Tendsto (fun n => ∫⁻ ω, ‖(fn n) ω - f ω‖₊ ∂μ) Filter.atTop (nhds 0)) :
  Filter.Tendsto (fun n => ∫ ω in s, (fn n) ω ∂μ) Filter.atTop (nhds (∫ ω in s, f ω ∂μ)) := by
  -- Direct application of mathlib's tendsto_setIntegral_of_L1
  apply MeasureTheory.tendsto_setIntegral_of_L1 f hf_int _ hL1 s
  -- Show that fn is eventually integrable
  filter_upwards with n
  exact hfn_int n

/-- **L¹ convergence of product with bounded factor.**

If fn → f in L¹ and H is bounded a.e., then ∫_s (fn * H) → ∫_s (f * H). -/
lemma tendsto_set_integral_mul_of_L1 {α : Type*} [MeasurableSpace α] {μ : Measure α}
    {s : Set α}
    {fn : ℕ → α → ℝ} {f H : α → ℝ} {C : ℝ}
    (hf_int : Integrable f μ)
    (hfn_int : ∀ n, Integrable (fn n) μ)
    (hH_int : Integrable H μ)
    (hL1 : Filter.Tendsto (fun n => ∫⁻ ω, ‖(fn n) ω - f ω‖₊ ∂μ) Filter.atTop (nhds 0))
    (hC : 0 ≤ C)
    (hH_bdd : ∀ᵐ ω ∂μ, ‖H ω‖ ≤ C) :
  Filter.Tendsto (fun n => ∫ ω in s, (fn n) ω * H ω ∂μ)
          Filter.atTop
          (nhds (∫ ω in s, f ω * H ω ∂μ)) := by
  -- Strategy: Show fn * H → f * H in L¹, then apply tendsto_setIntegral_of_L1
  apply MeasureTheory.tendsto_setIntegral_of_L1 (fun ω => f ω * H ω) _ _ _ s
  · -- Goal (a): Show f * H is integrable
    -- Apply bdd_mul: bounded function H times integrable function f
    have := hf_int.bdd_mul hH_int.aestronglyMeasurable hH_bdd
    simpa only [mul_comm] using this
  · -- Goal (b): Show fn * H is eventually integrable
    filter_upwards with n
    have := (hfn_int n).bdd_mul hH_int.aestronglyMeasurable hH_bdd
    simpa only [mul_comm] using this
  · -- Goal (c): Show ∫⁻ ‖(fn * H) - (f * H)‖₊ → 0
    -- Bound ∫⁻ ‖(fn - f) * H‖₊ by C * ∫⁻ ‖fn - f‖₊
    have h_bound : ∀ n, ∫⁻ ω, ‖(fn n) ω * H ω - f ω * H ω‖₊ ∂μ
                      ≤ ENNReal.ofReal C * ∫⁻ ω, ‖(fn n) ω - f ω‖₊ ∂μ := by
      intro n
      calc ∫⁻ ω, ‖(fn n) ω * H ω - f ω * H ω‖₊ ∂μ
          = ∫⁻ ω, ‖((fn n) ω - f ω) * H ω‖₊ ∂μ := by
            congr 1; ext ω; rw [sub_mul]
        _ = ∫⁻ ω, (‖(fn n) ω - f ω‖₊ * ‖H ω‖₊ : ℝ≥0∞) ∂μ := by
            congr 1; ext ω
            simp only [← ENNReal.coe_mul, nnnorm_mul]
        _ ≤ ∫⁻ ω, (‖(fn n) ω - f ω‖₊ * Real.toNNReal C : ℝ≥0∞) ∂μ := by
            apply lintegral_mono_ae
            filter_upwards [hH_bdd] with ω hω
            gcongr
            -- For real numbers: ‖x‖₊ ≤ C.toNNReal follows from ‖x‖ ≤ C
            show ‖H ω‖₊ ≤ Real.toNNReal C
            calc ‖H ω‖₊
                = Real.toNNReal ‖H ω‖ := norm_toNNReal.symm
              _ ≤ Real.toNNReal C := Real.toNNReal_le_toNNReal hω
        _ = ENNReal.ofReal C * ∫⁻ ω, ‖(fn n) ω - f ω‖₊ ∂μ := by
            rw [← lintegral_const_mul' _ (fun ω => ‖(fn n) ω - f ω‖₊) ENNReal.ofReal_ne_top]
            congr 1; ext ω
            -- Need: ↑‖fn n ω - f ω‖₊ * ↑(Real.toNNReal C) = ENNReal.ofReal C * ↑‖fn n ω - f ω‖₊
            rw [mul_comm]
            simp only [ENNReal.ofReal_eq_coe_nnreal hC]
            congr 1
            exact congr_arg ENNReal.ofNNReal (Real.toNNReal_of_nonneg hC)
    -- Apply squeeze theorem with C * hL1 → C * 0 = 0
    have h_limit : Filter.Tendsto (fun n => ENNReal.ofReal C * ∫⁻ ω, ‖(fn n) ω - f ω‖₊ ∂μ)
        Filter.atTop (nhds 0) := by
      convert ENNReal.Tendsto.const_mul hL1 (Or.inr ENNReal.ofReal_ne_top) using 2
      simp [mul_zero]
    -- Apply sandwichtendsto_of_tendsto_of_tendsto_of_le_of_le
    exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds h_limit
      (fun n => zero_le _) h_bound

end MeasureTheory

end
